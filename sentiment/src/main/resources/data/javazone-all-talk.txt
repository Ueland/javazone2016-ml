The talk will introduce the concepts and benefits of process-driven configuration and change management tools. (The presentation will be given in Norwegian.)
The talk will be targeted at developers, team leaders and software development project managers. It will introduce the concepts and benefits of process-driven configuration and change management tools in general and within the context of the Software Engineering Institute’s capability maturity model and process-oriented management concepts (such as ITIL). The talk will then continue in a technical vein and address (among others): Handling the lifecycle of an application from development to production and into maintenance Simplified branching to prevent the regression of bugs in the context of AllFusion Harvest parallel and regression development - how to handle new development simultaneously with bug fixes on a previous release Automating the build - multiple versions of JRE/JDK Backing up deployment of EJBs/EARs onto a J2EE application server Handling common code in a Java environment

Rule engines in java programming, why and how.
There is a trend in building smarter and smarter software, where the aim of the software is to represent knowledge of some specific application area. Knowledge can be defined as "productive use of information", and can be represented on the form "IF (list of condtitons) THEN do list of actions". The reasons why knowledge is important includes supporting users to perform better choices, such as the book recomendations at Amazon, automate business processes and to build more flexible and adaptive software. The most common tools used to support knowledge representation is the rule engine. The key problem to resolve within a rule engine is execution time. This has been addressed and resolved by the RETE algorithm, where there exist powerfull implementations such as JRULES from ILOG and JESS, products that implements the interfaces defined in JSR-94, the Java standard for rule engine interfaces. During this lecture the issues adressed above will be presented and examples at code level will be presented.

Mange av Accentures ansatte har den siste tiden arbeidet med å sertifisere seg som Java Programmer og Enterprise Architect. Denne presentasjonen vil summere opp erfaringer fra dette arbeidet og vurdere nytteverdien av disse sertifiseringene.
Mange av Accentures ansatte har den siste tiden arbeidet med å sertifisere seg som Java Programmer og Enterprise Architect. Denne presentasjonen vil summere opp erfaringer fra dette arbeidet og vurdere nytteverdien av disse sertifiseringene: Hvilke forberedelser har kandidatene gjort Hvilke verktøy har kandidatene brukt, og hva er erfaringene med disse Hvordan har prosessen med sertifiseringene vært Hvilken nytte har man fått av prosessen utover selve sertifiseringen Hvor mye forteller sertifiseringen om kompetansen til kandidatene

So you think you know Java? This talk will help you answer that question. Statistics show that real-life experience in Java programming alone is not sufficient for passing the certification exam. The exam requires in depth knowledge of features and usage of the Java programming language. The talk provides a roadmap for achieving the right level of proficiency demanded by the certification exam.
So you think you know Java? This talk will help you answer that question. Statistics show that real-life experience in Java programming alone is not sufficient for passing the certification exam. The exam requires in depth knowledge of features and usage of the Java programming language. The talk provides a roadmap for achieving the right level of proficiency demanded by the certification exam. First we answer some questions about Java certification: What is certification. Why get certified. Who should get certified. How to get certified. How to plan, study and prepare for certification. Where to get certification resources. The main part of the talk will concentrate on giving examples which provide insights into some of the topics that appear on the exam: Shift operators equals(), hashCode() and compareTo() methods Intern strings Upcasting and downcasting Exception scenarios with try-catch-finally Overriding and overloading Nested classes Thread communication Audience participation will be solicited.

Sesjonen vil gi en innføring i filosofi og tankesett rundt Aspektorientert Programmering, en diskusjon rundt implementeringsstrategier for AOP i Java, samt endel eksempler på hvordan komme igang med AOP og eksempler på fornuftig bruk av AOP.
Agenda: What is AOP? How does it work? Examples What's in it for me? Further reading

A discussion of the MVC pattern
MVC was conceived in 1978 as the design solution to a particular problem. The top level goal was to support the user's mental model of the relevant information space and to enable the user to inspect and edit this information. The first part of the talk describes the original problem and discusses the chosen solution. The second part elaborates the original ideas and extends the scope to include current day challenges to the original goal. We examine some ideas related to MVC that are found in the literature and select those that appear to be particularly relevant to the top level goal. The third and final part summarizes it all in a condensed and coherent MVC pattern language.

- Thirteen Recommendations for Refactoring, Repairing and Regaining Control of Your Code This session outlines a concrete thirteen-point list of practices (zero through twelve) that can be applied out-of-the-box to reduce code size and complexity, acting as both guidelines for new code and indicators for refactoring.
There is no shortage of technical wisdom on how to develop clear and robust code, so why the confused expression on many a programmer's face when staring at all those source files, trying to make sense of the encrypted code? There are companies whose development culture does not encourage pursuit of knowledge of practice: a penny-wise pound-foolish approach. However, there are many companies and developers that want to push themselves to the state of the art, but seem swamped and bemused by how much state there really is to that art. This session outlines a concrete thirteen-point list of practices (zero through twelve) that can be applied out-of-the-box to reduce code size and complexity, acting as both guidelines for new code and indicators for refactoring. The short list has no ambition to be all that you needed to know about design but were afraid to ask, but it does offer an easily memorable and easily practised set of guidelines that offer the greatest immediate return on investment - the most bang for your buck, oomph for your euro or kerrang for your kroner.

Will Rogers, the noted American philosopher, said, "It isn't what we don't know that gives us trouble, it's what we know that ain't so." What is it we know about software development that ain't so?
Will Rogers, the noted American philosopher, said, "It isn't what we don't know that gives us trouble, it's what we know that ain't so." What is it we know about software development that ain't so? Specialization of labor Quality department Programming Done Defects How would we act if we knew better?

This talk describes the proposed changes in release 1.5 of the Java(tm) 2 Platform, Standard Edition, and show how they work together to improve the language.
A number of significant language enhancements are slated for release 1.5 of the Java(tm) 2 Platform, Standard Edition (J2SE 1.5, code-named "Tiger").  The purpose of these enhancements is to make the Java programming language more expressive, developer-friendly, and safer, while minimizing incompatibility with preexisting programs.  These changes, covered by Java Community Process JSRs 14, 175 and 201, include generics, typesafe enums, autoboxing, an enhanced for-loop, a static import facility, and a metadata facility.  In this talk, we describe the proposed changes and show how they work together to improve the language.

Joshua Bloch and Neal Gafter (also known as "Click and Hack, the Type-It Brothers") present ten more programming puzzles for your entertainment and enlightenment.
Joshua Bloch and Neal Gafter (also known as "Click and Hack, the Type-It Brothers") present ten more programming puzzles for your entertainment and enlightenment. The game show format keeps you on your toes while the puzzles teach you about the subtleties of the Java(tm) programming language and its core libraries. Anyone with a working knowledge of the language will be able to understand the puzzles, but even the most seasoned veterans will be challenged by them.  The lessons you take from this session are directly applicable to your programs and designs. And some of the jokes may even be funny. This is an entirely different set of puzzles from last year's JavaOne talk ("Programming Puzzlers"). If you hated "Programming Puzzlers," you'll detest "More Programming Puzzlers"! Overripe fruit will be provided to the first 50 attendees, so come early!

This talk will focus on the more advanced topics of AOP, specifically weaving, persistence and loading policies, advanced trics and some AOP issues.
Agenda What is AOP? Weaving Static versus dynamic Weaving and persistence Loding policies Advanced tricks Problems with AOP

Tool Mimicry in the OO World
Tool Mimicry in the OO World

This session will cover some of the techniques and tools that can allow the developer to improve quality, maintainability and productivity, including profiling, unit testing, visualisation and code analysis.
On average, 30% of total project cost is spent on rework. Attempts at reducing project cost focus on improving developer productivity and all too often forget the critical issues of improving quality and maintainability. This session will cover some of the techniques and tools that can allow the developer to improve quality, maintainability and productivity. Subjects covered include: Profiling: Look inside the JVM & J2EE black boxes and regain control Unit Testing: Integrate Unit Testing earlier into the development cycle Visualisation: Multiple ways to visualise runtime and static behaviour Code Analysis: Static analysis of code to enforce coding standards and collect metrics

Modelldrevet utvikling med open source-verktøy.
Denne presentasjonen viser en modelldrevet tilnærming for effektiv og enkel utvikling av J2EE-applikasjoner. UML brukes for å beskrive komponenter og grensesnitt. Ulike kodegenereringsverktøy brukes for å generere session- og entity-komponenter fra modellene. Et eksempel blir brukt for å vise hvordan J2EE-løsninger kan automatiseres basert på modelleringsverktøy og kodegenerering. Eksempelet viser bruk av UML for modellering, et open source verktøy (UMT - UML Model Transformation Tool) for generering fra UML-modell til Java/XDoclet og ant build scripts, og hvordan dette blir tatt videre til J2EE/JBoss ved bruk av XDoclet. Hovedfokus vil ligge på bruk av UML og kodegenerering i modelldevet utvikling. Andre tilnærminger til automatisering/kodegenerering av systemutviklingen vil også bli belyst.

Middlegen er et kodegenereringsverktøy basert på JDBC, Velocity, Ant og XDoclet. Det er et Open Source prosjekt startet i Norge.
Middlegen er et kodegenereringsverktøy basert på JDBC, Velocity, Ant og XDoclet. Det er et Open Source prosjekt startet i Norge. Verktøyet bygger en modell ut fra database ved hjelp av JDBC meta-data. Diverse plugins benytter modellen sammen med Velocity templates til generering av kode. Det eksisterer foreløpig plugins for EJB CMP 2.0 (+ Struts), Hibernate og JDO. XDoclet benyttes til å ferdigstille koden med interfaces, deployment descriptors etc. Alt kjøres og pakkes med Ant script, slik at prosessen blir mest mulig automatisk. Sesjonen vil fokusere på generering av komplett database applikasjon, med Entity Beans (CMP 2.0), XDoclet value-objects, Session Bean Facade til JBoss applikasjonsserver. Muligens med live demonstrasjon. Den ferdige applikasjonen kan aksesseres av forskjellige klienter, som for eksempel Webapp/Struts eller J2SE Swing klient. Sesjonen kommer også til å ta for seg hvilke andre plugins som eksisterer, og hvordan man enkelt kan skrive egne custom plugins. Man vil også si noe om hvordan neste versjon av Middlegen kommer til å bli og trekke paralleller mot andre kodegenereringsverktøy. Prosjektside

Dette foredraget vil se nærmere på Hibernate og hvordan det kan brukes sammen med J2EE.
Dette foredraget vil se nærmere på Hibernate og hvordan det kan brukes sammen med J2EE. Foredraget vil bygge på erfaringer fra et prosjekt hvor Hibernate blir brukt og det vil dekke bl.a. følgende ting: Hvordan virker rammeverket? Verktøystøtte Transaksjonshåndtering Hvordan hentes data fra databasen? Cache-mekanismer Queryspråket til Hibernate Design-strategier: Top-down vs bottom-up Hibernate i en J2EE-setting Andre alternativer til Hibernate Andre erfaringer, gode og dårlige Hvis det blir tid vil det også bli kodeeksempler for å vise hvordan en del av disse tingene virker i praksis.

How to build a first-cut application using an MDA-based tool and how to modify it where necessary, allowing you to focus on the creative aspects of coding rather than the tedious, repetitive tasks.
The past has thought us that, in large projects with many developers, the model and the application drift apart and a point arrives when a reverse engineering exercise is tried. This often results in a model that is unintelligible, badly commented and laid out. So we now have a pretty model that doesn't reflect the code or a messy one that is true but unusable. Typically the analysts continue to work with their tidy model and the developers stick with the 'code view'. MDA-based tools unite model and code so that they can't drift apart. This presentation/demonstration will explain the MDA concepts, how OptimalJ maps to MDA and OptimalJ's implementation of MDA, which focuses on models and patterns. You will see how to build a first-cut application using an MDA-based tool and how to modify it where necessary, allowing you to focus on the creative aspects of coding rather than the tedious, repetitive tasks.

This session tries to unscramble the architecture and acronym soup and clearly explains the differences and details of the standards and how they fit together.
With the broad adoption of Web services we find an explosion in standards activity that can confuse the most adept amongst us as we follow and decode the activities and products that support them. Core Web services built on a basic stack of SOAP, WSDL, UDDI and XML to provide Messaging, Discovery and Description services are generally accepted and understood within the community. But the architecture and standards layers don’t stop there. New and emerging standards build the necessary layers of architecture support for the Plug and Play Business embracing : Security ( with Liberty, XACML and SAML ), Reliable Messaging (with WS-RM), Transactions, Coordination and Choreography (with BPEL4WS, WSCI) with an end game of business process standardisation through ebXML and RosettaNet and compute resource on demand from Grid services through the GLOBUS alliance. This session tries to unscramble the architecture and acronym soup and clearly explains the differences and details of the standards and how they fit together into an SOA approach for software development and organisational collaboration and maps these standards into a forward vision for the Oracle technology stack.

A story of the issues developers will face on the road from Hell to Oslo An attempt to walk through some of the most common misconceptions in today's modern development architecture and discuss the issues at hand.
An attempt to walk through some of the most common misconceptions in today's modern development architecture and discuss the issues at hand. (An interesting side aspect is that we today have many of the leading architects at our show, the ones who are (at least partly) responsible for this mess) Agenda: Mistaken presumptions (1) Limitations of the Java programming language (3) Missing inside knowledge (3) Pattern mistakes (2) Environment coupling mistakes (5) The issues covered in this talk can also be aggregated as follows: Hardware/infrastructure (1) Core Java (6) Enterprise Java/EJB (8) Metodology (2)

John Crupi will discuss the six new patterns in the Core J2EE Patterns catalog.
John Crupi will discuss the six new patterns in the Core J2EE Patterns catalog. The Core J2EE Patterns [CJP]1st edition contains 15 patterns and was released in June 2001. The 2nd edition was just released in June 2003 has been completely updated to reflect J2EE 1.4 and contains 6 new patterns. John will briefly cover the history of the pattern catalog and provide details into the six new patterns. Finally, John will briefly discuss Micro Architectures which was introduced in the CPJ 2nd edition. A Micro Architecture is a prescriptive design solution which leverages patterns and is applied to a larger grained problem.

how to make an enterprise architecture around the oo model.
Object models are the best known tool to handle complexity and change. Yet main-stream enterprise arkitectures downplay the role of the oo model at best. The session will show very concretely how to make an architecture around the oo model which addresses the requirements of enterprise applications better than the main-stream non-oo enterprise architectures.

When dealing with distributed enterprise applications, designing functionality in terms of services can promote flexibility, and result in easy to use APIs across application domains. Lower coupling and improved cross-application reusability can also be achieved when clearly separating services and data. Business logic in large-scale systems should be defined in terms of java interfaces and implemented in terms of distributed stateless services. By then encapsulating service invocation using java 1.3 Dynamic Proxies, we can both get a high degree of flexibility and have simple to use client APIs as a result.
When designing enterprise applications, being able to create understandable API's is important. The same API's should also easily lend themself to distribution in form of J2EE SLSB's or Web Services, providing a centralized repository of services accessible from multiple platforms, channels and applications. When using services in a distributed environments, effort and focus tend to shifts from using business related functionality, to create Service locators, discuss home vs remote interfaces or web services, i.e. to discuss infrastructure. By defining some simple naming conventions for java classes and by the application of java 1.3 Dynamic Proxies; java idioms and simple framework from creating and using services in a distributed environment can be established. Everything related to infrastructure can be isolated in a few classes and hidden from the user, and code-generation can be kept to a minimum. The author has created a simple framework for accessing distributed services that: Uses a java interface for each service Uses a generic factory for getting an instance implementing the service Creates a chain of InvocationHandlers that can intercept method calls of the service Can dynamically add restricted time execution, and asynchroumos execution of the service

Bouvet was selected to build a new real time information feed for the nordic power exchange NordPool. Jini technology combined with the Creare RBNB was selected as the platform. The presentation will take a tour through the key demands, the chosen architecture down to code level.
Bouvet was selected to build a new real time information feed for the nordic power exchange NordPool, where the feed system is used to feed information syndicates with market information in real time. The nature of the system is best illustrated by some key requirements: Maximum delay of mesages 1,5 second from a trade has taken place and the information is delivered to customers Handle 100 messages / second in peak sequences of 3 seconds Required availability during opening hours 99.15% pr. 15 minute To meet the functional and non functional requirements a resilient and redundant design was required, and during analysis it became more and more clear that use of Jini technology combined with the Creare RBNB data turbine constituded the most cost efficient platform that met the requirements. With respect to Jini the Rio software was used, as it provided a higher abstraction level for developers and provided the key mekanisms for building an adaptable system. The presentation will take a tour through the key demands, the chosen architecture down to code level.

Hvordan Java-teknologier som JAAS og JACC kan brukes for å løse problemer knyttet til ende-til-ende autentisering og autorisasjon, og hvordan nye standarder for "digital identitet" (SAML, XACML, Liberty) kan kombineres med Java-teknologier for å lage løst koblede web-føderasjoner.
En av utfordringene med å lage løsninger som integrerer informasjon og tjenester fra mange forskjellige fagsystemer er autentisering og avgrensning av sluttbrukerens rettigheter i de ulike systemene. Som oftest har de ulike systemene egne sikkerhetsløsninger og opererer med ulike brukerbegreper. Sikkerhetsløsningen må dermed også omfatte hvordan identitet konsolideres og transformeres når informasjon og tjenester fra ulike systemer integreres. Dette gjelder både ved tette integrasjoner som når løsninger integreres gjennom en J2EE applikasjonstjener, og ved løse integrasjoner, som når løsninger integreres gjennom web føderasjoner eller web services. Vi skal se på hvordan Java-teknologier som JAAS og JACC kan brukes for å løse problemer knyttet til ende-til-ende autentisering og autorisasjon, og hvilken rolle disse teknologiene spiller i Javas sikkerhetsmodell. Vi skal også se på nye standarder innenfor det feltet vi kaller "digital identitet", og hvordan disse standardene kan kombineres med Java-teknologier for å lage løst koblede web-føderasjoner. Aktuelle standarder er SAML, XACML og Liberty. Vi skal videre se på hvordan støtte for autentisering med digitale sertifikat, for eksempel BankID, kan implementeres inn i det utvidbare JAAS-rammeverket.

Foredraget tar for seg hvilke forskjeller og likheter det er i funksjonalitet plattformene tilbyr, såvel som det evinnelige spørsmålet: Hvilken plattform er best?
I de siste 5 årene har Java vært den raskest voksende utviklingsplattformen i verden. Nå slår Microsoft tilbake. .NET er Microsofts visjon av en plattform for det nye årtusen. Begge miljøene har forkjempere som står på barrikadene og har sine sterke meninger. Dette foredraget tar for seg hvilke forskjeller og likheter det er i funksjonalitet plattformene tilbyr, såvel som det evinnelige spørsmålet: Hvilken plattform er best? Foredraget sammenliger hvilke løsninger plattformene tilbyr til utviklere av en n-lags enterprisemodell, mobile applikasjoner, og desktop-applikasjoner. Brodwall vil sammenligne sin erfaring på Java og .NET prosjekter når det gjelder integrasjon, sikkerhet og portabilitet, såvel som ikke-tekniske faktorer som opplæring, kostnad og filosofi.

J2ME Clients talking to J2EE Servers
Agenda Problems in end-to-end development J2ME Wireless Connection Wizard Demonstration

Et system utviklet for Statens Vegvesen hvor PDA'er benyttes for informasjonsutveksling.
Java på små "duppedingser" er ensbetydende med spill og moro for folk flest. For bedrifter kan J2ME også bety "nytteverdi", "besparinger", "fleksibilitet" og "suksess". Presentasjonen omhandler et system utviklet for Statens Vegvesen hvor PDA'er benyttes for informasjonsutveksling. Temaer som vil bli gjennomgått er valg av plattform (PersonalJava vs PersonalProfile), distribuert oppdatering av persistent informasjon ved hjelp av XML og et open-source rammeverk for brukergrensesnitt (Thinlet).

Introduction to MIDP 2.0
The Mobile Information Device Profile 2.0 includes many enhancements and new features. These cover gaming, audio, security, network protocols, user interface improvements and more. The latest version of the Java 2 Platform, Micro Edition (J2ME) Wireless Toolkit fully supports MIDP 2.0, as well as the Mobile Media and Wireless Messaging APIs. This session, for J2ME platform developers at all levels, gives a broad overview of these new features and their support in the J2ME Wireless Toolkit.

Discussion of the problems a developer faces when it comes to differentiating specs on various terminals on the market today, with references to real life models. There will also be focus on the various extensions existing in both Asia and the Western countries, and how to utilize these without breaking platform independence.
Discussion of the problems a developer faces when it comes to differentiating specs on various terminals on the market today, with references to real life models. The problems varies from the obvious like different screen sizes, language, CPU speed and input options to unofficial extensions you are "forced" to use and bugs in the Java implementation. There will also be focus on the various extensions existing in both Asia and the Western countries, and how to utilize these without breaking platform independence. This leads to the need for a complex versioning system, as many builds might result from each game, this will also be discussed. The presentation will also have a business angle, giving some views on the market today, locally, in Asia with some visions for the future.

Java 2 Platform, Standard Edition (J2SE) 1.5 is a major update to the language. The security features of the platform have made it a defacto platform of choice to implement end-to-end security. After attending this presentation you will walk away with a comprehensive overview of the security enhancements and their benefits, as well as how to use them using the Java Security APIs and tools.
Java 2 Platform, Standard Edition (J2SE) 1.5 is a major update to the language. The security features of the platform have made it a defacto platform of choice to implement end-to-end security. Attend this presentation to learn about the security enhancements in the J2SE 1.5 release, which include major enhancements in the areas of cryptographic token support, public key infrastructure (PKI), code signing and verification, and cryptography. After attending this presentation you will walk away with a comprehensive overview of the security enhancements and their benefits, as well as how to use them using the Java Security APIs and tools. It will, for example, detail how the newly added cryptographic token support enables smart card authentication and seamless access to hardware cryptographic accelerators.

The secrets of IoC - The PicoContainer advantage
The secrets of IoC - The PicoContainer advantage

An object is an object is an object, right? So you need objects for the big things in your system, and you can do the rest with integers and other primitives. This talk presents a set of patterns, connected into a pattern language, for defining value objects in Java.
An object is an object is an object, right? So you need objects for the big things in your system, and you can do the rest with integers and other primitives. Although this can be -- and is -- made to work, it is not make the best use of object orientation. Unfortunately it is the approach taken by many development methods and APIs. There are many different categories of object that can be used to express quite different concepts in a system. And yet many programming guidelines seek to have "one true way" of defining a class, what should go into its interface, what methods to provide, how to define them, etc. Perhaps the most commonly overlooked category is that of value objects, objects that represent fine-grained informational concepts in your system. Defining value objects is not simply about defining a "big object" class and leaving a few things out, the practices are quite different. This talk presents a set of patterns, connected into a pattern language, for defining value objects in Java. The talk includes coverage of the common pitfalls or oversights in both interface and representation design, and aims to present a reasoned, pragmatic and sparing approach to the use of Java's language features in expressing value concepts.

Java Generics (JG) has been the most sought-after feature by Java developers. Through examples, this tutorial explains usage and declaration of generic types and methods.
Java Generics (JG) has been the most sought-after feature by Java developers. It is now finally added to Java 1.5. JG provides extra type information at compile time to avoid verbosity and the need for explicit type checking and casting at runtime. It is implemented as compiler transformations, with insignificant impact on the JVM for backward compatibility. Through examples, this tutorial explains usage and declaration of generic types and methods. It also covers what impact JG has and how it relates to other features of the language. JG is touted to have a profound affect on how Java programs will be developed. To understand the underpinnings and limitations of JG, the tutorial also covers the following topics: Type Parameter Bounds, Wildcards, Generic Methods, Raw Types, and Type Erasure.

Foredraget tar for seg poenggiving i Bowling og er inspirert av Robert C. Martin's eksempel fra "Agile Software Development"
Foredraget tar for seg poenggiving i Bowling og er inspirert av Robert C. Martin's eksempel fra "Agile Software Development" og vil gå gjennom følgende: Introduksjon om test-drevet utvikling og bowling. Praktisk demonstrasjon med test, utvikling og refactoring av løsningen. Det vil bli implementert Spear, men ikke Strike (for de som er bowlingeksperter!). Typisk blir det 4-8 runder med test-code, og 2-3 runder med refactoring. Q&A

J2EE developers can lose a lot of time writing code to implement best-practices design patterns to achieve well-architected applications. JSR 227 eliminates some of this routine coding by standardizing a declarative approach to data binding. This presentation illustrates Oracle's runtime and designtime implementation of JSR 227 in its Oracle Application Development Framework (ADF), and highlights the facilities that Oracle ADF provides for productively building and data-binding to J2EE business services. Along the way, we showcase the best-practice techniques that Oracle's over-2000 internal J2EE application developers have made and motivate why.
J2EE developers can lose a lot of time writing code to implement best-practices design patterns to achieve well-architected applications. JSR 227 eliminates some of this routine coding by standardizing a declarative approach to data binding. This presentation illustrates Oracle's runtime and designtime implementation of JSR 227 in its Oracle Application Development Framework (ADF), and highlights the facilities that Oracle ADF provides for productively building and data-binding to J2EE business services. Along the way, we showcase the best-practice techniques that Oracle's over-2000 internal J2EE application developers have made and motivate why.

Java has continued to move forward at a remarkable rate over the last few years. The Java platform has matured into a stable enterprise-proven deployment environment, and the development solutions supporting this have also made great steps forward. Borland has been at the leading edge of such advances in Java development from the very beginning. In this session you will see the latest Java development solutions from Borland, and how an integrated approach to development really can enable better productivity for developers, and deliver better performance and quality for applications, faster.
Subjects covered include: Integrating requirements into the development process Profiling to improve and track performance How to better understand and document your applications Building web applications faster with JavaServer Faces Integrating requirements into the development process (10 min) Profiling to improve and track performance (10 min) How to better understand and document your applications (10 min) Building web applications faster with JavaServer Faces (15 min) Q&A Required experience: Basic understanding of: the Java language and runtime environment of web applications using Java servlets and JSP’s Expected audience: Developers and architects interested in JavaServer Faces development and Java performance

De fleste større selskaper har både J2EE- og .NET-baserte løsninger. Både Java og .NET har sine sterke sider - hvordan kan du utnytte disse for å levere bedre løsninger for brukerne?
Vi vil vise forskjellige måter å gjøre dette på, samt synliggjøre noen av grunnene til at dette kan være interessant for deg!

Qualitative requirements can and should always be specified as clearly as possible. Most people do not know how. Everybody can learn how.
Artikkel: Quantifying Quality Qualitative requirements can and should always be specified as clearly as possible. Most people do not know how. Everybody can learn how. Organizations should insist on quantitative clarity for all critical qualitative aspects of their project, process or product. The main concept is to define an "operational scale of measure" for all qualitative requirements. You can quantify any quality. This quantification ability will give you control over quality and over related quality costs. It will improve your personal, and corporate, ability to manage projects, products, services, local quality of life where you live or work,[TG1] and organizational improvement. It is a useful general skill for top managers, technical directors, product managers, project managers, social services, idealists, and engineers. This book will focus on the practical ‘how to quantify’. Then if you want to see some of the practical consequences of this ability – we will teach you some related methods. Examples: Instead of ‘very user friendly’ - We could specify ’10 minutes to learn to do something’ Instead of ‘highly secure’ - We could specify ’99.9% of all intentional attacks will be detected and 99% thwarted’ Instead of ‘very adaptable’ - We could specify ‘employee gets back to normal productivity within one week of new environment’ "Use figures as little as you can", said the grand old man of American accounting James Anyon, who came from Lancashire. "Remember your client doesn’t like or want them, he wants brains. Think and act upon facts, truths and principles and regard figures only as things to express these, and so proceeding your are likely to become a great accountant and a credit to one of the truest and finest professions in the land."[Boyle00, p.38]

The Open Source community is currently a major innovative force, forming the future of Java and J2EE development. An architecture based on WebWork, Spring and Hibernate is the subject for this talk, focusing on ease of development, productivity gains and other project experiences.
The Open Source community is currently a major innovative force, forming the future of Java and J2EE development. This is particularly evident looking at the upcoming EJB3.0 standard, inspired by Hibernate and non-invasive frameworks like Spring and PicoContainer. An architecture based on WebWork, Spring and Hibernate is the subject for this talk, focusing on ease of development, productivity gains and other project experiences. Especially we demonstrate how lightweight containers based on the Dependency Injection pattern facilitates test-driven development and improves overall testability. Required experience Web application and EJB development experience Familiarity with the basics of the Dependency Injection pattern Basic understanding of JUnit and mock objects WebWork, Spring and Hibernate knowledge is an advantage, but not required. Expected audience Developers and architects interested in how non-invasive Open Source frameworks can improve productivity, ease of development and testability, especially compared to the laborious and hard to test EJB component model. Developers/architects will see a real-life project based on WebWork/Spring/Hibernate. The talk will demonstrate a superior alternative to the laborious and hard to test EJB component model.

Assertion facilities as found in Java 1.4 are known to be very useful as they increase the probability of detecting the presence of bugs. Design by Contract1 (DbC) allows for more powerful assertions.
Abstract Design by Contract1 (DbC) allows for more powerful assertions since with the DbC framework assertions take the form of preconditions, postconditions, and class invariants. Preconditions specify something that must be true before a specific method executes, postconditions specify something that must be true after a specific method executes, and class invariants state something that must be true within a context of a specific class before and after any public method belonging to class executes. For example, in a Person class we may want to specify the invariant that the age attribute is never negative. If this is ever broken we ask the system to let us know by, for example, throwing an unchecked exception. Developing software with such a framework allows for developers to build better software by organizing the communication between software elements through specifying, the mutual obligations and benefits that are involved in those communications, where the specifications are the contracts. The benefit of DbC is said to be better designed software with improved reliability where the documentation is better, the debugging is easier, and support for reuse is better. The DbC concept is taken further in UML via OCL as contracts are expressed in higher-order logic and the contracts can be specified during analysis. Outline Introduction to Design by Contract (DbC) and the principles & guidelines to writing good contracts. (10 min) Introduction to DbC in UML with OCL. (5 min) Introduction to ocl2j, a prototypical tool that converts OCL contracts into Java assertions and instruments these into the target program using aspect-oriented programming. (10 min) Discussion of recent advances and findings in the field, i.e., guidelines how to best use the technology derived from empirical studies. (5 min) Examples pertinent to core and enterprise software development. The examples will show how this approach can solve real problems that developers have to contend with, i.e., control over the use of inheritance (distinguishing between subclassing and subtyping) and unambiguous specifications. (15 to 20 min) Required experience Basic experience with Java and UML class diagrams. Expected audience Software professionals interested in developing software of higher quality faster, specifically, software with a better design, better reliability, easier reuse, and easier debugging.

Hibernate has de siste årene blitt en av de mest populære persitensmekanismene tilgjengelig. Foredraget tar for seg en rask innføring i selve rammeverket, samt gjennomgang av forskjellige verktøy for utvikling og hvordan disse virker sammen.
Hibernate, en liten oversikt. Trekke inn noe ORM og sammenligne med JDO/EJB2.0. Utvikling med Hibernate. Vise med eksempel hvordan man kan bruke XDoclet til å få generert XML mapping filer (top-down). Vise hvordan man kan bruke MiddleGen til å generere mappingfiler fra eksiserenede database for så å kjøre hbm2java verktøy for å generere klasser (bottom-up). Hibernate i bruk. Trekke frem kjente problemer, som sesjonshåndtering, exception handling osv. Vise forskjellige måter å deploye/bruke hibernate: 1. Som SAR fil i JBoss, hvor app server styrer transaksjoner osv.. 2. Med Spring rammeverk for å styre sesjoner, exceptions, transaksjoner osv. Ytelse og tuning. Snakke om typiske ytelsesproblemer, hvordan effektivisere spørringer osv. Eventuelt trekke inn andre tips og tricks. Avsluttning med fremtidsutsikter. Snakke litt om EJB3.0 spec, samt JDO2.0. Trekke frem Hibernate sin rolle i disse, og se på sannsynligheten for at Hibernate kommer til å bli kompatibelt med disse.  

In this session we will show how Maven can be used on real-life projects to handle continuous integration, project intra-dependencies, artifact templates, and source code structure.
When the project size and complexity grows, the effort needed to maintain source code and project builds increase. In order to minimize this effort, and being able to focus on the problem domain, a well-functioning build environment is essential. Maven is an open source project management and build tool that aims to address such challenges by providing a well-defined project structure, and a coherent body of documentation that keeps the project team apprised of project status. By using Maven we are able to ease the project build and source code management effort, lowering the start-up-time for new developers, perform easier reporting, while introducing a framework that facilitates agile methodologies. We will dive into the details on how Maven is configured, and address some of the challenges, and best practices that we have found. Introduction Problem focus: hard to manage builds and dependencies in larger J2EE projects Strategies for solving this problem: using Maven. Maven history. Maven key aspects Keywords: Project Object Model, configuration using properties, local and remote repositories, site generation Will go through key concepts while show running Maven to perform a build. Project challenges Keywords: challenges using Ant: large scripts, maintenance of scripts, no re-use. Managing inter-project dependencies, builds. Maven benefits Keywords: example of project structure, script re-usability, continuous integration with Maven, creating reusable project templates using plugins, reporting Will show generated site documentation for entire project. Summary/ Q & A  

WesternGeco has been running an internal proof of concept project using OptimalJ this spring and summer. This report summarizes the experiences with the current state of art in MDA. Do we get reduced development time and improved quality?
UML based modeling tools have been around for a few years now. These tools have helped people creating visual models to improve the understanding of both the problem and solution domain. These models have been very useful at particular phases of development, but because of the lack of traceability and consistency between the various models and tools, the models themselves and in particular the code get fairly quickly out of sync. Model driven engineering (MDA) defined by OMG is a new approach that tries to close this gap and keep models and code in sync by advanced code-generation. It also removes the tedious work coding towards various middleware. Very few systems today are developed completely from scratch. Most systems are modifications or reengineering of existing systems. If would be a tremendous improvement in both quality and effort if the reengineering task could start from existing up-to-date models of the existing system. The lifetime of most software systems tends to be quite long. During this time the systems undergo quite significant changes. The initial development is often less than 20% of the total effort. If the models could stay up-to-date and synchronized with the code this would significantly reduce the effort of sustaining and supporting systems. WesternGeco has a big internal software development organization that has been involved in several EU-projects that focus on MDA. We have been running an internal proof of concept project using OptimalJ this spring and summer. This report summarizes the experiences with the current state of art in MDA. Do we get reduced development time and improved quality?

In this presentation (held in Norwegian) the author will share project experiences after using BEAs APS solution BEA 8.1 Platform. Application Platform Suites (APS) is an important part of the developing process hiding complexity and allowing high-speed development. The knowledge basis is taken from going live with 2 BEA Platform projects the last year.
Note that this presentation will be held in Norwegian. In this presentation the author will share project experiences after using BEAs APS solution BEA 8.1 Platform. Application Platform Suites (APS) is an important part of the developing process hiding complexity and allowing high-speed development. The knowledge basis is taken from going live with 2 BEA Platform projects the last year. The presentation will cover experiences after: - Having teams with a lot of programmers (using CVS) - Going to production in a clustered environment - Building a portal using pageflows, JSPs, portlets etc.. - Creating a good environment for development, test and production (Linux and Windows) - Working with architecture/programming/infrastructure on the 2 projects The presentation will touch important themes like: JSR168, JSR170, Struts, J2EE patterns, J2EE frameworks, development tools, J2EE productivity, SOA and portals/portlets. Required experience Average technical audience understanding what J2EE, portals and SOA is. 

Everyone is talking about Model Driven Development (MDD) BUT why do we need it? Is it the answer to IT productivity? The core problem of software development is to balance increased productivity with flexibility and control.
Everyone is talking about Model Driven Development (MDD) BUT why do we need it? Is it the answer to IT productivity? The core problem of software development is to balance increased productivity with flexibility and control. This presentation will look beyond MDD and will reveal an approach that allows you to develop applications faster, while leveraging your expertise and leaving you in control. Goal MDD is enjoying high visibility but this presentation will look beyond MDD and will reveal an approach that allows you to develop applications faster, while leveraging your expertise and leaving you in control. This presentation will outline the essence of Model Driven Architecture (MDA) - the reality not the hype. It is no exaggeration to say that MDA has the potential to revolutionise the way we create and maintain software. Since MDA is becoming so popular, it is important to understand clearly why we need it, what it is - and what it is not. The goal of this presentation is to answer these questions. The Essence of MDA What is it about MDA that offers such drastic improvements over conventional methods of software development? The answer to this question lies in its "separation of concerns". MDA divides domain knowledge and platform knowledge allowing domain experts, platform experts and application developers to contribute their respective knowledge independently. Increase Productivity and Control Over the years the level of abstraction has risen, allowing programmers to create more and more powerful applications in return for a given investment of time and effort. The drawback was that they sacrificed other desirable factors, such as flexibility and standardisation, for this productivity. That is why, 15 years after 4GLs looked set to replace 3GLs, most of today's programming is done in 3GLs like C, C++ and Java. MDA strikes a compromise between power, flexibility and standardisation. It allows development to move smoothly between levels of abstraction, with much of the tedious, plumbing work being automated. What MDA is NOT The essence of MDA requires the separation of domain and platform expertise, which numerous approaches don't allow. The presentation will make heavy use of pictures, examples and demonstrations. Required experience: Java, development and/or application architecture and design knowledge expected. Expected Audience: Who should attend? Developers of all levels and architects. How will participants benefit? They will get a clear understanding on MDD, in particular MDA.

This talk will discuss in Sun internal project called SALSA. SALSA stands for Sun appliance for live software analysis and  is being developed as a tool to assist software architects extract, analyze, and refactor Java designs and architectures using 2D and 3D visualization.
This talk will discuss in Sun internal project called SALSA. SALSA stands for Sun appliance for live software analysis and is a joint venture between Sun PS and Sun Labs. SALSA is being developed as a tool to assist Sun software architects extract, analyze, and refactor Java designs and architectures using 2D and 3D visualization. Salsa is technology built on top of Gosling's Sun Lab technology called Jackpot which produces design and architectural software characteristics known as "analysis facts". Using SALSA, architects can quickly assess an application for such things as patterns, anti-patterns, bad practices, pattern density and design inconsistency. This talk will include a SALSA demonstration and some insight into the future direction and potential applications.

Implementing enterprise J2EE applications as a collection of cooperating business services offers added flexibility, but presents a number of new challenges for developers and administrators. This presentation highlights relevant standards and requirements for delivering reliable, secure, and manageable applications in a Service-Oriented Architecture, and illustrates Oracle's strategy for providing a complete, standards-compliant Application Platform Suite that meets these requirements.
Implementing enterprise J2EE applications as a collection of cooperating business services offers added flexibility, but presents a number of new challenges for developers and administrators. This presentation highlights relevant standards and requirements for delivering reliable, secure, and manageable applications in a Service-Oriented Architecture, and illustrates Oracle's strategy for providing a complete, standards-compliant Application Platform Suite that meets these requirements.

Richard Stallman will speak about the goals and philosophy of the Free Software Movement, and how they impact the use and development of Java.
Richard Stallman will speak about the goals and philosophy of the Free Software Movement, and how they impact the use and development of Java.

Portlets are subject to become the new hype of web programming and the JSR 168 / WSRP has made this hype become realistic. The portlet programming model requires a new way of thinking compared to standard web application development.
The current Portlet API works well for the "hello world" and stock-ticker applications, but not for enterprise applications, where page-flow, web-components, and input validation, become time consuming and important. The application is no longer alone at the clients browser, and there is a new API to conform to. None of the high-level web development frameworks cannot fully be utilized, making them unattractive choices for doing enterprise development of portlets. This presentation is divided into three sections: 1) An overview of portlets/JSR 168 and the challenges with this programming model. 2) Show how Struts can be customized to be compatible with the JSR 168, allowing the developer to use all Struts' bells and whistles the same way as before. This approach would also make it easy to port existing Struts applications to conform to JSR 168. 3) A brief overview of what impact the JSR 168 portlets and Web Services for Remote Portlets (WSRP) may have on future web development.

This session gives an overview of the JSR 168 portlet programming model, and how to utilize it to write portlets that can run on any JSR 168 compliant portlet container.
This session presents the Java Portlet Specification (JSR 168) and gives an outlook of its implementation in IBM WebSphere Portal. JSR 168 provides a standard for Java-based web applications that are not self-contained but run in a presentation and management environment that is provided by a J2EE portal. The presentation shows the goals (and non-goals) of JSR 168 and explains the interaction of portlets and the portlet container. It introduces the programming concepts of the specification, contrasting them with the well-known servlet concepts, and gives some programming examples for portlets. Finally, the specific capabilities of the JSR 168 implementation in IBM WebSphere Portal are presented and it is shown how portlet programmers can make optimal use of WebSphere Portal features while writing standard compliant portlets that run on any JSR 168 implementation. Required experience: J2EE concepts, Servlet programming experience Expected audience: J2EE architects and programmers that are interested in new standards for writing modular web applications. Pariticipants will learn about a standards-based programming model that allows to make use of the presentation and management framework provided by a J2EE portal and about IBM middleware support for this standard.

Service-Oriented Architecture (SOA) is an organizational and design methodology that maximizes the reuse of application-neutral services. Process-driven development has become acknowledged as a much more intuitive and powerful way to develop composite applications. This session will show how to model and execute business processes that span multiple systems, services, and users using process-centric constructs like sequencing, branching, system state, and causality.
Service-Oriented Architecture (SOA) is an organizational and design methodology that maximizes the reuse of application-neutral services. The benefits include greater reuse of IT assets, faster delivery of value to the business, and greater adaptability to support ongoing change. While Integrated Service Environments (ISE), such as BEA WebLogic Workshop 8.1, can help in developing reusable services, the real payback of investing in SOA comes when you are able to consume services within rich composite applications. Process-driven development has become acknowledged as a much more intuitive and powerful way to develop composite applications. This session will show how to model and execute business processes that span multiple systems, services, and users using process-centric constructs like sequencing, branching, system state, and causality.

Begrepet Multi-Paradigm Design er stjålet fra James Coplien som har skrevet bok om temaet relatert til C++. I Java har vi mange programmeringsparadigmer tilgjengelig. I tillegg til Objekt-orientert programmering, kan vi benytte Meta-programmering, Generisk programmering (JDK 1.5) og Aspekt-orientert programmering (f.eks. vha AspectJ).
Begrepet Multi-Paradigm Design er stjålet fra James Coplien som har skrevet bok om temaet relatert til C++. I Java har vi mange programmeringsparadigmer tilgjengelig. I tillegg til Objekt-orientert programmering, kan vi benytte Meta-programmering, Generisk programmering (JDK 1.5) og Aspekt-orientert programmering (f.eks. vha AspectJ). Spørsmålet er hvordan kombinere disse paradigmene på best mulig måte. Coplien tar utgangspunkt i en såkalt "Commonality and Variability Analysis" for å finne objektive kriterier for når de forskjellige paradigmene passer best. Vi foreslår å passe en slik analyse inn i en iterativ prosess der Solution Design gradvis forbedres gjennom å anvende metoden. Vi vil presenterer et lite (men realistisk) case study som tar utgangspunkt i et use-case, hvor man til slutt ender opp med å benytte alle 4 paradigmene.

Erfaringer fra arbeidet med Metro 2, Telenor Networks sin mellomvareplattform. (The presentation will be held in Norwegian.)
"Metro" tilhørende Telenor Networks, er en mellomvareplattform brukt til systemintegrasjon og applikasjonslogikk tilhørende de fleste større applikasjoner innunder kundefront, kundeservice, feilhåndtering, alarmer, leveranse og tjenesteaktivering innenfor Telenors fastnettvirksomhet. Vi har i løpet av de siste par årene vært gjennom et stort migreringsløp hvor løsninger er blitt flyttet fra gammel plattform/arkitektur over på ny plattform/arkitektur basert på WebSphere 5.x, MQ 5.3 og tilhørende verktøy, arkitekturmålbilder og -retningslinjer. Foredraget vil presentere erfaringer fra denne migreringen, med problemer vi møtte og hvordan de har blitt løst. (The presentation will be held in Norwegian.)

Mesan AS har lang erfaring med utvikling av store transaksjonssystemer i det norske markedet. Denne presentasjonen viser hvordan Mesan har videreført denne kompetansen til effektiv utvikling av Java-applikasjoner med Swing brukergrensesnitt og J2EE transaksjonshåndtering.
Mesan AS har lang erfaring med utvikling av store transaksjonssystemer i det norske markedet. Denne presentasjonen viser hvordan Mesan har videreført denne kompetansen til effektiv utvikling av Java-applikasjoner med Swing brukergrensesnitt og J2EE transaksjonshåndtering. Følgende emner vil bli berørt: Hvilke egenskaper ved teknologi, arkitektur og utviklingsmiljø trenger vi for å kunne utvikle effektivt? God arkitektur for en SWING-basert enterpriseapplikasjon GUI-håndtering SCOPE HMVC Transaksjonshåndtering - J2EE Hvordan sikre kodekvalitet, effektivitet og vedlikeholdbarhet Priaktisk demonstrasjon - vi bygger en komplett Swing/J2EE-applikasjon Live!

Large information systems need a domain model. Development teams know this, yet they often end up with little more than data schemas. This tutorial delves into how a team, developers and domain experts together, can engage in progressively deeper exploration of their problem domain while making that understanding tangible as a practical software design.
Large information systems need a domain model. Development teams know this, yet they often end up with little more than data schemas. This tutorial delves into how a team, developers and domain experts together, can engage in progressively deeper exploration of their problem domain while making that understanding tangible as a practical software design. This model is not just a diagram or an analysis artifact. It provides the very foundation of the design, the driving force of analysis, even the basis of the language spoken on the project. The tutorial will focus on three topics: 1. The conscious use of language on the project to refine and communicate models and strengthen the connection with the implementation. 2. A subtly different style of refactoring aimed at deepening model insight, in addition to making technical improvements to the code. 3. A brief look at strategic design, which is crucial to larger projects. These are the decisions where design and politics often intersect.

Rune, Rune og Ru... Gunnar presenterer teknologi og erfaringer fra håndholdte Java-løsninger.
Objectnet AS og Unified Consulting utvikler to av Norges største virksomhetskritiske løsninger for håndholdte terminaler. Disse er Forvaltsys for Statens Vvegvesen og MT for NSB. Prosjektene har gitt oss mye kunnskap om hva som finnes av teknologier, muligheter og problemer. Ved å presentere MT-prosjektet ønsker vi å dele denne kunnskapen med andre utviklere. Stikkord for foredraget er modulær oppbygging, J2ME, J2EE, design patterns, kommunikasjon mellom eksterne og interne enheter, valg av teknologi og ytelse. Vi vil fortelle om våre valg og løsninger og gi dere et inn blikk i hva som fungerer, hva som ikke gjør det og hvor vi mener utfordringene ved håndholdte løsninger ligger. Foredraget vil hovedsakelig passe for utviklere og arkitekter med noe erfaring i utvikling av systemer for håndholdte terminaler. Foredraget vil også være interessant for beslutningstagere som ønsker å vite hvilke muligheter som finnes med håndholdte løsninger i dag.

This presentation, for J2ME developers at all levels, gives a broad view of these new features and enhancements and their use in the J2ME Wireless Toolkit.
The latest version of the J2ME Wireless Toolkit, includes implementations of exciting new JSRs and supporting tools. To name a few: JSR 184 - Mobile 3D, JSR 82 - Bluetooth APIs, JSR 205 - WMA 2.0, and JSR 172 - J2ME Web Services. These features help developers write applications that use the new APIs. In addition, existing tools have been improved and enhanced to better suit developer needs. This presentation, for J2ME developers at all levels, gives a broad view of these new features and enhancements and their use in the J2ME Wireless Toolkit.

This BOF will be arranged in an informal panel style. In the session we will touch topics like why we have different approaches to "wrapping" our domain models-putting them in more or less heavy-weight containers, adding features through aspects and so on. We will talk about the purpose of this wrapping, what the core questions are when selecting an approach, and maybe some characteristics, pros, and cons of different approaches.
Domain Model-wiring This BOF will be arranged in an informal panel style. In the session we will touch topics like why we have different approaches to "wrapping" our domain models-putting them in more or less heavy-weight containers, adding features through aspects and so on. We will talk about the purpose of this wrapping, what the core questions are when selecting an approach, and maybe some characteristics, pros, and cons of different approaches.

I'm going to talk about Maven 2 and Continuum. Maven 2 should be a known topic for a lot of the participants so I'm mainly going to talk about the changes from maven 1, what's been changed, added and removed. Continuum is a new continous intergration server using maven 2 and is beeing developed by me with the support of all the maven 2 developers. Continuum is beeing used to continously intergrate all the maven 2 components and it's dependencies.
I'm going to talk about Maven 2 and Continuum. Maven 2 should be a known topic for a lot of the participants so I'm mainly going to talk about the changes from maven 1, what's been changed, added and removed. Continuum is a new continous intergration server using maven 2 and is beeing developed by me with the support of all the maven 2 developers. Continuum is beeing used to continously intergrate all the maven 2 components and it's dependencies. Some Maven 2 highlights: Speed: Currently it's about 5 times faster than Maven 1 for a simple project and twice as fast for a equal ant build. Embedding: Maven 2 is fully embeddable, it's already beeing used in continuum. New POM (Project Object Model). The new pom is called 'pom.xml' to make the migration from Maven 1 to Maven 2 easier.

Teknologien endrer seg .. Sun N1 Grid: Managing n computers as 1 ..... Dette er ikke bare om teknologi, men en hybrid av teknologi og automatiserte prosesser og rutiner. Dette er ikke “bare” ett Sun initiativ, men noe hele industrien arbeider med. Ett paradigmeskift i hvordan vi forvalter IT arkitektur, prosesser, rutiner, tjenester osv er i ferd med å skje.
Teknologien endrer seg .. Sun N1 Grid: Managing n computers as 1 ..... Dette er ikke bare om teknologi, men en hybrid av teknologi og automatiserte prosesser og rutiner. Dette er ikke “bare” ett Sun initiativ, men noe hele industrien arbeider med. Ett paradigmeskift i hvordan vi forvalter IT arkitektur, prosesser, rutiner, tjenester osv er i ferd med å skje.

Agile utviklingsteknikker som test-drevet utvikling, kontinuerlig integrasjon, daglige stand-up møter og ukentlige iterasjoner skaper en rytme i prosjektet som er veldig behagelig og effektiv å jobbe i, både for utviklere og prosjektet som helhet. Foredraget vil fokusere på disse teknikkene og for bedre enn andre, mye anvendte teknikker i programvareutvikling, og ikke minst gi tips og råd om hvordan man gjennomfoerer teknikkene i praksis og hva man kan gjoere for å ta dem i bruk.
Agile utviklingsteknikker som test-drevet utvikling, kontinuerlig integrasjon, daglige stand-up møter og ukentlige iterasjoner skaper en rytme i prosjektet som er veldig behagelig og effektiv å jobbe i, både for utviklere og prosjektet som helhet. Foredraget vil fokusere på disse teknikkene og for bedre enn andre, mye anvendte teknikker i programvareutvikling, og ikke minst gi tips og råd om hvordan man gjennomfoerer teknikkene i praksis og hva man kan gjoere for å ta dem i bruk. Agile teknikker som foredraget vil ta for seg er blant annet: Test-drevet utvikling Parprogrammering Kontinuerlig integrasjon Automatiske akseptansetester Stand-up møter Ukentlige iterasjoner Blant teknikkene som diskuteres og ikke anbefales å gjoere finner vi: ukentlige statusmøter manuelle byggeprosesser lange/ingen iterasjoner manuell akseptansetesting på slutten av prosjektet up-front detaljert design

Ved Universitetets Senter for Informasjonsteknologi (USIT) i Oslo har man det siste året gjennomført to prosjekter med bruk av emnekart. Det ene systemet brukes til å registrere IT tjenester og maskinressurser i et emnekart, og det andre for å legge inn metainformasjon om blant annet fagområder og tema for artikler i forskningsmagasinet Apollon. Presentasjonen er først og fremst beregnet på de som har vært igjennom en introduksjon til emnekart og vil vite mer om hva det kan brukes til i Java applikasjoner.
Ved Universitetets Senter for Informasjonsteknologi (USIT) i Oslo har man det siste året gjennomført to prosjekter med bruk av emnekart. Det ene systemet brukes til å registrere IT tjenester og maskinressurser i et emnekart, og det andre for å legge inn metainformasjon om blant annet fagområder og tema for artikler i forskningsmagasinet Apollon. Presentasjonen er først og fremst beregnet på de som har vært igjennom en introduksjon til emnekart og vil vite mer om hva det kan brukes til i Java applikasjoner.

Presentasjonen vil gi en innføring i Emnekart (Topic Maps) og hvordan man utvikler smart programvare med denne standarden.
Presentasjonen vil gi en innføring i Emnekart (Topic Maps) og hvordan man utvikler smart programvare med denne standarden. Emnekart er en relativt ny ISO-standard for formell beskrivelse av kunnskap. Datamodellen er svært godt egnet i applikasjoner hvor datamodellen er dynamisk og gjerne kompleks. I tillegg kan dataene være distribuerte og automatisk flettes ved behov. Presentasjonen vil legge spesiell vekt på at man i motsetning til i relasjonsdatabaser og XML ikke behøver å gjøre skjemaendringer og endringer i applikasjonen dersom nye typer data introduseres. Muligheten for å utvikle generisk programvare vil også bli diskutert. Fokuset til presentasjonen vil først være en introduksjon til emnekart-modellen, deretter på hvordan man bruker denne modellen til å modellere domene-informasjon, og til slutt hvordan man utvikler programvare rundt emnekart.

Heard of aspect-oriented programming (AOP), but not sure how to get started? In this session Adrian Colyer, leader of the AspectJ project, will present a proven road map for adopting AOP using AspectJ. Attendees will gain an understanding of the phases of adoption, with examples and demonstrations of the kinds of aspects you might write at each stage. There will be plenty of opportunity to see the latest version of AJDT (the AspectJ Development Tools for Eclipse) in action too.
Introduction Overview of the phased adoption approach Enforcement & Exploration aspects Auxiliiary / infrastructure aspects Core / business aspects Sanity check - what makes a good aspect? Conclusions and next steps Required Experience: Attendees will be expected to be familiar with Java programming, and preferably with some of the concepts of AOP (these will not be covered in the session). Hands-on programming experience with AspectJ is not required.

It is not surprising that after Java 1.5 became official, that the Sun Certified Programmer for Java 2 Platform exam should also be updated. However, it might come as a surprise that the new exam for Java 1.5 is radically different from earlier versions of this exam, requiring a different mindset in preparing for the new exam. Early in 2005 Sun completed beta-testing of its new Sun Certified Programmer for Java 2 Platform 1.5 (SCJP 1.5) Exam. The exam is expected to be finalized in the summer of 2005. The objectives of the new exam have been revamped. The objectives emphasize understanding of Java language features and being able to understand code scenarios which use these features. Esoteric features have been omitted, and heavy emphasis put on OOP concepts, locales, stream I/O, and nearly all the new features introduced in Java 1.5 (Autoboxing/unboxing of primitive values, Enums, Foreach loop, Formatting of values, Using regular expressions with the Scanner class for parsing input, Generic types/methods/wildcards, Static import, StringBuilder class).
The talk answers pertinent questions like: How to plan, study and prepare for the SCJP 1.5 exam Where to get certification resources for the SCJP 1.5 exam, as currently no certification Books are available on the market. However, the talk will concentrate on examples of code scenarios that providing insights into a selection of important topics that appear on the new exam. Outline Please note that the Exam objectives have not been finalized at the time of writing this proposal. Java Technology Certification Overview (3 min.) New exams for J2SE and J2EE. Sun Certified Programmer for Java 2 Platform 1.5 (SCJP 1.5) Exam: (3 min.) Practical information about the new exam Overview of the Objectives of the SCJP 1.5 Exam (4 min.) Understanding language features Reading and interpreting code scenarios Code Scenarios to illustrate the topics on the exam (30 min.) Realistic Sample Exam Questions on important topics: OOP concepts Autoboxing/unboxing of primitive values Enums

This session will explore Spring Web Flow (SWF), a core module of Spring's web stack, and its architecture as a powerful controller technology based on a finite-state machine.
Keith will discuss in detail SWF's capabilities, including its ability to capture web application page flows as self-contained, reusable modules that make dynamic and sophisticated page navigation decisions. Keith will demonstrate SWF's solutions to important issues facing web application developers in areas such as application transactions, duplicate submits, security, testability, browser-navigation button use, and state management. This session will also show how Spring Web Flow may be leveraged in a variety of web environments as a compliment to "traditional" controllers. You'll see how to embed flows within a number of established frameworks in the web space, including Struts, Spring MVC, and JSF. You'll also see how it integrates with the rest of the Spring Framework. You can expect to see in-action the benefits of using a declarative, test-driven approach to building page flows to orchestrate controlled navigations that drive business processes. You'll leave with an understanding on when to use Spring Web Flow, and how to use it in a best-practice manner.

The Java programming language has been tremendously successful. Many of the roots of its success may be surprising to the audience. But every major programming language has a limited life cycle. While it’s true that Java and .NET seem to be the only games in town, some alternatives are beginning to emerge. In this session, we’ll discuss some of the limitations of the Java language, and the impact that they might have on the productivity of Java developers. We’ll then look at some of the innovations around other frameworks and languages, and some of the features of those languages that boost the productivity of other non-Java developers: Typing, and why it matters Code blocks and closures Regular expressions Innovative frameworks Finally, we’ll take a look at where developers may look at using other languages. Clearly, most of the work that we do will be in Java for the foreseeable future, but certain project classifications may make it much easier to embrace alternatives, for good competitive effect.
Goals: After this session, attendees should: Understand why Java was initially successful Know where Java is coming up short Know some language features that yield better productivity Know what types of projects may be better served by other languages and platforms. Pre-requisites: Attendees should: Have a good understanding of the Java programming language Have used Java in a project Have an open mind Track: Core Java, management

Put simply, a Multi Agent System (MAS) is a computer system built as an anthill. The MAS is composed of many different, independent programs. These programs exchange messages and adapt their behavior to each other in order to solve problems. However, MAS and agent systems in general have obtained the stigma of hype since no techniques and methods have enabled programmers to implement grand and futuristic MAS designs. Here, an experimental method is presented that enables simple and fast implementation of MAS. Using Java (with two minor syntactic adaptations) as a language for inter-program communication and collaboration, MAS designs can be implemented. The Java language (with adaptations) allows each individual agent program to integrate new and existing functionality in order to adapt seamlessly and service the needs of other agent programs. A problem requiring adaptable, collaborative programs along with its MAS solution is presented, and actual and understandable examples of running programs and code are used to illustrate how old dreams can now be made reality.
Topics and time: 1. Introduction to the problem of MAS: How can we set up a program that provides a (web) service, but were both the format and the method of delivery of the service result can only be set up and adapted to client programs’ different needs at run-time? 20 min. 2. Example of a simple, implemented MAS solution using presented method: A graphical demonstration of programs run-time and an easy-to-understand presentation of the underlying program code. 15 min. 3. Java as an inter-program language – how Java can be used and the few adaptations necessary. Parallels are drawn to similar methods such as BeanShell, RPC, CORBA, and SOAP. 10 min

The tutorial will focus on real-life experience with the Spring Framework. The context for the presentation is building web applications using the framework and how to declaratively configure applications. Its main aim is to give an introduction to the most important concepts in this context. Testing is an important part of any application and how to do integration testing with the Spring framework will be demonstrated. Ideas for handy helper classes will also be discussed. Further on the presentation will focus on how to get the most out of Spring’s support for AOP and how to declaratively configure interceptor chains. Real life examples will be shown. Spring’s support for Hibernate as well as how to successfully configure Hibernate with Spring is also a topic – the aim being to get the most out of Hibernate. This part will be brief – but is nonetheless important and not as trivial as one would think! As this is a practical introduction to web application development with the Spring framework, the Model-View-Controller (MVC) tier is important. Configuration and a few examples will be demonstrated. The main goal of the presentation is to give a thorough introduction of how to configure Spring in a fast and reliable way in order to focus on building the web application itself. By providing this tutorial I aim to help the audience by providing solutions to many issues and challenges that one faces when first using the Spring framework in this context.
Development environment setup Handy helper classes Basics of testing Interceptor chaining Aspect Oriented Programming (AOP) examples Spring and Hibernate Spring and JDBC Spring and MVC Required experience The participants should be familiar with the basic concepts of the Spring framework and should have some knowledge about web application development based on J2EE and MVC. Expected audience Developers and architects who are interested in learning how the Spring framework can be used as an efficient way of building web applications should attend this presentation. It will take a practical approach toward setting up an development environment, explaining the relevant components in order to get up and running and ready to focus on implementing business logic efficiently.

Dette foredraget vil se på redesign av et tjenestegrensesnitt brukt i en portalløsning for å lettere kunne møte nye ikke-funksjonelle krav samt å forenkle utvikling av ny forretningslogikk. Verktøy som blir tatt i bruk er bl.a. dynamiske proxyer, aop og dependency injection ved hjelp av Spring. Resultatet blir en løsning hvor egenskaper som caching, logging og EJB-teknologi blir kapslet inn slik at man til daglig ikke trenger å forholde seg til dette. Foredraget vil være praktisk anlagt med både kodeeksempler og muligens også live kode. I tillegg vil det også bli brukt litt tid på å se på fordeler og ulemper ved et slikt design, samt å se på hvilke nye muligheter dette designet gir. Dette foredraget er basert på mine erfaringer fra et større forretningskritisk prosjekt hvor dette designet nå er i produksjon.
Vis designet til grensesnittet som skal refaktoreres (5 min) Gå gjennom fordeler og ulemper med dette designet (5 min) Mål for ny løsning (5 min) Kort introduksjon til verktøy for jobben og hvorfor de ble valgt (15 min) Dynamic proxies Spring, både som aop-rammeverk og lettvekts-container Vis skisse til nytt design og hvordan dette løser målene skissert tidligere (5 min) Strategi for hvordan man kan gå fram for å gjøre en slik refactoring (5 min) Fordeler og ulemper med ny løsning (5 min) Vis kode på ny løsning (5 min) Forventet forhåndskunnskap: Det vil være en fordel med noe kunskap om dynamiske proxyer, spring og aop.

In the last two years, ORM tools like Hibernate have become popular in the Java developer community as a part of a trend towards simplifying J2EE application development. Many of these tools support generating the database from the object-model and try in this way to minimize the required knowledge of database design, even though in practice some database design knowledge is still required. Other tools, like Prevayler, try to take this even further by eliminating the database altogether.
Another recent trend is the use of AOP for implementing cross-cutting concerns like logging, security, caching, and even the domain logic itself, such as proposed by Rickard Öberg at the JavaZone conference in Oslo in 2004. In this talk I will present a design approach for how domain models can be described with as little information as possible, where dynamic proxies are used for managing the data and thereby realizing an even more agile and adaptive way of defining the domain model. The design is inspired by Rickard Öbergs thoughts, but avoids the use of AOP for the implementation because it doesn’t provide the necessary functionality for implementing this. I will also look at how business logic can be handled in this kind of a design by using a variant of the dependency injection pattern. The talk will also have a live demonstration of how this works and go into detail about pros and cons of such a solution.

Traditional object oriented development may work for large projects, but it’s not the right approach for most of the enterprise software that we build. Certain characteristics of technology can improve your chances of success. Some new open source technologies, like Spring and Hibernate, dramatically simplify programming by reducing complexity. Many development teams use heavyweight development technologies to solve basic problems. We overuse EJB, we use XML where it’s not the best fit, and we needlessly complicate our lives in many other ways. We’ll look at process, architectures, and technologies that can simplify your code and save you money. When the session is over, you’ll have a good understanding of the techniques that you can use to do lighter-weight, simpler development projects. You’ll know the processes that the experts favor, and the tool kits that they use to simplify their lives.
Goals: After this session, attendees should: Understand the foundations of the lightweight development movement Know some basic principles that simplify programming Understand the basic tools for dealing with complexity Get an overview of technologies that can improve development

Being one of the hottest topics in the Java community, the content of this presentation will be an introspective on the different and typical persistence layers in Java. The presentation will focus on each of the persistence layers and offer the pros and cons of each. It will show the architectural merits of the different persistence mechanisms, where they are most appropriate for use, and culminate in showing that they can coexist in the same application.
Introduction Preamble Peristence Layers   o EJB   o JDBC   o O/R Mapping   + Hibernate EJB  o Advantages  o Disadvantages JDBC  o Advantages  o Disadvantages O/R Mapping  o Advantages  o Disadvantages Architectual Merits  o Is One Better than the other?  o Where should each be used?  o They can live together, and often do.

Few argue against the value of Developer Testing (a.k.a. Unit Testing): it provides undisputed benefits for improving software quality, developer productivity, and control over delivery schedules. Agitator amplifies these benefits by providing automation for test creation and by enabling large-scale adoption. In this presentation Alan Perkins will show the power of Domain Experts, the out-of-the-box support for Struts, J2EE, and more, and the ability of the Domain Experts to learn from your domain knowledge and business logic and make your Testing Tool as smart as you are.
In the USA Agitator was recognized by an unprecedented 6 major awards for technical excellence in its first year on the market. Now Agitator 3.0 raises the bar again with Domain Experts, which analyze not only your Java code, but also contextual information such as the configuration of your application frameworks - so you get the most useful tests possible. Few argue against the value of Developer Testing (a.k.a. Unit Testing): it provides undisputed benefits for improving software quality, developer productivity, and control over delivery schedules. Agitator amplifies these benefits by providing automation for test creation and by enabling large-scale adoption.

In this presentation, we'll look in depth the new features of WebWork 2.2 that extend WebWork's existing UI tag library and embrace rich client-side interaction using JavaScript, XML, DHTML, and XmlHttpRequest. Now commonly referred to as AJAX (Asynchronous JavaScript and XML), the technique of enabling rich user interaction and instant feedback has become quite popular in recent months. Using these components, we'll see that building an application like Gmail or Google Maps is much easier than it might first appear. More importantly, we'll continue to underline the importance of componentizing your web applications and show you how building reusable libraries not only lets you create richer applications, but also increases your productivity and quality of the products you develop. Lastly, we'll see how AJAX doesn't fundamentally change the MVC style of development, but rather facilitates it while still following the same principles of keeping the data on the on the server as long as possible.
1) Introduction(3 minutes) o WebWork, web applications, who am I, etc o Quick overview of OpenSymphony 2) AJAX: Definition(5 minutes) o Example of AJAX o Discuss XmlHttpRequest slightly o Browser requirements 3) Simple action(8 minutes) o Show a simple WebWork action o Expand that example to use UI tags o Explain UI tags, but don't go in-depth on them o Discuss general WebWork concepts 4) Uses of AJAX(3 minutes) o Caution: can be overused o WebWork components: Tabbed Pane, Validation, Polling, etc 5) Building blocks o 6 minutes o Discuss the basic building AJAX building blocks in WebWork o ww:div tag o ww:a tag o ww:form tag o ww:submit tag 6) Tabbed Pane(5 minutes) o Show WW tabbed pane component, how it works, etc 7) Validation(7 minutes) o Show normal WW validation and then turn on client side validation 8) Polling(5 minutes) o Chat application 9) AJAX pitfalls(5 minutes) o Discuss areas where AJAX can be improperly used o Address compatibility (cite gmail.com) o Handling polling: too many requests vs. sockets open too long 10) Wrap-up(3 minutes) o AJAX tools: DWR, Dojo, etc o Conclusion 11) Q & A(10 minutes)

The presentation will briefly discuss the history and philosophy of Maven, discuss why the collection of project level metadata, Maven's POM, is important for Java, discuss all the Maven 2.x technologies that are currently being developed and how they can benefit those working with Java.
A brief discussion of the history and philosophy of Maven. What goals Maven has tried to solve and how the project has evolved in the last 3 years. A discussion of Maven 2.x itself. What new features it adds and how it is different from m1. A discussion of Continuum. Why Continuous integration is critical in software development and how Continuum makes CI seamless when working in tandem with Maven. A discussion of our new Repository Manager (which will be in alpha). How a project can help manage its software inventory in your Maven repository by leveraging its indexing, seach, and categorization capabilities.

BEA and OSS ­ Leading Java Innovation This presentation will discuss how BEA is working with the Open Source community to help bring innovations to the market quicker and to compliment BEA¹s standardization strategy. This presentation will describe the current work BEA is doing within the Eclipse Foundation and the Apache Organization including the Eclipse Web Tools Platform project, Apache Beehive and Apache XMLBeans.
Looking back at WebLogic 8.1 ­ release themes BEA Standards and Open Source strategy BEA¹s Eclipse Participation how Java is evolving ­ common trends and frameworks Apache Beehive ­ each section to include overview and code examples (this will be the majority of the talk) Java PageFlows Java Controls Java Web Services ­ JSR 18 Apache XMLBeans Required Experience: Basic understanding of Java, Web applications and Web Services Expected audience: Developers, architects looking to increase productivity

Users of today's web sites desire high-quality search functionality, but, the techniques to achieve that are rarely discussed from a technological point of view. This presentation gives an overview of Lucene and various experiences from projects where this open source API has been used. The presentation will include: How to extract data: Integration, web crawling and parsing Queries and language issues Performance, scalability and tuning Steps to take when adding search functionality to existing web sites
How does a search engine work? - 5 min About Lucene: What will it give you? What does the API offer? - 5 min How to make a high-quality search: Typical issues and suggestions on how to handle them - 20 min Experiences: Some projects and "lessons learned" - 15 min Q & A - 10 min Required experience: Basic knowledge of databases and Java-based web applications Expected audience: Java developers and architects that want to create good searches Developers interested in utilising valuable open source libraries

Det finnes en rekke rammeverk for utvikling av brukergrensesnitt som baserer seg på XML. Deklarativ GUI-utvikling gir mange fordeler i en del av systemutviklingen som tradisjonelt er veldig tidkrevende. Rutinemessig arbeid minimaliseres og kodebasen reduseres. Hierarkisk definering av GUI komponenter i XML-filer gir også god oversikt og er lesbart for vanlige mennesker.
Objectnet har benyttet rammeverkene SwiX^ml og Thinlet i tre av sine utviklingsprosjekter. Hensikten med denne presentasjonen er å gi en introduksjon til XML-drevet GUI utvikling og Objectnets erfaring med disse rammeverkene. SwiX^ml (http://swixml.org <http://swixml.org/>) er et open-source (ala Apache) Java bibliotek med intensjon om å forenkle implementasjon av Swing brukergrensesnitt. Rammeverket leser XML-definisjonen under kjøretid og bygger opp et brukergrensesnitt på basis av innholdet i definisjonen. De fleste standard Swing komponenter støttes. Det er i tillegg mulig å utvide rammeverket med nye komponenter. SwiX^ml er tett integrert med Swing-biblioteket og bygger på eksisterende Swing kompetanse. Dette gjør overgangen fra tradisjonell Swing-programmering til XML-drevet GUI enkel. Thinlet (http://thinlet.com <http://thinlet.com/>) er en annen open-source (LGPL) løsning for XML-drevet GUI. Denne er laget med et eget proprietært komponentsett. Hovedvekten er lagt i å gjøre GUI-motoren lettvekt. Dermed kan den benyttes selv på små plattformer ned til Personal Java. Thinlet har alle de komponenter som vi er vant med og utseendet er enkelt og moderne. Til slutt vil vi avslutte med en funksjonssammenligning mellom de to grensesnittsverktøyene og sette dette opp mot XUL.

Når man gjør integrasjoner mot ulike baksystem vil man oppleve at ulike konvertering teknikker må benyttes for å mappe mellom proprietære eller strengbasserte resultater til en intern DO representasjon. Dette medfører at man bør ha bygge inn muligheten for å konfigurere denne mappingen for å enkelt kunne bygge utvidelser og endre konfigurasjonen.
Da vi i mitt nåværende prosjekt skulle bestemme oss på hvordan mappe mellom CICS record, offset string basert resultat, falt valget på å benytte Hibernate Configurasjon siden vi allerede skulle benytte Hibernate. For å få gjort dette måtte det gjøres noen utvidelser til Hibernate for å få den nødvendige ekstra funksjonaliteten. Dette førte til at vi kunne konfigurere mappingen mellom DO's og Cics Records (CopyBooks) i samme format som for vår database. Videre for å konfigurere hvilken configurasjon for hvilket kall i CICS benyttet vi Spring Framework. Duration: 45-50 Min Required experience: Kjent med Hibernate og Spring Expected audience: Personer som jobber med integrasjonsarktiektur (J2EE Arkitekter). Hibernate utviklere

As one of the founding members of the Eclipse platform, as well as one of the members of the board of directors, Borland has supported the Eclipse platform with various solutions and technologies for several years. Borland is now amplifying this initiative further by offering a complete ALM (Application Lifecycle Management) solution on the Eclipse platform. This presentation will show you how you can extend the Eclipse platform with enterprise level modelling, requirements management, and change management capabilities. Enterprises can now rely on Eclipse as their software delivery platform of choice. Come and see Eclipse as you’ve never seen it before.
Subjects covered include: - Requirements management on the Eclipse platform - Modeling on the Eclipse platform - Change management on the Eclipse platform Duration: 45 min presentation and demonstration followed by 15 min Q&A Required experience: Basic understanding of the Java language and runtime environment Expected audience: Developers and IT professionals interested in development on the Eclipse platform

Etterhvert som bedrifter tar i bruk flere og flere web-løsninger internt øker brukernes krav om å slippe å oppgi brukernavn og passord for hver applikasjon. Microsoft har lagd en utvidelse av HTTP autentisering for IE og IIS som tillater brukere som er logget på en Windows-maskin på et Active Directory (AD) domene å autentisere seg mot websider uten å oppgi brukernavn og passord. Autentiseringen foregår ved at brukerens AD-sesjon sendes til webserveren og autentiseres mot AD-serveren. Dette foredraget viser hvordan man kan benytte dette i en Javaløsning uten å benytte IIS eller Windows på serversiden.
Foredraget er praktisk rettet og går igjennom den nødvendige java-koden for å implementere denne typen av single sign-on. Det blir en kort overordnet beskrivelse av Single sign-on generelt og NTLM-protokollen, samt jCIFS-biblioteket som ble benyttet for å implementere dette. Foredraget er basert på erfaringer gjort på en webapplikasjon i WebSphere som kjørte på Windows, HP-UX og IBM stormaskin. Brukerne av dette systemet er logget på sin Windows arbeidsstasjon og trenger ikke å oppgi brukernavn og passord for å logge seg på webapplikasjonen etter at denne løsningen ble implementert. Det vil også bli en kort gjennomgang av hvordan dette kan benyttes på andre applikasjonstjenere som WebLogic og JBoss. Outline 0. Why single sing-on? Different ways of doing single sing-on 1. Background: Java Authentication and Authorization Service (JAAS) 2. Microsoft's NTLM authentication protocoll 3. Implementing single sign-on with NTLM using an open source library (jCIFS) 4. Making WebSphere trust our NTLM-implementation 5. Other application servers (BEA and jBoss) Required experience Man bør kjenne til J2EE.

Multi-Paradigm Design handler om systematisk å kombinere flere paradigmer for design av software. I Java kan vi benytte objekt-orientering, meta-programmering, generisk programmering og aspekt-orientert programmering. Refaktorisering bør utføres for å unngå duplisering av kode. I mange tilfeller finner man duplisert kode som håndterer ”cross-cutting concerns”, dvs. funksjonalitet som går på tvers av klasser og metoder. Foredraget viser hvordan forskjellige paradigmer kan avvendes for å refaktorisere ”cross-cutting code”. Det vil være spesielt fokus på likheter og forskjeller mellom AspectJ Advice, Dynamic Proxy og objekt-orienterte design patterns, og hvordan velge blant disse. Prinsippene illustreres gjennom et case-study som tar utgangspunkt i en J2EE applikasjon basert på EJB og Struts som refaktoriseres ved å kombinere forskjellige paradigmer. Foredraget viderefører prinsippene fra fjorårets foredrag på JavaZone (Multi-Paradigm Design in Java), med fordypning på problemstillinger rundt refaktorisering av ”cross-cutting code”.
Outline 1) Introduksjon (2.5 min.) - Oversikt over paradigmer i Java (OOP, Meta-progr, Generics, AOP) - Om å kombinere paradigmer 2) Refaktorisering (25 min.) - Felles kode på tvers av klasser og metoder (cross-cutting code) - Om behovet for refaktorisering - Språk-støtte i Java - AspectJ advice - Dynamic Proxy - OO design patterns 3) Case study (25 min.) - Refaktorisering av J2EE applikasjon basert på EJB og Struts ved å kombinere forskjellige paradigmer - Oppsummering (2.5 min.)

Implementing Single sign-on (SSO) can be challenging to implement in heterogeneous environments. There are many approaches, some of them involving rather large and intrigue solutions. We demonstrate some of the simpler approaches that you may use to implement web single sign-on, based on experience from successful SSO implementations. These approaches consist of leveraging possibilities in your existing IT environment, and tailoring a solution to fit your requirements. We will demonstrate that in many situations, you will be able to create a relatively easy SSO implementation without introducing large changes to your environment.
- What is single sign on its benefits (5min) - Bringing in the big guns. WebSEAL and SiteMinder (10min) - Dissecting single sign-on. What makes it tick? (10min) - Lighter guns - tailored to actual needs (15min) - Experiences from the field: lessons learned (5min) - Demonstration (5min) - Q&A (10min) Required expirience: Basic security knowledge. Basic architectural knowledge. Expected audience: J2EE architects and developers.

An introspective of how a large utility company utilized open source to solve the problem of moving 24x7 mission critical data around an organization requiring workflow, transactions, providing/transforming data from one system and format to another with distributed components. The overall goal was to replace hundreds of small, one-off applications with an enterprise class, distributed J2EE architecture. The completed solution is a prime example of using 100% open source software to develop an enterprise class system that saved the organization a significant amount of investment in commercial software. The solution resulted in a centralized enterprise service bus architecture utilizing best-in-class architectural concepts, J2EE components and open source implementations, such as Spring, Webservices/AXIS, Hibernate, JBoss, Quartz, JBPM, EJB/MDB, JMS, and JMX/MBeans.
This presentation will focus on various aspects of the project including the overall architecture, the project’s affect on the business, the open source software used to complete the project and the many struggles throughout the project lifecycle. The project will be demonstrated and discussed throughout the discussion of the architecture and the open software used to accomplish the project goals. TOPIC OUTLINE The Problem Definition Many data formats Many incompatible systems/applications moving the data Lack of identified workflow Lack of status notification The Business Constraints Limited budget Limited time Must follow the company process The Solution Centralized management of transformations Guaranteed delivery of events and results Workflow/Task identification and management Pluggable transformation component framework Scheduled and manual implementation of tasks The Project Architecture Build system (Maven) Unit and functional tests (JUnit) Administrative web console (Struts) Scheduler (Quartz) Workflow (JBPM) Messaging event engine (JMS/MDB) Activity transformers (moving data, performing business logic) Notification (JavaMail) Using IoC effectively (JMX, Spring) Persistence to multiple data stores (Hibernate, Spring JDBC) Generation of object model and business delegates (Middlegen, XDoclet) Single sign-on (JAAS, JCIFS) Application Server (JBoss) Webservices/AXIS (SOA communication to third party systems) Operating System (Linux) Lessons Learned What worked What didn’t

This session will walk the audience through the experiences gained migrating real world EJB 2.x applications to EJB 3.0. Session will cover the key differences in coding and design patterns between EJB 2.1 and EJB 3.0 applications. Specific tips and techniques that can be adopted for migrating applications to EJB 3.0, and potential pitfalls that developers should be aware of will be discussed with real examples. This session will also highlight the potential limitations of EJB 3.0 specifications and implementations and what can be done to better improve the developer experience in building applications.

This paper describes the findings of performance comparisons between design patterns and typical uses of EJB 2.1 with similar functionalities using the new features of EJB 3.0. Concentrating on some of the most common techniques used by EJB developers, we review the use of patterns such as Data Transfer Object and Session Facade and compare them with equivalent functionalities in EJB 3.0. We also compare Container Managed Relationship of EJB 2.1 with the EJB 3.0 getters/setters. The test code and harness, as well as the testing methodology, from the book "J2EE Performance Testing", will also be explained and made available.

Large and complex Java systems are often difficult to unit test due to tangled code, problematic design patterns and certain aspects of the Java language. This talk describes how a complimentary framework can be used to introduce unit testing in large Java enterprise systems. The framework has been used on a Java system comprising 5000+ Java classes with more than one thousand service methods and makes it possible to effectively isolate virtually any module for unit testing without changing the production code.
Introduction (15 minutes) What is a (good) unit test? Unit test in XP vs. the industry Isolation of what to test --> Mock objects Repeatable tests Test what possibly can break Common misconceptions Problems with unit testing in large enterprise systems Pipeline design Singletons and factories Datasources ++ Tackling the problem (10 minutes) Known strategies for testing this kind of systems JUnit-integration tests Refactoring to unit-testable design (e.g. inversion of control) Catch-22: refactoring to testability with no unit test... No unit testing An alternative approach: Surrogate (5 minutes) Non-intrusive with respect to production code No refactoring required Mock singletons, factories, DB-connections, 3-rd party libraries and whatever you want Makes uses of AOP technology in the background Demo (7 minutes) References (1 minutes) Summary (5 minutes) Q&A (10 minutes) Required experience: Knowledge of unit testing in Java, and preferably of use of mock objects. Intended audience: Experienced developers, system architects and other technically compentent personnell.

“The future of Enterprise Java” Covers the motivation behind the EJB3 specification and how it addresses the issues with EJB2.1. Gives an introduction to how enterprise Java will be simplified and empowered using the evolved specification. By combining the new JBoss microkernel with the specification we will show how true lightweight applicationservers are going to impact future enterprise development, and how middleware eventually will be found everywhere.
Outline and duration The motivation behind the new EJB3 specification The people and companies driving the innovation Sample EJB3 code Inside and outside the container Introducing Jboss5 and the new Jboss microkernel Middleware everywhere Examples Bringing it all together: the future of enterprise development Examples Conclusions Questions and Answers Intended audience: Enterprise architects, ISVs and channel enablers who wish to see the direction enterprise Java is going.

How do you know that the software you are building is what the customer wants? Is there any way to involve the customer continuously throughout the project and verify that you are moving in the right direction? Enter the world of Automated Acceptance Testing and the Framework for Integrated Tests (FIT). FitNesse automated tests bridges the gap between customers, test staff and developers, facilitating collaboration as well as early and frequent feedback in a deterministic way. Tests are easy to create and maintain for business resources, can be integreted in your continuous integration cycle and are invaluable for regression testing. While unit testing and TDD helps you building the code right, automated acceptance tests ensures that you are building the right code.
Outline (60 minutes including Q&A) Automated acceptance testing, FIT and FitNesse (5 min) Basic FitNesse Demo: Your first FitNesse test (5 min) Writing FitNesse tests: Tables and Fixtures (5 min) FitNesse demonstration and examples from an enterprise project (10 min) Integrating FitNesse in the development and test environment (5 min) Benefits and customer involvement in the process (10 min) Communication and collaboration between the customers, project management, developers and other stakeholders Automated regression testing Progress reporting; know when you're done Measuring code coverage to indicate test quality Lessons learned, tips and tricks (10 min) Q&A (10 minutes) Required experience: None Expected audience: All roles in any project will benefit from learning and applying automated acceptance tests, including developers and architects, test personnel, project managers and persons working with functionality and requirements. A basic understanding of testing in general, Test-Driven Development and functional testing is an advantage. Source-code for the presentation can be found here [437Kb] Other examples can be found here

The presentation gives an overview of challenges and opertunities provided by the Java platform, when building large scale enterprise systems for a demanding business. We will present the business requirements and how these requirments are met by an event driven architecture, and how the architecture is trasnsformed into working code. Practical examples of interesting areas and use of tools and techniques will be addressed.
Statoil Wet Supply Chain (10 min) Overview of the business and the driving requirments TOPS - Trading and OPeration System The SJEF architecture & its tools (15) From data processing to process automation - The need for an event driven architecture Decision making, autonomy and collaboration List of key tools and Sharing experiences from one of the main areas (25) Client side challenges and solutions Designing a distributed system the inherent complexities of distribution Organizing the client code, role based user access, server communication use of the command pattern Swing and the MVC pattern i practice. Lazy loading, domain centric client code Software agents and usability Server side challenges and solutions Domain driven design in practice, working with deep object models Use of repositories and JDO. Mapping of rich object models to relational databases, considering use of object databases Integration and event (message) processing, practical use of JMS Integration of BRSM systems in a rich object model, does and donts, benefits and concerns Inversion of control and the Spring framework, experienced benefits and concerns Questions 10 min Required Experience: Some experience with J2EE development and rich clients is recommended. Expected Audience: Architects, designers and developers interested in an experience report from development of enterprise scale information systems.

This session presents the key concepts of Java Middleware Platforms and how and why open source based platforms will play a principal role in the middleware development and systems integration. Get insight into existing integration approaches, get answers to your questions about their benefits, differences and effective infrastructures/platforms to deploy them. The session will focus on the Service Oriented Architecture (SOA) concept as natural approach to define abstract services included in those platforms. Learn from the experience of the Bull R&D department and how they leveraged the Java open source development to implement a Java Integrated Platform on top of JOnAS J2EE Application Server. The session also introduces the Bull ESB Platform, the current work around and concludes with a demo focused on a real-world use case.
Bull R&D (JOnAS Team) and ObjectWeb introduction What are Java Middleware Platforms? What’s on? What’s new with open source based Java Middleware Platforms? Java Middleware Platforms and systems integration Service Oriented Architecture (SOA) vs EAI approaches SOA and Web Services JOnAS Integrated Application Platform insight: JOnAS components and services introduction New vertical services, components and tools added on top of JOnAS A second step: Bull Enterprise Service Bus Demo: putting together the Bonita Workflow System, a JetSpeed based portal and BPEL engine for web services orchestration. Required experience Participants should have a good skill in Java programming and Java existing infrastructures. A first contact with interoperability issues with non-java programming languages, heterogeneous systems integration and workflow systems would be suitable. Expected audience Due to the dual vision of the session (Java development and systems integration solutions), this speech is oriented to both Java architects and Java project managers. Participants will get a general overview about the ObjectWeb open source consortium and one of its most active contributors: the Bull R&D department. Attendees will learn what a Java Middleware Platform is, its benefits, problems targeted and possible implementations. Attendees will also gain insights into Service Oriented Architecture approach used on those platforms and how this approach will be used to simplicity the java middleware development and heterogeneous systems integration issues.

15 of the 75 Items from the book of the same name, providing rules for building enterprise Java systems that will scale, will perform, and most of all, won't suck.
( ) Introduction ( ) 10 Fallacies: ( ) Remember identity breeds contention ( ) Keep data and processors close together ( ) Build in monitoring support ( ) Build in administration support ( ) Make deployment as simple as possible ( ) Pass data in bulk ( ) Prefer rules engines for complex state evaluation/execution ( ) Prefer transactional processing for nonatomic failure ( ) Recognize the object-hierarchical impedence mismatch ( ) Never assume you own the data or the database Required experience: Attendees should be at least passingly familiar with the major elements of the J2EE stack, such as servlets, JSP, JDBC, and/or EJB. Expected audience: Anyone who wants to see ways in which to make enterprise Java applications not suck.

Much has been made in recent months about service-orientation or SOA (service-oriented architecture), but not much has been said that's concrete and usable. In this talk, we'll talk practically about the 4 Tenets of Services, why they look the way they do, and what they mean at a practical level.
Required experience: Audience should have some familiarity withdistributed systems programming; any of RMI, CORBA, EJB, .NET Remoting, DCOM, COM+/EnterpriseServices, or OSF RPC would be fine. Expected audience: Audience should be familiar with some of the terms of Service-Oriented programming, only so that we can get beyond the hype and get into the core of what SO is.

In this presentation, we'll take an in-depth look at the WebWork MVC framework. Designed for both those familiar with WebWork as well as those unfamiliar, this presentation will showcase the unique features that make WebWork such a great platform to develop on. Starting off with a quick "Wow" example demonstrating the power and ease of use of WebWork, we'll then look at the various aspects of the example, detailing WebWork's unique features along the way. This presentation is very "hands on", so you can expect to see lots of code and discussion around that code. No charts and diagrams here!
Introduction 3 minutes WebWork, web applications, who am I, etc Quick overview of OpenSymphony Wow example 7 minutes Show a simple WebWork action, form using UI tags, and "long running process" Show off demo flowchart using WebWork "WebFlow" tool Overview 8 minutes High level design Main features: o Broad technology support: JSP, JSTL, FM, Velocity etc o Advanced expression language o Extensible template library o Advanced type conversion o Interceptors provided unlimited extension points Core concepts 6 minutes Actions Interceptors Results Template library 9 minutes Go over example from "Wow" example Demonstrate advanced components, such as the Select tag Demonstrate HTML output and JSP input side by side Demonstrate how to customize templates Discuss themes and show how to create a new one Type conversion 5 minutes Why it is important in HTTP Advanced uses Uses of interceptors 7 minutes Double submit problem Long running processes Parameter dependency and object loading Wrap-up 5 minutes New features in WebWork 2.2 Plug AJAX presentation Conclusion Q & A 10 minutes

Maven 1 is now a mature build system. It has some limitations but all build actions can be accomplished with it. It boasts hundreds of plugins that provide the full range of build needs. Maven 2 is the new kid on the block and is the successor of Maven 1.
This session will explain the motivations behind Maven 2, what are the Maven 1 limitations it is fixing and where it is taking us in term of builds and more generally development tools. We'll assess the current state of Maven 2 and we'll provide tips for migrating a Maven 1 project to Maven 2

As software projects grow they become increasingly unmanageable. It seems that large projects inevitably grow into huge spaghetti-like structures. One way of enforcing a clean separation of functional areas is to physically partition the code base into many separate sub-projects with clearly defined dependency relationships. There are some interesting and wide-ranging benefits that result from this approach, but new problems and issues also emerge. Many of the Java IDEs now offer features which support the development of large projects containing hundreds of separate modules. These features will be reviewed in IDEs such as IDEA, Eclipse and NetBeans. Finally, this talk will introduce and demonstrate a new build tool based upon Ant, which is designed to assist in building very large numbers of modules and sub-projects.
There will be five sections to this talk. 1. Introduction (10 minutes) Introduce key concepts: - what is a software module? - how big is it? - what terms can we all agree upon? 2. Comparing modular software to monolithic software (10 minutes) Large-scale monolithic software projects have a tendancy towards becoming 'great piles of spaghetti'. The idea of modularity is to prevent this happening, based on the observation that smaller projects are a lot easier to maintain than larger projects. Key advantages of a modular approach to software development using Java :- a) Agility - it's faster to build and test a small module than a large project. b) Architectural visibility - modules make it easier to see your project's overall structure. c) Support for major refactorings - modules make it easier to try out new ideas, integrate good ones and eject bad ones. d) Re-use - it's easier to turn useful code into common code when it's in a module. e) Architectural integrity - the code won't compile if a dependency is not explicitly declared. All these claims will be clearly explained and justified in the presentation. 3. IDE support for modularity (15 minutes) This section will be a lightning tour of a sample of Java IDEs to compare their support for developing software as a series of modules and dependencies. This will show how a modular project appears in each of these IDEs, and demonstrate supporting features of each IDE. a) IntelliJ IDEA 4.5 b) Eclipse 3 c) NetBeans 4 4. Building and testing modular software projects - demonstration (15 minutes) This final section will demonstrate mBuild, an open-source build tool based on Ant and the FreeMarker template engine. mBuild is not available today, but will be available before JavaZone 2005. The role of mBuild is to use metadata (usually contained in IDE project files) to build modules in the correct order according to rules contained in an Ant template. It helps in the development of large build systems. 5. Questions & Answers - 10 minutes Level: This is an advanced topic designed for experienced Java developers, but requires no previous experience in the subject area, which is likely to be new to most. Participants should have experience of working on a reasonably-sized Java project and ideally some experience of using Ant. Expected audience: Software developers, technically-savvy project managers and architects.

Hvordan bygge komplekse moderne virksomhetskritiske systemer med fokus på total livssyklus Når 1. versjon av applikasjonen er implementert skal den være bygd for å håndtere endringer. Dette kan være endringer knyttet til f.eks: - Ny funksjonalitet - Ny teknologi - Ny teknologisk plattform, f.eks. applikasjonsservere/databaserplattform - Antall brukere av applikasjonen - Brukermønster til applikasjonen, flere og evt. nye kanaler - Nye systemer som skal integreres mot applikasjonen
Stikkord: Hvilke virkemidler bør og må settes i prosess i forkant og underveis i selve for å sikre høy effektivitet både i utviklingen og videreutviklingen/ forvaltningen av systemet i hele systemets levetid. Hvordan sikre kvalitet før leveranse/implementering av systemer: - Ha fokus på J2EE applikasjonens ”Life Cycle” - Java Automation- automatisert J2EE utvikling - Prosesser som gir mulighet for å systematisere og automatisere test Hvordan bygge systemer for å håndtere endringer knyttet til videreutvikling gjennom: - Bruk av hensiktsmessige, riktig og strukturerte patterns - Testing i hele utviklingsprosessen med ulike virkemidler og på alle nivåer - Kvalitetsikring underveis i utviklingen. (4) Level: Intermediate (5) Forventet publikum: Arkitekter, utviklere, metode- og prosessansvarlige

This talk will introduce some of the Google infrastructure components and illustrate how Java can be used in an environment with extreme scale computing..
Google are not willing to let us publish the slide deck. However, they have supplied two articles: The Google File System MapReduce: Simplified Data Processing on Large Clusters

: Web Services seem to get everywhere. But are they secure 'enough'? Transport- or message-based security? When do I need what? When is one better than the other? SSL and WS-Security can be used to apply Web Services security between the Java and .NET platforms today. This session will demonstrate an hands-on approach to a widely discussed problem space. See examples on how to use the different token types in WS-Security and learn how to deal with certificates and other advanced security mechanisms. Leverage message encryption, signing and authentication to enable safe and secure communication between the Java and .NET worlds based on open and hopefully interoperable standards.

SOA Importance By 2006, more than 75% of midsize and large enterprises will have deployed SOA-enabled development tools and middleware (Gartner 2004) By 2006, more than 60% of enterprises will consider SOA a guiding principle in designing their new mission-critical business applications and business processes. (Gartner 2004) By 2006/7, focus will shift from basic infrastructure to business frameworks via Web services-based, Service-Oriented Architectures. (Meta Group 2004) Sun Proprietary/Confidential: Internal Use Only SOA Impact - From Forrester
Agenda What the analysts are saying Why the need SOA philosophy SOA business SOA architecture Q&A /ul>

It is easy enough to design code generators that can churn out application software at a tremendous rate. But we must be aware of the perpetual tradeoffs between speed of development, and other desirable factors such as quality, security, maintainability, runtime efficiency and reliability. We do not want to carry things to extremes and generate mass-produced, inefficient software that fails to meet user requirements. The key is to strike a balance between automated efficiency and human creativity; and this is where pluggable, customisable patterns enter the picture. This presentation / demonstration will focus on automating the creation of software itself and the part pluggable, customisable patterns play, always remembering Albert Einstein's saying: "Everything should be as simple as possible, but no simpler.
- The need for smart automation: combining speed and control (10 minutes) - Model Driven Architecture (10 minutes) - Design patterns (10 minutes) - Pluggable, customisable patterns (25 minutes)

The talks starts with a brief overview if Enterprise Service Bus architecture, the JBI (JSR-208) specification Mule. It will then introduce a ‘real-world’ loan application that demonstrates some of the typical design traits of a service-based architecture. The application will show how to integrate JMS, SOAP, JDBC and HTTP with the services that make up the application. The talk will finish showing how to test and deploy the solution.
Outline Brief overview to ESB Introduction to Mule and JBI Introduction to the loan Application Overview of the problem Systems involved Application architecture Technical Challenges Implementation with Mule Transports Components Routing Exception handling Testing Deployment Further Reading / Q&A Required experience J2EE technologies such as JMS, EJB and Web Services, with a broad understand integration issues and service oriented principals. Expected audience Developers and architects who develop applications that interact with other applications at the middle tiers.

Prosjekterfaringer: - EA/SOA: Granularitet, governance, KPI'er, BPEL etc. - Common Information Model (Shared Object Model/Domenemodell) med tilhørende transformasjoner - EA/SOA sett fra både IT avdelingen og forretningssiden - Kanskje litt om JSR207, JSR208 og andre viktige spesifikasjoner

Patterns are often considered and presented in isolation or as part of a loosely themed catalogue. However, much of their power comes from connecting them together to describe whole systems or frameworks and how to build them.
This session considers the ways in which patterns may be combined, presenting some of the current thinking on concepts such as pattern compounds, pattern stories, pattern sequences and pattern languages. It presents concrete examples in Java and UML. The session encourages attendees to think beyond their conventional pattern vocabulary.

The Sun Java System Application Server Enterprise Edition provides a high-performance, scalable, and robust J2EE platform for delivering enterprise-class application services and Web services.One of the key features in the EE edition is the built-in session persistent data store which delivers failover protection of Application Server instances in a cluster.
The Always-On technology HADB is built on is originally a Norwegian technology. This presentation will explain how transparent session failover is achieved using HADB. (rough draft) Introduction (5 min) Application Server Overview (5 min) Load balancing and failover (10 min) Session Persistence (15 min) HADB technology (15 min) Duration: 50 minutes plus Q&A Expected audience and level: The presentation is suitable for anyone who would like to know more about the availability aspects of application server. The presentation assumes knowledge of the J2EE architecture.

The presentation gives an overview of Software Agents, and how they support the development of dynamic Java Enterprise Applications. We will describe different types of agents and their properties and capabilities, with special focus on agents using the the Belief Desire Intention (BDI) model of Artificial Intelligence. We will give examples of business scenarios that can benefit from the use of intelligent software agents and present a demo of a system for process control and dynamic distribution of workflow tasks.
- Software Agents - Using software agents in enterprise applications - Demo: A Workflow client with Agents - Questions Required Experience: Some experience with J2EE development and rich clients is recommended. Expected Audience: Developers and designers interessted in ways of building more dynamic enterprise applications.

Two main goals of the EJB3 specification are developer productivity and reducing complexity, making the simple things easy and the difficult things possible. At the same time, lightweight containers such as the Spring Framework in combination with Hibernate could be a viable alternative. Enterprise architects are expected to explain the differences, advantages and drawbacks of the available technologies. It is important to see through the smokescreen to be able to explain the differences between the various alternatives and appreciate the consequences of the selected architecture.
In this session we discuss the emerging EJB3 standard in relation to lightweight containers. Central qualities such as support for business logic, persistence, transactions, testability and remote access are compared. The assessment is based on the EJB 3.0 Preview provided by JBoss 4.0, as well as experience from several large projects using Spring and Hibernate. Brief introduction to the topic - 5 min. Persistence: EJB3 Entity Beans vs. Spring ORM/Hibernate - 10 min. Business logic: EJB3 Session Beans vs. POJOs managed by Spring - 10 min. Some services/aspects - 20 min: Transaction management Distribution and remote access Redundancy, scalability and fail-over Testability Development tool support - annotations and metadata Conclusion - 5 min. Q&A - 10 min. Duration: 50 minutes + 10 minutes Q&A Track: Enterprise (J2EE development and architecture) Required experience: Some J2EE experience. Expected audience: J2EE Architects and Developers. Developers who wish to learn more about EJB3.

Two emerging fields of interest to the Java developer are Java Management Extensions (JMX) and Aspect Oriented Programming (AOP). This talk gives a rapid introduction to each of these areas to begin with, so that the attendee will be familiar with the terminology on leaving. Then, starting with the motivation that the application developer should be concerned about their manageability, but not have to work hard to incorporate it into their code, the talk presents a new approach to building manageability as an aspect, that is woven into the code at runtime. Annotations are shown as devices for attaching a JMX Managed Bean (Mbean) to a business object, and the potential disadvantages of doing JMX in this way will be pointed out.
Some pragmatic steps are show that the developer can take today without going to full aspect-oriented programming, so that the application design will be ready for AOP once it becomes more accepted by mainstream. Some examples of AOP will be pointed out from work done on manageability code. Finally a look to the future will be taken with the potential for JMX to be incorporated into Integrated Development Environments (IDE's).

This talk explains how to use JMX (Java Management Extensions) patterns in practical applications for building better manageable applications. The 7 design patterns that are described here were derived from real world projects that are now working and being managed in production. JMX has now become much more popular since it is incoporated into the Java 5.0 (Tiger) SDK. There were 5 different sessions on JMX alone at the JavaOne 2005 conference recently. More programmers will be paying attention to the production deployment parts of their applications in order to make them long-lived in the data center. This is expecially true for server-side or J2EE applications. This talk will enable the developer to avoid some pitfalls in using JMX and to make the best use of it for their application design. A white paper documenting the design patterns will also be available. The design patterns shown here build on the EJB Design patterns from F. Marinescu and the original design patterns by Gamma, Johnson, Vlissides and Helm to give the developer a more powerful language for describing manageability of their applications. The importance of profiling the JMX parts of the application will also be discussed.
Examples of some of the patterns to be discussed are : MBeanForAppConfig, MBeanHelper, MBeanLivesForever, MBeanAggregator.

Popular web sites such as Google Maps and MSN My Spaces, along with the emergence of "Smart Clients", raise the bar for what users expect from web applications. This session explores what challenges web developers face and what the available choices are to address them. The options explored span from simple Ajax validations to serializing business objects between servlets, client side script and back. The session also looks into the future of Ajax and Swing based "Smart Clients".

In the past few years, Struts has emerged as the de-facto standard for Java web application development. It was the first major open-source framework to provide a basic Model-2 infrastructure with a host of useful features, a vibrant user community, and a strong commitment to backwards compatibility. Over the years, several competing frameworks have emerged, and in 2004, The Java Community Process released JavaServer Faces (JSF), as a new standard web user interface framework. JSF specifies a web user interface component model, complete with server-side event handling, validation, internationalization, page navigation, and declarative mapping between user interface components and Java objects. It is designed to work with JSP and other display technologies, and allow rapid development of web applications for HTML and non-HTML clients, using traditional RAD IDE metaphors.
This session begins with an explanation of what JavaServer Faces is, and how it relates to Struts and other web frameworks currently on the market. Next, it examines different strategies for using Struts and JSF together as well as migrating from Struts to JSF, discussing the pros and cons of each approach. The session ends with an overview of future directions for JSF as well as Struts, and the Struts Shale project.

Java web development has come a long way since the initial introduction of the Servlet API. Today, there are dozens of different frameworks -- dominated by Jakarta Struts -- that make web development faster and easier. However, until recently, most of these frameworks didn't mask the underlying request/response nature of HTTP, or concentrate on stateful user interface components. And only Struts has widespread industry adoption and tool support.
JavaServer Faces (JSF) is a standard web user interface framework, developed under the Java Community Process (JSR 127), and released in March, 2004. JSF specifies a web user interface component model, complete with server-side event handling, validation, internationalization, page navigation, and declarative mapping between user interface components and Java objects. It is designed to work with JSP and other display technologies, and allow rapid development of web applications for HTML and non-HTML clients, using traditional RAD IDE metaphors. This talk explains what JavaServer Faces is, and how it relates to Struts and other web frameworks currently on the market. It will cover the architecture and key JSF concepts, and also show a sample application inside of an IDE such as Sun Java Studio Creator.

Most developers have by now heard of Design Patterns, but what are they, what is their history and how are they used? This presentation will start with the historical origins - the term 'Pattern' was used already in 1677, in a way that is surprisingly close to present usage. The architect Christopher Alexander was the founder of modern usage of the term, with architectural design starting in the late 60's. The software world picked up the thread around 1993, and the movement gathered momentum with the book Design Patterns by Gamma et al in 1994. Since then, Design Patterns have appeared on many levels. Some have become standard usage, some (iterator) have even become features of programming languages. Many books have been writen on Design Patterns, but it seems that only a relatively low number remains in widespread use - and their use is perhaps less widespread than we might expect. Testimonials abound, but rigorous empirical work is quite scarce. I will present empirical data gathered during my thesis research, both from formal experiments, code analysis and project postmortems. These data show that some patterns are correlated with lower error rates than average, while other patterns show the opposite effect. Names will be named – concrete patterns have been tested and the results are clear and interesting.
After a historical introduction, as outlined in the abstract, the presentation will focus on three topics: 1) What are patterns really about? Not in an academic sense of trying to nail down a waterproof, rigorous definition, but in a practical sense – what kind of information and help should you expect from a good pattern, and what do you have to supply yourself. Design Patterns are not a silver bullet, and they won’t transmute novices into architects, claims notwithstanding. 10 minutes 2) What do we know about the practical consequences of using design patterns, from goodquality research? During my thesis research I have gathered most of the available research evidence (not much) and done a lot of research myself. In this part of the presentation, I will show what we know, and how we know it – again, in a way understandable to practitioners, not academics. An experiment performed in Germany in 1997, and repeated in an improved version in Norway in 2003, tested five different, well-known patterns: Observer, Decorator, Abstract Factory, Composite and Visitor. Their presence or absence in several test programs led to widely differing effects during maintenance and extension tasks, ranging from seemingly intuitive acceptance (Observer), via positive effects after training (Decorator), indifference (Abstract Factory, Composite) to outright harm (Visitor). Analysis of the error and modification history of a large commercial product over three years gave somewhat different results, with higher than normal error rates correlated with the presence of Observer, and markedly lower error rates for Factory. These results probably reflect the difference between the small, controlled examples used in the experiment, and the effects of real-world complexity. 25 minutes 3) Given this knowledge, how do we interpret and use it? In summary, Design Patterns are fairly widely used, and some of them have become ubiquitous by virtue of being language or standard library features and concepts. Like any sharp-edged tool they must be used with knowledge, lest they do harm. To a certain extent, the presence or absence of certain patterns can be used as a diagnostic tool, to locate program areas that warrant close inspection and above-average attention to good design. 15 minutes Required experience: Intermediate to Advanced. Participants will benefit from basic knowledge of Design Patterns, and should have experience with design and architecture, not just coding to spec. Benefit to participants: Better awareness of what Design Patterns can and cannot do for you, based on a combination of principles and practical experience.

You can hardly turn a corner without someone hollering SOA at you these days. Despite a lot of vendor attention, there is a lot of misconceptions about SOA. This presentation will try to penetrate the hype and get to the bones of what SOA is. I will attempt to dispel the lame visions of SOA presented by the vendors and show how the popular description are premature at best, harmful at worst. After mavigating between two different hyped incarnations of SOA, I will describe how we ended up creating a real world realization of SOA.
Towards a definition of SOA (5 min) Motivation SOA as the semantic web (15 min) The vision The promise The reality SOA as web services (15 min) The vision The promise The reality What are services in Java (15 min) Java interfaces and classes Wiring services together - dependency injection Providing supporting functionality (Security, auditing, work flow tracking, logging)

The Enterprise Java landscape has changed dramatically in the last 18 months. We've seen the return of OOP in J2EE applications, increasing adoption of agile development methods, a shift towards framework-oriented development, much greater use of open source, and the gradual rise of AOP. Many old certainties have vanished in an exciting period of innovation which will change how we all work.
Rod Johnson will discuss these and other important areas, concluding with a summary of technologies to watch in the future, and recommendations as to how Java developers can keep ahead of the curve.

Elektroniske billettsystemer er et satsningsområde for å øke antall kollektivreisende, oppnå mer kostnadseffektive salgsløsninger og økt kundetilfredshet. Slike systemer er under planlegging, konstruksjon eller i drift i mesteparten av landet. Foredraget presenterer erfaringer høstet i Oslo-samarbeidet, som er et samarbeid mellom operatørene NSB, Oslo Sporveier og Stor-Oslo lokaltrafikk.
Partene i Oslo-samarbeidet søker å oppnå interoperabilitet mellom sine respektive billettsystemer. Med interoperabilitet menes det at de ferdige systemene opptrer som ett og samme koordinerte system for de kollektivreisende. I tillegg konstrueres det et felles system for å håndtere noen oppgaver som interoperabilitet krever. Utvikling av ny software og tildels ny hardware utføres av fem forskjellige leverandører i fire forskjellige land, på oppdrag fra tre operatører. Samordningssystemet samt standardene rundt selve de elektroniske billettene skal, sammen eller hver for seg, kunne ta inn over seg flere operatører i samarbeidet, eller løftes helt ut av denne sammenhengen og over til andre operatører som ønsker å benytte dette. Foredraget vil ha en del med noe bakgrunnsinformasjon om e-billettering. Dessuten vil foredraget berøre hvordan koordinering mellom de tre/åtte partene håndteres. Avslutningsvis presenteres den implementerte løsningen.

The next release of the Java Wireless Toolkit (formerly the J2ME Wireless Toolkit) brings to the developer community support for three exciting JSRs. The next release will support the APIs for SATSA for smart cards (JSR 177), Location APIS (JSR 179) and the brand new Content Handler API (CHAPI, JSR 211). But it's not just the APIs.... The release has been enhanced with additional tools to aid developers when building applications for these exciting APIs. One example is the route planner, which allows you to create a route for your location sensitive application. Another new tool is the CHAPI property editor, which makes it easy to add the necessary properties to your content handler application's descriptor. Featuring hands-on demonstrations, this presentation will tell developers everything they need to know about the new Java Wireless Toolkit release.
1. Introduction to the Sun Java Wireless Toolkit 4 minutes overview, MIDP, development, projects, emulator 2. Using the Location API (JSR 179) 12 minutes location, gps, latitude, longitude, provider 3. Using the Security and Trust Services API (JSR 177) 14 minutes smart card, java card, apdu, jcrmi, cryptography, authentication, security 4. Using the Content Handler API (JSR 211) 14 minutes MIME type, invocation, handler, register 5. Summary and Questions 6 minutes

The next generation of Java devices will be based on the Connected Device Configuration (CDC) and the Mobile Systems Architecture (MSA). MSA includes a wide range of APIs, including an advanced graphics API for smartphones and PDAs. In the session we will provide an overview of the platform and APIs. New technology requires new tools; the session we will demonstrate a set of tools based on Sun's award-winning Java Wireless Toolkit. The tools for the CDC stack will facilitate adoption of the technology and development of applications for the new APIs.
1. Introduction to CDC 8 minutes The Java platform, CLDC, CDC, the CDC stack, upcoming MSA-for-CDC standardized stack 2. JSR 209 - AGUI 13 minutes features, relationship to Swing, relationship to MIDP, benefits, demo 3. CDC developer toolkit 13 minutes benefits, features, architecture, skins, demo 4. Using an IDE to develop CDC applications 8 minutes contrast with CLDC IDE support, demo of IDE integration 5. Future CDC Roadmap 2 minutes 6. Summary and Questions 6 minutes

Why a Java technology standard? Why technology communities? This session will explore the circle of adoption and business opportunity from an IT Manager and IT developer perspective. How Java technology fits into these circles, and the significance of conformance and the "Write Once, Run Anywhere" promise. The role the Java Community Process (JCP) program plays by carefully focusing on binary compatibility and bringing together the community to agree on standards and the results of this effort--multiple implementations from many sources based on Java technology. Learn about the innovations currently under development through the JCP program and how you can be involved in the evolution of Java technology.


The agile methods have virtually no Quantified focus on the quality and performance levels of the software. This means you cannot control the main benefits for users and stakeholders. This means that you cannot really control the costs, necessary in order to meet the quality needs of your users. It means the methods are not suitable for industrial products where you cannot simply get the functionality, but must compete to deliver all sorts of qualities and performance attributes.

Abstract modeling principles and patterns takes many concrete forms. Developers often ask how to bring them together in a more step-by-step fashion. Although there can never be a cook-book for modeling and design, this talk walks through the application of three rules, using an actual, recent case as an example (simplified, of course).
The case, a redesign of a currency exchange application, brought order to a complex application and prepared it for continued growth. The simple (though not easy) rules used Bounded Contexts to guide detailed design decisions, and Value Objects to weave together a collection of loosely coupled subsystems and provide a Ubiquitous Language. The talk will explain both the patterns and the rules based on them, through the example.

Mobile software development is highly volatile, risky and requires a lot of talent. Agile methods are claimed to offer support for this type of volatile development environment. Indeed, Extreme Programming and other agile methods have received a lot of attention in recent years. These methods do not contain any specific information related to complexities faced in mobile development domain concerning testing, user-centered issues or terminal variance. Mobile-D is an agile approach designed to meet the challenging demands of mobile development environment and standard quality requirements. The talk will offer an insight look into the world of agile methods, principles and solutions. The Mobile-D approach will be introduced and supportive empirical data on rework costs, defect rates and project management based on eight mobile projects will be disclosed.
1. Agile philosophy and rationale (10min) 2. Existing agile development solutions (10min) 3. Mobile-D for mobile software (15min) 4. Empirical data from 8 case projects (10min) 5. Future & conclusions (5min) = 50min.

Viktige beslutninger tas ofte på bakgrunn av magefølelse. Slik er det også innen systemutvikling, der de fleste prosjektplaner er basert på eksperters magefølelse av arbeidsomfanget.
Våre forskningsresultater viser at: 1) Ekspertestimater er bedre enn sitt rykte og trolig minst like bra som estimeringsmodeller. 2) Ekspertene vet ikke hvordan overgangen fra "å forstå hva som skal gjøres" til "å estimere hvor mye arbeid som kreves" (the magic step) skjer. 3) Ekspertestimater er lette å påvirke (f eks gjennom å legge til irrelevant "ankerinformasjon") Presentasjonen tar for seg disse og andre resultater fra vår forskning på området, samt gir råd om hvordan man med enkle midler kan bli bedre til å estimere. Presentasjonen vil være interaktiv, med innlagt øvelser og konkurranser.

En visuell reise gjennom historien til COS, Telenor Mobils mellomvaresystem, gjennom 8 år og en gjennomgang av hvordan transisjonen til lettvektsmetodikker faktisk har gått.
COS er et system som til enhver tid har hatt over 30 utviklere. Hva fungerer? Hva fungerer ikke? Hvilke begrensninger har man? Hva er effekten av teknikker på kort, mellomlang og lang sikt? Hvordan introdusere teknikker? Hvordan bygge kultur? Hvordan få aksept i organisasjonen for radikale endringer? Deltagerne vil gå gjennom en visuell historisk reise med bilder, samt tall og grafer fra verktøyet XRadar. COS-miljøet i Telenor Mobil jobber med et av Norges største Java-systemer. De siste årene har miljøet blitt stadig smidigere i sin prosjektgjennomføring - med bruk av lettvektsmetoden Scrum og innføring av smidige teknikker - mange kjent fra ekstrem programmering (XP). Underveis har man endret rutiner, fjernet prosessteg, innført og utviklet nye verktøy, deltatt i forskning på teknikker, jobbet med rekruttering, miljøbygging - og samtidig målt produktivitet, intern og ekstern kvalitet i løsningen.

WSRP (Web Services for Remote Portlets) is a relatively new standard which allows different portal products to be easily integrated. By allowing portlets produced from a portal be consumed by other portals we can now create truly distributed web systems. By using portals that leverage WSRP it becomes possible to enable outsourcing of web components, hence allowing individual applications to be deployed, managed, and scaled independently of the main portal. This allows for better control and higher uptime of the total system, since one can then avoid monolithic, and hence fragile, portal architectures. It also allows for new business opportunities as it enables standardization of modular ASP solutions.
This presentation will briefly outline the technical aspects of WSRP, demonstrate how it can be used to create better portal architectures, and discuss how proper usage of it can increase the business value of a portal implementation.

Behaviour-Driven Development (BDD) recognises what experienced test-driven developers know -- Test-Driven Development is not really about testing. By using a vocabulary for specifying behaviour rather right. You write a specification of how the program should behave in a way that is concise, unambiguous and executable. You do this before you write the implementation, and you do it in small, repetitive steps. Changing the way you talk about a thing changes the way you think about it.
Invented by Dan North of ThoughtWorks, BDD has evolved from Test-Driven Development (Beck), Responsibility-Driven Design (Wirfs-Brock) and Domain-Driven Design (Evans). BDD can be used for specifying behaviour both at the application level as well as at the object level. The presentation will demonstrate how to do Behaviour-Driven Development at the application level using Ward Cunningham's Framework for Integrated Test (FIT), showing you: how specification by example is a powerful way to communicate behaviour how thinking of the FIT tables as being a specification of behaviour rather then tests changes the way you write the tables how declarative FIT tables helps you find the right abstractions to solve the problem how the terms we use in the FIT tables identify objects in the domain model how refactoring the tables to remove duplication can helpidentify new objects and abstractions in the domain model

Software practitioners and managers seeking to improve the quality of their software development processes often adopt new technologies without sufficient evidence that they will be effective, while other technologies are ignored despite the evidence that they most probably will be useful. As a consequence, software is often built with techniques for which we have insufficient evidence to confirm their suitability, qualities, costs, and inherent risks. This leads to a variety of problems ranging from financial losses to personal injuries. Evidence-based Software Engineering (EBSE) addresses this issue by using reliable evidence from empirical studies, practical experience, and human judgement to support decision making in the development and maintenance of software.
The talk will basically consist of two parts. Part one will give a general introduction to and motivation for EBSE with reference to similar work within the medical domain. In doing this, examples will also be taken from newly published and ongoing research on software design methods and pair programming with Java as the implementation language. The second part of the talk will focus how practitioners can use the evidence-based paradigm as part of their daily work to improve their software process. The talk will be at an introductory to intermediate level and will build on the following references: Dybå, T., Kitchenham, B.A., and Jørgensen, M. (2005) Evidence-based Software Engineering for Practitioners, IEEE Software, Vol. 22, No. 1, January/February, pp. 58-65. Kitchenham, B.A., Dybå, T., and Jørgensen, M. (2004) Evidence-based Software Engineering, Proceedings of the 26th International Conference on Software Engineering (ICSE 2004), Edinburgh, Scotland, 23-28 May, pp. 273-281. Erik Arisholm and Dag Sjøberg, Evaluating the Effect of a Delegated versus Centralized Control Style on the Maintainability of Object-Oriented Software, IEEE Transactions on Software Engineering, vol. 30, no. 8, August 2004, pp. 521-534. In addition, results from ongoing research on a pair programming version of the last reference will also be presented in the first part of the talk.

Presentation of a project where: The only tangible project requirement is best expressed as: Offer 60 ELMER compliant Internet services to the citizens of Oslo by the end of the year!” The applied solution is based on Agility, UML models and automation Specifically: Applying agile and MDA oriented mindsets. Developing a framework for designing ELMER compliant web forms. Using UML to define metamodel and models for the content of a web application. Letting XSDs and XMLBeans be automatically generated from the UML content model. Populating XMLBeans directly from end user input in the web application. Automating client- and server-side user input validation from a common rule set. Generating customized PDF documents and XML documents automatically from the populated XMLBeans. The solution is nominated for the Rosing Award 2005 in the category for user-friendly systems.
Introduction and project setting (approx. 4 min.) Explanation of the requirement(s), what is ELMER? The infrastructure of Oslo Kommune’s IT systems The available budget, time, resources and accommodations Project decisions (approx. 8 min.) Choice of technology Choice of methodology Choice of supporting tools Application architecture and design (approx. 15 min.) The tiers and components UML models as glue Patterns and best practices Project artifacts (approx. 8 min.) UML models and database schema Code and markup Documents? Project organization (approx. 3 min.) The war room The people The process Lessons learned (approx. 7 min.) Modeling content with UML Agility Usability tests revelations Online demo of solution (approx. 5 min) Required experience SW development experience and/or interest Expected audience Anyone who has attended or will attend SW development projects

Test-Driven Development is a buzzword that it appears no modern developer can be without. However, it is a proper understanding of the practice rather than the buzzword conformance that makes the greater difference in development. As a term TDD is often misused: it is sometimes used to mean that somewhere on a project someone is using JUnit; others use it as a synonym for "unit testing"; and others use it interchangeably with the term "Extreme Programming". In Java, JUnit is certainly one of the most popular tools employed in support of TDD. Unit testing is certainly a part of TDD, but there is more to TDD than just unit testing. And, although TDD forms a part of the code-centric practices of XP, TDD and XP are not one and the same.
This session introduces a set of core practices that can be said to characterise TDD at the unit level, embracing both the conventional view of unit testing plus its emphasis on active design. The session also demonstrates the bare minimum involved in evolving a testing framework from nothing, departing from the common reliance on JUnit to illustrate a lightweight and less intrusive approach that is more idiomatic in style to Java.

Authentication, authorization and access control (AAA) is an important topic in the area of middleware. This talk will outline both technical and non-technical issues related to the design, implementation and deployment of a real-world authentication/authorization system used in educational institutions today. The goal is to provide the audience with an understanding of the potential challenges involved in creating such a system.
Introduction (5 minutes) What is UNINETT? What is the FEIDE organization? Basic Requirements (10 minutes) The original FEIDE idea; federated identity management. Consequences and requirements. Service owners' perspective. Organizations' perspective. Privacy and Security (10 minutes) Privacy in the context of Norwegian law. The FEIDE approach vs. Shibboleth. Ownership of user data. Requirements from the Norwegian Data Inspectorate. Design Overview (5 minutes) The authentication triangle. Attempts at SSO. Technical security issues. Implementation Overview (5minutes) Brief overview of implementation details. External interfaces (10 minutes) Service interfaces; cross-platform support through SOAP. SOAP and potential WS-I issues. LDAP and the problem with non-HTTP servlets. Brief note on organization interface. Deployment (5 minutes) Challenges – stability and survivability. LVS case study. Anycast/BGP case study. Surveillance options. Summary and Questions (10 minutes) Duration: 60 minutes. Required Experience: Some experience with issues related to authentication/authorization design and programming. Also, a working knowledge of the Java programming language is required, preferably in the area of web (servlet) programming. Some knowledge of SOAP is beneficial, but not strictly required. Expected Audience: Java developers working with or interested in the subject of authentication, authorization and access control.

Enhetstesting er nå etablert som en naturlig del av de fleste prosjekter. For webapplikasjoner er det i tillegg nødvendig å teste selve brukergrensesnittet, vanligvis gjennomført manuelt med de ulempene dette medfører med hensyn til tidsforbruk og kostnad. Automatiserte webtester øker kvaliteten i prosjektene ved at testene kjøres kontinuerlig som en del av utvilkingsprosessen, og muliggjør dessuten regresjonstesting. Canoo WebTest lar deg gjøre nettopp dette og enda mer...
Outline : Introduksjon : 10 minutter - Hvorfor automatiserte webtester? - Kvalitet - Kost/nytte - Dokumentasjon - Hvorfor Canoo WebTest? - Sammenligning med andre verktøy Canoo WebTest : 15 minutter - Kort presentasjon av Canoo WebTest - Open Source Java prosjekt - Plattform uavhengig - Spille inn tester med Click-O-Mat - Feilretting og regresjonstesting - Skal jeg virkelig bruke det? - Automatisk HTML validering - Utvidelser til Canoo WebTest Demonstrasjon : 10 minutter - Demonstrasjon - Automatiserte Webtester med ant Praktiske erfaringer : 15 minutter - Bruk av Canoo i forbindelse med ytelsestesting - Hvordan unngå skjøre tester - "pragmatisk" GUI-testing - Overvåking av svarstider Spørsmål og Svar : 10 minutter

Når du skal utvikle store systemer som skal håndtere høy trafikk, må du være forsiktig med å følge J2EE "etter boka". Kanskje det til og med kan bli riktig galt. En del J2EE-mekanismer er rene feller. Hva gjør du når CMP cachen har "overraskende" lav treffrate, eller når du måler at altfor mye av tiden går med til transaksjonshåntering i applikasjonsserveren. Distribuerte transaksjoner med XA har flere sideeffekter som man ikke tenker på før man opplever dem som overraskende "killere" på ytelse og robusthet. XA på tvers av persistente køer, integrasjon mot databaser på flere plattformer og kall mot CICS på stormaskin, åpner for interessante problemer i utviklings- og testmiljøet. Hvilke hensyn må du ta når du clustrer applikasjonen over flere noder? Hvilke cache teknikker fungerer best? Hvordan skalerer du et stort J2EE system? Hvis du har problem med ditt profileringsverktøy, har vi et tips til en nødløsning som ikke påvirker ytelsen i systemet. IIOP burde sikre at to produkter kunne snakke sammen, men så enkelt er det ikke. For å fikse en av dagens svakheter, må du faktisk endre Sun's runtime. Det å "flytte" en applikasjon fra stormaskin til J2EE/Unix må da gi billigere drift, eller...
I dette foredraget vil du få presentert flere tips om hvordan få store J2EE systemer til å spille godt. Dette er basert på erfaringer fra flere store J2EE-prosjekter med opptil 80 programmerere og 150 prosjektdeltagere. Noen tips vil være grunnleggende, ting du må vurdere i arkitekturdesignen, mens andre er muligheter til å gjøre forbedringer senere i prosessen, for eksempel under volumtester.

Derby introduksjon - hva Derby er: open source apache prosjekt, 100% Java, small footprint etc - historikk fra Cloudscape via IBM & Informix, til Apache Derby - har aktiv støtte fra IBM og Sun (begge har dediker personell på Derby) Derby features - Standarder (JDBC, SQL) - Platformer (J2EM, J2SE) - Java stored procedures - Embedded vs. client-server - sikkerhet (krypterte data, autentisering etc). Derby ytelse - litt om Derby ytelse Derby arkitektur: - Litt om hvordan Derby er bygd opp - Kompilering (SQL kompilert til byte kode og java klasseobjekter) Derby framtid: - Hva vi i Sun DBTG i Trondheim ser for oss kommer til å skje med Derby - Ut av incubator status (og hva det innebærer) - Standard DB for Apache Geronimo - Økt funksjonalitet og robusthet

The Jakarta Struts framework is the de facto standard for web applications development in Java. Unfortunately, one of the primary difficulties with Struts-based development is that a lot of relationships are defined in a declarative manner, which leads to errors not being found at compilation-time. Furthermore, the system is developed in three different types of files: Java class files, Java ServerPages (JSPs), and XML configuration files. It is difficult to comprehend how these relationships interact, both, statically and dynamically (especially for a person not involved with the original development of a system).
Modeling can greatly help in the understand of these relationships: (1) From a static point of view, page flow diagrams show how JSPs, user-defined classes, and Struts constructs (e.g. action mappings) relate (e.g. shows which JSP uses which action mapping); and (2) From a dynamic point of view, sequence diagrams show when/how specific action objects are invoked and when/how objects are placed in a scope. The technique discussed in this session has been discussed with over twenty professional Struts developers and actively used by ten on a real-word project. The talk will also cover the advantages and disadvantages of proprietary (non-UML based) Struts tools, mainly M7’s NitroX for Eclipse.

While many think of MDA as just a way of separating Platform Independent Models (PIMs) and Platform Specific Models (PSMs), and then generating code from PIMs, the real advantage lies in model-to-model transformation, code generation being one kind of transformation. Working only in the PIM and generating code from it is not very practical and lacks flexibility. A different solution is needed. In this session you will see how model-to-model transformation using Query View Transformation (QVT) and Object Constraint Language (OCL2) works. What are the benefits with this approach? How can you achieve true inter- and intra-model traceability between PIMs and PSMs to get around the limitations of model-synchronization?
Required experience: TBA Expected audience: Developers and IT professionals interested in MDA

Practical use of the J2EE Connector Architecture to access mainframe applications. Integration of mainframe applications in J2EE application systems. Technical challenges encountered building a J2EE Connector from an existing Java terminal emulator: synchronization and timing issues. Building a component generator to automate mainframe transactions and encapsulating them as Enterprise Javabeans. Using the components in a business logic architecture.
1.Brief presentation of Gallagher & Robertson AS 2.Brief overview of the J2EE Connector Architecture 3.Overview of the Glink for Java terminal emulator 4.Adapting the emulator: creating it as a J2EE Connector 5.Caveats and challenges related to mainframe communications 6.Generating EJBs and Javabeans modeling mainframe applications 7.Integrating the applications in the J2EE container 8.Demo – creating a real application 9.The next step: J2EE Connector Architecture 1.5 and inbound communication 10.Q&A Duration: 50-60 minutes Required experience: General J2EE knowledge Java programming

I en verden som endres raskt har tradisjonell systemutvikling vist seg å komme til kort – systemet er kort og godt utdatert før det kommer i produksjon. Prosessen tar ikke tilstrekkelig hensyn til læringseffekten i prosjektet og tar for lite hensyn til endrede behov grunnet manglende involvering og tilbakemelding. Iterativ systemutvikling tar hensyn til denne læringseffekten og sikrer at løsningen som leveres er mer i tråd med de krav som gir verdi på leveransetidspunktet. Prosessen sikrer således raskere ”time-to-market” og økt fokus på forretningsmessig verdi. Foredraget fokuserer på hvilke styringsparametre som benyttes i iterativ systemutvikling, og hvordan disse konkret sikrer en verdidrevet prosjektgjennomføring.
Outline Kort om iterativ og inkrementell systemutvikling (5 min) Hvorfor iterativ og inkrementell systmeutvikling bidrar til bedre kvalitet (10 min) Hvilke styringsparametre som sikrer verdidrevet systemutvikling (10 min) Hvordan disse parametre brukes til løpende og målrettet planlegging og kontroll av verdiskapingen i prosjektet (15 min) Konkrete erfaringer - do’s and dont’s (10 min) Spørsmål og svar (10 min) Required experience Erfaring fra ledelse av eller deltakelse i systemutviklingsprosjekter Expected audience Ledere med ansvar for utviklingsprosjekter, program- og prosjektledere og erfarne systemutviklere

The Sun JVM has literally hundreds of command line options that can be used to control its internal functions. This session will explore a subset of those options explaining the different ways that garbage collection, threading and instruction execution can be configured for different types of application to improve performance.

Apache Geronimo has rapidly grown to be a successful community and an architecturally advanced implementation of J2EE standards. This presentation will inform the audience of its design motivations, history, and possible future directions. This also touches both open source community development and avenues for commercialization.

Traditional n-tier applications are quite inflexible to changes in the domain model. A common architecture is to use data transfer objects (DTO) between client and server. A change in the domain model will imply changes in many places; in the DTO layer itself, in the DTO to client mapping layer, in the server to DTO layer, in the domain/business layer and finally in the persistence layer. This is a very tedious and error-prone approach. As part of the ModelWare EU-project, WesternGeco has developed a framework that supports a transparent and shared domain-model between client and server. All persistence needs are handled on-demand, meaning that there is no need to explicitly define what should be created, retrieved, updated, or deleted (CRUD). All such operations are available from a remote client, where Java dynamic proxies takes care of tracking what needs to be done . Changes to the domain model needs to be done only in a single place; - in the domain layer itself. The framework is flexible with respect to communication middleware and persistence layer. The CRUD part of the domain-model is generated from UML class-diagrams, while the business behavior is hooked in as conventional Java classes.
This talk will explain and demonstrate the framework by a real example; a requirements management system (Precise) built as an Eclipse plugin. This application is also built as part of the ModelWare project. The implementation uses Hessian for communication, Jetty as servlet container, Hibernate with MySQL as the DBMS, and Eclipse plugin as a client application using the framework. The modularity of the 11 modules is taken care of by using Maven 2 for dependency handling. Other tools tested to ensure proper modularity are: Tomcat, Burlap, PostgreSql, HSQLDB, and db4Objects.

It has been five years since Effective Java™ was released. The Java™ platform has evolved, and we've learned more about how to use it to best effect. This session covers new material that will be added to the second edition. This material should be useful to every working Java technology programmer.

Josh Bloch present eight more programming puzzles for your entertainment and enlightenment. An entirely different set of puzzles from those presented in previous years, this year's talk focuses on features introduced in the Java™ 2 Platform, Standard Edition 5.0 (J2SE™ 5.0)--"Tiger"--release. The game show format keeps you on your toes, and the puzzles teach you about the subtleties of the Java programming language and its core libraries. Anyone with a working knowledge of the language will be able to understand the puzzles, but even the most seasoned veterans will be challenged. The lessons you take from this talk are directly applicable to your programs and designs. Some of the jokes may even be funny.

This talk covers Java Management Extensions (JMX) in Java EE, existing tools to manage and monitor your Java EE based applications, as well as examples of how you can implement application-specific management of your own applications using JMX technology. The session starts with an introduction to the management and monitoring information provided by the Java EE platform, and shows how to use JConsole and MC4J to tap into the wealth of monitoring information provided by the Java EE platform and the Tomcat server. JConsole (included in JDK 5.0) and MC4J are monitoring and management tools that provide information on performance and resource consumption of applications using JMX technology. Secondly, we are going to look into different aspects of application-specific management, and how JMX MBeans allows you to configure, manage and monitor your application. The last part of the presentation demonstrates some of these aspects on a Java EE application using the Spring Framework. When you attend this session you will be acquainted with some of the existing tools for managing and monitoring JMX-enabled platforms and applications, and should be able to start implementing application-specific management for your own application through JMX MBeans.
Intro (5 min) o Short intro to JMX o Management environment in Java EE 5 Connect to provided MBeans (15 min) o J2EE Management (JSR 77) o VM-provided and platform-provided MBeans o Demo : JConsole o Demo : MC4J Application specific MBeans (15 min) o Areas of application management o Building a manageable application with Spring o Best practices / lessons learned Demonstrations (15 min) o Configuration of logging o JMX and Ajax o Application statistics Q & A (10 mins) Duration 50 minutes with 10 minutes to Q and A. Language Norwegian Level: Intermediate Required experience General JEE knowledge, interest in JMX technology and examples of good use of JMX. Expected audience Devlopers / architects that are curious about JMX and want to learn more about how to use JMX to configure, manage and monitor your application.

My MVC (Model-View-Controller) is a well known architecture for bridging the gap between the user’s mental model and a computer. MVC supports the user illusion of working directly with the domain information (models) as seen in different perspectives and presented in different views. All I/O code is pulled out of the model programs; making them simpler and more readable. The MVC is particularly applicable to situations with complex information and knowledgeable users. My DCA (Data-Collaboration-Algorithm) is a new architecture for creating simple solutions to complex problems. It uses a divide and conquer approach to hide object substructures within components that appear as regular objects in their environment. The DCA architecture further simplifies the internals of complex components; data and collaboration aspects are refined and made explicit in specialized data and interaction objects. The result is disentangled and more intelligible code with member objects being purified to implement the essential algorithms only.
Outline 1) Intro (4 min) The BabyUML project - “The price of reliability is the pursuit of the utmost simplicity” 2) The well-known MVC: Model – View – Controller (15 min) a) Goal and abstract architecture. b) Example demo for whole talk: Project panning with activity network. c) MVC Structure. View and controller details. d) Behavior example: Controller coordinates selection. Example code. 3) The new DCA component separates Data – Collaboration - Algorithm a) Data as base relations (a “micro database”). Code explicitly declares “What are the objects”? b) Collaboration as a temporary relations; queries. Provides a tailored object structure. Code explicitly declares “How are they interconnected”? c) Algorithm specifies interobject interaction. Code explicitly defines “How do they interact?” d) Two code examples: i) A View access base objects through a collaboration. ii) A network method (frontloading) access database through a different collaboration. 4) Summary and conclusion (6 min) a) MVC and DCA paradigms summary b) Critique: when to use and not use MVC and DCA c) Final claim: MVC and DCA scales! 5) Q and A (10 min) Duration 50 minutes + 10 minutes to Q and A and transition to next talk. Language English or Norwegian as preferred by organizers. Level Intermediate Required experience Some knowledge of Java. Expected audience The talk is for system designers and architects who will see novel principles for structuring complex systems of interacting objects. The goal is to build self-documenting systems that can be modified with confidence.

The use of design patterns in our applications gives us a great tool for communicating design decisions, and represents best practices for solving recurring design problems, but they can also be quite cumbersome to write. In this talk I will take a look at some of the classic Gang of Four patterns and contrast the Javabased and AspectJbased implementations. I will also illustrate that some of these patterns are much easier to grasp and that some are no longer needed with AOP.

This session will demonstrate how to use the revolutional dynamic tracing framework, DTrace, that ships with Solaris 10 to profile java applications. DTrace allows the developer to profile a complete system, including the kernel and I/O, and is thus not limited to the application layer. After this session you will be familar with the DTrace concept and ready to write your very first own D program.
Author introduction (5 min) o Rikard o Peter DTrace intoduction (15 min) o What is DTrace o Compared to usual Profiling tools + the added value o Usage scenarios + System in production + Black box - crash analysis The D language (5 min) o Hello world Using DTrace with Java (25 min) o Core presentation Demo (through out the session) o 5-6 demos The future for DTrace and Java SE 6.0 (5 min) Q&A (5 min)

The session will introduce Java developers to the Microsoft .NET port of the popular framework Spring, and show how they can leverage their Spring experiences to develop enterprise grade .NET applications. The session also touches on .NET implementations of Hibernate and iBatis.
Why Java developers should care. A swift comparison of C# 2.0 and Java 5. Introducing Spring.NET An overview of Spring.NET Key differences between Spring and Spring.NET A well-known demo in an unknown environment – MovieFinder.NET Developing ASP.NET applications with Spring.Web Data access with Spring.NET and NHibernate Developing Windows Services with Spring.Services Connect the dots – A walkthrough of the SpringAir reference application Spring.Core Spring.AOP Spring.Data.Ado Spring.Data.Ibatis Spring.Web

Models are often viewed as something you create during design time and use to generate code. What if we turn the approach upside-down and generate models from code? Humans are very good at recognizing patterns in images, making visualizations a valuable tool to, for example, recognize dependencies or data flow. This is particularly true for dynamic, loosely coupled systems that are often less explicit and evolve over time. Once you have generated a model you can take things a step further and run checks and validations against it. Visualizations can also be used to plot out source code metrics over various dimensions to detect potential “hot spots” in the application that may require special attention.
This session applies the concepts of visualization and model generation to a broad range of usage scenarios, such as asynchronous messaging, software components and object-oriented applications.

Quite often when teams are faced with the pressure of dealing with poor performance, the first instinct is to revert to those development techniques that are all so like your favorite pair of slippers. The problem is, it is almost impossible to diagnose a performance problem using static analysis of the code. To be successful (rather then lucky) one must be able to acquire dynamic data from the runtime and then be able to understand what that data is telling them. This talk will dive into how one can instrument J2EE/J2SE applications to diagnose performance problems. But since power point slides are cheap, we will minimize time looking at them in favor of spending more time solving performance problems together.

In this session Rod Johnson will describe the new AOP support in Spring 2.0, how it integrates with AspectJ, and how it fits in the construction of enterprise applications. Using an example-driven approach, attendees will learn how to simplify the implementation of many common enterprise application requirements. The way you think about software may never be the same again... In this session Adrian Colyer will describe the new AOP support in Spring 2.0, how it integrates with AspectJ, and how it fits in the construction of enterprise applications. Using an example-driven approach, attendees will learn how to simplify the implementation of many common enterprise application requirements. The way you think about software may never be the same again...
<TBD>

This session describes how to build a Swing application that looks good and works well. It presents the most critical Dont's things you should avoid and the most important Dos - guidelines you should follow. You learn about easy steps for improving the appearance of your visual design and how to compete with or outperform decent native desktop applications. Several examples of good and poor design demonstrate the effect of the techniques described in this session.
Introduction Presentation Goal Agenda The problems we face 10 Steps to improve your UI Focus of this talk Don'ts Principles Colors, Fonts, Icons Dos Clutter Reduce to its essence Special Swing problems Negative space Align,group, relate, balance Consistency, aspect ratios, contrast Scaling with font, resolution Tips & Tricks Looks&Feels Advanced layout issues Responsiveness, application startup Performance The power of the Java Foundation Classes Before & After Examples Summary & References Summary References: libraries, projects, articles, books Questions & Answers Required experience Basic Swing experience Expected audience Everyone interested in improving a Swing UI. The attendee will learn simple techniques for improving his Swing design.

Animation and whizzy graphical effects can be totally gratuitous, but they can also be used to make applications more effective and users more productive. This session examines fundamentals of timing and animation and shows techniques for implementing cool effects on Swing components. It also discusses recent advances in combining 2-D and 3-D effects in the Java™ Platform, Special Edition (Java SE) 6 ("Mustang") release.
Fundamentals of animated Swing effects (20 minutes) timing component animation animated transitions Advanced demos and custom effects (15 minutes) Combining 2D and 3D with the OpenGL bindings (15 minutes) Overflow/Q&A (10 minutes) Required experience Attendees must be familiar with Java/Swing GUI development. Knowing how to create a custom component is a plus. Expected audience This session is meant for all developers that have to write rich clients. With the uprising of advanced rendering effects and animations in modern operating systems (Windows Vista and MacOS X.) The goal of this talk is to teach how to achieve the same results effectively with Java/Swing. Attendees will learn how to improve the user experience by providing richer user interfaces.

Java DB is Sun Microsystems branding of the Apache Derby database (http://db.apache.org/derby). Java DB is a pure Java, small footprint, easy to use relational database engine.
Part I: Java DB overview What is Java DB: Open source Apache project, pure Java, small footprint History from Cloudscape via IBM & Informix, to Apache Derby and Java DB Java DB features Implemented features, standards, platforms, security Client/server vs. embedded Java DB Java DB performance Java DB compared to other open source databases Java DB bottlenecks and tuning Java DB architecture The architectural structure of Java DB the basic principles of the database engine Java DB future Where to go from here Planned (and not-so-planned) new features Part II: Java DB usage Embedded Java DB Java DB embedded in small applications "Database-on-a-jar" - Java DB read-only database in a zip/jar-file. "Database-on-a-stick" - Java DB on e.g. a memory-stick Server Java DB Normal Client/Server operations Combined embedded and server usage Scaling How Java DB scales Horizontal scaling with e.g Sequoia (C-JDBC) HA Java DB Java DB high availability with Sequoia How is this compared to a real HA solution In-memory Java DB What is meant by "in-memory"? Speed or no durability? Comparision to e.g. HSQLDB Q&A Approx 45 minutes + Q&A

This talk will investigate how metadata, and in particular the annotation support introduced in Java 5, can be combined with aspect oriented programming. Used carefully the combination can be both powerful and interesting.
AOP in 4 minutes. Pros and cons with signature based join points. Introducing annotations. Pros and cons with annotation based join points. @OP example application. Summary and some final thoughts on @OP. Q&A Required experience Experience with object oriented programming. Expected audience Anyone interested in AOP.

De siste årene er bruk av Object-Relational Mapping-verktøy som Hibernate, TopLink og JDO blitt stadig mer populært. Dette er blitt enda mer aktuelt med Java Persistens API som er kommet som en del av EJB3.0, samtidig som at det er et felt som lett blir undervurdert. I dette foredraget vil man få lære hvilken innvirkning ORM-teknologi har på arkitekturen og få se mer av hva som skjer i bakgrunnen når man benytter ORM for persistens og hvilken innflytelse dette kan ha på ytelsen. Jeg vil først ta utgangspunkt i de fundamentale forskjellene mellom Java- og database-teknologi, både fra et teknisk og organisatorisk perspektiv for å se hvilke utfordringer man står ovenfor. Jeg vil deretter se kort på forskjellige metoder for å implementere persistens, både for å vise hva dette valget gjør med arkitekturen og spesielt hvordan valg av ORM skiller seg fra andre teknikker. Deretter vil jeg se nærmere på hvilken innflytelse forskjellige implementasjoner av arv, lesing av objekter med lazy-loading og caching har på ytelsen. I tillegg vil jeg også bruke en del tid på n+1-queries problemet og forskjellige måter å håndtere dette på da dette illustrerer mange av de utfordringene man møter ved bruk av ORM-teknologi Foredraget vil ikke basere seg på et spesifikt ORM-produkt men fokusere på hva som skjer i kulissene og hva slags SQL som faktisk kjøres, hvilket er felles for de fleste produkter. Til slutt vil jeg også se på tilfeller hvor ORM kan komme til kort og hvor andre alternativer kan passe bedre.
Outline Utfordringer med persistens, The Object-Relational impedance mismatch (5 min) Tekniske Organisatoriske Tre forskjellige typer design for persistenslaget (5 min) Vanlig JDBC Lagrede prosedyrer Object Relational Mapping ORM-implementasjonsteknikker (10 min) Lazy-loading Arv ORM-tuning (15 min) Caching N+1-queries problemet, et lite eksempel og hvordan det kan løses Projeksjoner Skriving (5 min) Minimering av skriving til basen Utnyttelse av databasen (5 min) Når bør man vurdere andre alternativer? (5 min)

This tutorial is designed for those familiar with Maven who wish to make the most of Maven in a team collaboration environment. A brief overview of Maven will be provided before digging into some advanced uses of Maven in the context of team development, and how to leverage related Maven technologies to help with team development.
In this session you will learn: How Maven helps teams to collaborate more effectively How to set up consistent developer environments How to setup Continuum for team continuous integration We currently do not have an outline for the talk, but will make one in the next few days. Duration: 5 minutes Main part: 55 minutes. Given the practical nature of this talk we assume most questions will come while talking so we won't make a particular long A&Q session in the end. Language: English. Required experience: Knowledge of Maven required. Expected audience: This talk is suited for developer of all experience levels and project managers who manage teams of developers. It will benefint everyone who's involved in a the day to day operations of a development team.

Client side applications are notoriously difficult to test, with many of the traditional approaches leveraging screen scraping techniques resulting in both brittle and costly tests. There are a number of alternative ways of testing Swing GUIs, and we will be looking at one of these that make testing Swing applications easier and more reliable. We will investigate how you can apply this testing technique for TDDing an entire Swing application that will be both robust and reliable. We will look at how you write acceptance level tests and the patterns that you could implement in a swing application that allows you to fully test all the components before you get an acceptance test passing. We will demonstrate the robustness of tests by demonstrating how you can changing the way the components are laid out without breaking tests. We will also discuss all the difficulties, tips and tricks that you should be aware when you do decide to write tests for your application.
Introduction Overview of TDDing 5 minutes Writing Acceptance Tests Live demonstration of how you go about writing an acceptance test and watching it fail 5 minutes Structuring Swing Applications Talking about the different parts that make up the Swing application and how they interact, highlighting the way that they get used 10 minutes Implementing Acceptance Test Live code demonstration as we add more unit tests and code to get the acceptance test passing 10 minutes Robustness Demonstration Changing the layout of a component without breaking a test 10 minutes Top Tips Discussing all the things to be aware of including threading, timing, how you can test drag and drop, double clicking, modal dialog boxes, resizing, etc 10 minutes Questions and Answers 10 minutes

Memory management problems in object oriented programming languages are so serious that Java provides automatic garbage collection. Unfortunately problems of efficiency and space leaks remain. Early detection of these is vital but is complicated by the fact that these problems often do not show unless a program is run for an extended time which can happen after testing occurs. This paper considers what tools a Java programmer can use to monitor memory use and detect problems as early as possible.
Time Introduction - what the problems are and why early detection is important - 10 minutes How to detect Memory management problems in a language like Java which does not give the programmer access to the garbage collector - 40 minutes Conclusions - 10 minutes Questions - 10 minutes

The NetBeans™ 5.0 IDE introduced a next-generation GUI builder tool that radically simplifies layout design of Swing based-GUIs. It has never been easier to design professional UIs that can run on various platforms, be translated to different languages, look good, and behave consistently. All that without the usual need of fighting with layout managers. In this presentation, the developers of the NetBeans GUI Builder (formerly code-named "Matisse") take you through a tour of the GUI builder, demoing and explaining main features, and focusing on how to solve typical UI design problems. The session presents various tips and tricks for layout design and effective use of the Swing in a GUI builder. See how to internationalize the UI, how to use custom components, and more. Learn from the experts about the main principles of cross-platform UI design, UI guidelines in layout, comparison of various approaches and design styles, and typical mistakes to avoid. Last but not least, the Matisse authors reveal some new things being prepared for the next release and ideas about the future of the GUI builders field. Overall, the presentation provides a solid theoretical and practical basis for anyone who needs to quickly create a good-looking Swing UI that just works. The session requires a basic level of prior experience in programming Swing GUIs and using GUI builder tools.
1. A tour of the GUI builder -- Demoing and explaining main features -- Focusing on how to solve typical UI design problems -- Various tips and tricks for layout design and effective use of the Swing in a GUI builder. 2. How to internationalize the UI, 3. How to use custom components 4. New things being prepared for the next release 5. 15 Minute Demo: JFugue Music Application Built with the Matisse GUI Builder

Java allows the experienced developer to write highly flexible code, especially when using dynamic features like proxies and references. In this talk, we bring these together with generics and enums. We will demonstrate some approaches of using Java's dynamic proxies to create virtual proxies, protection proxies, dynamic object adapters and dynamic decorators. A part of the talk will also explore the performance implications and compare it with the benefits gained. P.S. If you are wondering why "enum" is listed under "advanced features" you should definitely attend this talk.

The software development community is at an interesting inflection point. Distributed and interconnected systems are becoming the norm for new development efforts to the extent that the word "application" itself might have to be redefined. Loosely coupled solutions, such as Service-Oriented Architectures, enable independent variability and evolution of components. While many of the architectural benefits of SOA have been belabored over and over we are often kept wondering what it means for developers to code in a service-oriented environment. Will business analysts wire together components in visual tools and make developers obsolete? What kind of new tools should we expect to see? Are there new patterns and guidelines to follow? How can you get ready?

The use of messaging and SEDA (http://www.eecs.harvard.edu/~mdw/proj/seda/ ) are excellent tools for building reliable distributed, loosely coupled applications for high performance computing. This session will give a brief overview of the concepts involved in messaging then show how to to use JMS and POJOs to build distributed applications which scale to meet your requirements. We will then go through some advanced topics using ActiveMQ, the open source message broker, such as load balancing, clustering & high availability, pooling, XA and how to use clients in both Java, C# and Ruby.
In this session, you will learn: • A brief overview of the concepts involved in messaging; • How to to use JMS and POJOs to build distributed applications which scale to meet your requirements; • Some advanced topics using ActiveMQ, the open source message broker, such as load balancing, clustering & high availability, pooling, XA and how to use clients in both Java, C# and Ruby.

The Ruby platform is growing nearly exponentially. We'll look at bridging technologies, including: 1) Ruby on Rails web services. Build your user interfaces in Ruby on Rails, and your object models in Java. Take advantage of the excellent AJAX support and the clearest, cleanest web development environment around, without losing the Java features that are most important to you. 2) JRuby, the Ruby virtual machine that's implemented on Java. With it, you can use first class scripting language to do your scripting for things like web pages, business rules integration, and simple scripting extensions. 3) Ruby/Java bridges. Use tactical XML/RMI to communicate between Java and Ruby.
JRuby: 20 minutes Rails web services: 20 minutes Java to Ruby bridges: 10 minutes

This session covers application design and development in distributed and high performance environments, in particular John will contrast and compare some of today's caching and grid technologies providing real-life use-cases. Rather than bake one technology off against the other John aims to demonstrate their unique benefits and show that, in many cases, they actually compliment each other. Grid and caching have evolved around the needs of high performance, large volumes, low latency and complex data, messages today are orders of magnitude more complex than 20 years ago, volumes are on a global scale and we need everything through in increasingly shorter time scales. From his perspective of the banking world John will demonstrate processing of complex financial derivatives through several vendor products; Modelling and Java Binding with C24's Integration Objects, High performance Web Services and a distributed ESB with IONA's Artix, eliminating the database with Tangosol's Coherence and distributed High Performance Computing with GigaSpaces.
Agenda Introduction Primer to the needs of the banking world Case Studies (code & demo) o Message complexity and modelling o Integration, EAI, SOA and ESBs o Data Caching o High Performance Computing Q&A

Interoperability in software, systems and technologies is seen in the marketplace as important as security and reliability. At Microsoft, interoperability is now a core part of our initiatives to make computing more trustworthy. We believe, that interoperability is achieved by design, collaboration and standards. Interoperability based on standards is just one part of a bigger picture, the whole story goes well beyond that: it is about business (processes) and people, and the needs of both suggest how IT should behave. We will discuss an architectural case that provides some evidence for this holistic perspective on interoperability. And of course we’ll give an overview of some interoperability work in core technology areas that are of interest to the Java community (e.g. WS- , SOA, Open XML vs. ODF etc).

This talk will give a detailed presentation of large-scale searching, using Nutch as an example. Large-scale searching involves various challenges, such as: Retrieving large amounts of data, keeping changing indexes up to date, and supporting many simultaneous searches. Nutch is based on the search API Lucene, but adds functionality for parallel searching, distributed storage, advanced web crawling and file format parsing.
The basics of the Nutch architecture (5 min) How to perform file crawling (5 min) How to perform crawling (10 min) Parallel searches: Making it work. Gotchas. (15 min) Summary and experiences: Things to keep in mind (15 min) Q&A (10 min) Required experience: A good understanding of search engines Expected audience: People interested in Nutch, or in performing large-scale searching

Not all memory leaks are the same. Some eat away at memory slowly over time. Others grab huge chunks of memory all at once. What is common for most of them is that they ultimately cause the virtual machine's heap to run out of space. A large variety of tools provides a high-level view of a Java™ application's memory usage, but not all of them are appropriate for doing the detailed analysis needed to find the cause of a memory leak. Depending on the type of memory leak, some tools are more appropriate than others. This BOF session examines some of the tools and techniques available and uses example memory leaks from real-world Java applications.
The presentation shows how to track down a memory leak where multiple object instances of the same class are created over time, some of which are the source of a leak and others of which are not. It also examines how to debug a memory leak where only a single object instance is the source of the problem. Each of these examples involves a brief examination of the source code and a demonstration using a monitoring/profiling tool. Comparisons are done between the two different situations and the capabilities of the different tools. 1. The easy part: watching the heap and learning you have a problem (15 minutes) 1.1 JVM Command line parameters and associated tools 1.2 VisualGC 1.3 JConsole and other JDK tools 2. A huge object taking up heap space (15 minutes) 2.1 Sample application description 2.2 Heap walking: how to's and what to watch out for 2.3 Using a heap walker to track down the problem 3. A slow death: a small leak that adds up over time (15 minutes) 3.1 Sample application description 3.2 A statistical approach to memory leak detection: pros and cons 3.3 Using a statistical approach to track down a small leak 4. Q&A/Discussion (15 minutes)

The upcoming EJB3 Java Persistence API (JPA) is the successor to the oft-lambasted EJB2 container-managed persistence entity bean model. How well does it meet its goals? Will it get a better reception than its predecessors? In this talk, Patrick Linskey (EJB team lead at BEA, member of the EJB expert group and standards-based persistence evangelist) discusses his thoughts about the best and the worst of the JPA. Patrick categorizes key features (and missing features) as good, bad, or just plain ugly. Come get a glimpse of what's coming to a JVM near you, and hear Patrick's predictions about upcoming best practices and antipatterns.

 Spring Web services (Spring-WS) is a new product from the Spring community that aims to help developing document-driven Web services. In this talk, we will describe the difference between RPC and document-driven Web services, and show that most document-driven Web services are actually RPC in disguise! Additionally, we will show how to implement the following features using Spring-WS: Validating requests and responses the difference between SOAP vs. REST XML Marshalling with Castor, JAXB, JiBX and others Binding domain objects to incoming and outgoing Web service messages Besides showing how to implement these features, we also talk about the possible dangers of them.
After a brief introduction and agenda, we talk about the properties of RPC-based en document-based Web services. We will investigate how these latter services can be built in Spring-WS, and shortly describe what the advantages and disadvantages are to a RPC-approach. Next, we cover the aforementioned list of features: we investigate the worth of each item, and how it can be implemented with Spring-WS. Required experience: Knowledge of XML en SOAP required; Spring knowledge useful Expected audience: Spring users, Web service developers

This session covers application development considerations for achieving maximum scalable performance and reliability in clustered Java Platform, Enterprise Edition (Java EE) environments, improving the scalability and scalable performance of applications through the use of clustered caching to reliably share live data among clustered Java Virtual Machine (JVM) machines in the application tier, providing transparent failover as a key element of uninterrupted operation, and reduced load on the database tier as a key element of scalability. The concept behind the material is quite simple: When it comes to distributed caching, I've seen a lot of approaches that work well and a few too many that don't. The presentation will explain why certain approaches work well, and gives specific suggestions as to how applications should be architected to make optimal use of distributed caching. Attendees Will Learn Cache aside, read/write through and write behind architectures, where and when to use Caching Topologies: the limitations, trade-offs and benefits The 12 essential lessons of Distributed Caching Use cases and a topology quiz
Agenda Introduction Primer to distributed caching Essential lessons Case Studies Q&A

Service Oriented Architecture (SOA) has been among the great hypes within the software industry lately. Product vendors are currently presenting SOA as the solution to virtually all problems although many of them forget what it is all about - building good service contracts that are focused on solving real-life requirements rather than the technology of which can be used to realize a proper SOA. This presentation will address how services in a SOA context can be designed to evolve over time. This will be illustrated by examples in a non-vendor proprietary context. Attendees should learn how public services should be created in order to make them maintainable and evolvable over time. Also, the term SOA itself isn't as important as focusing on service contracts. The public service contract is more important than any term, product vendor and technology.. Also SOA is more than SOAP.
Evolving Services Business requirements evolve over time and this has to be reflected in services. However, in a SOA context, one cannot constantly deploy services that are not backwards compatible. Evolvability is a term that relates to services representing constantly changing business requirements. Such services are decorated over time, they must be backward compatible and they are not allowed to break existing service APIs. Outline Goals Term definitions Services in an enterprise context Maintaining services - by example: Example1: Technology driven Example2: More or less technology driven Example3: Contract driven Example4: Evolving services Summary Q&A

The talk starts with a brief overview of what ESB technology is all about and shows how it can be used to implement a successful SOA. It will then introduce Celtix 1.0, an Opensource ESB, by starting with the project’s history and philosophy and then providing a complete architecture overview of the project along with some of its key goals. The talk will then take a closer look at how each of the Celtix ESB components are designed, and how that leads to achieving easy SOA development. Then it moves on to exploring how Celtix relates to JBI and SCA in the grand scheme of things. The talk will finish by showing how to build, test and deploy a Celtix service.
What is SOA? What is ESB? ESB for SOA. Celtix Project History Project goals Status Celtix Architecture Architectural principles and overview. Bus Concept Message Flows Celtix Components Transports Message Bindings Language Bindings JAX-WS Webservices Celtix and JBI Celtix and SCA Building a service with Celtix. Q&A Required experience: J2EE technologies such as JMS, EJB and Web Services, with a broad understand integration issues and service oriented principals. Expected audience: Developers and architects who develop applications that interact with other applications at the middle tiers.

If we take closer look at the majority of applications in a given organization, integration is done on an ad-hoc basis. As time goes by and the application portfolio grows, the interconnection between the systems and applications start looking like a coral reef: hard and stiff inside, and with some life on the outside. Fumbling with the hard coupled integration points can potentially invoke a cascade of side effects, causing nobody to dare correct the root cause of the problems. Often, people just fix the symptoms by adding a new layer on top of the coral reef of highly coupled systems and applications. To avoid this pit fall, we need to shift the way we think of. We need to accept that IT systems evolve, and the way the organization needs support from them changes. This can only be fulfilled by choosing an integration strategy that is complementary with the evolution of its IT facilities. The talk is a practical story on how a system can evolve from a regular closed system to a dynamic system with unlimited integration points. The talk will reference the EAI patterns described in Gregor Hohpe’s book and map those to real life scenarios.
Introduction to the ‘integration’ problem. (5m) Presenting the first version of the application. (5m) Introduction to Mule (5m) Discovering the Enterprise Integration Patterns, problem solution (5m) Shift towards Mule, converting the core system to Mule components (10m) Adding new integration points to the system (15m) (live code/demo) Summary. (5m) Q&A (10m) Required experience Experience with object oriented programming. Expected audience Anyone involved in developing enterprise systems.

Current approaches to SOA state that services are silos of functional code that make up composite applications. Both Web Services and ESB approaches are not good at managing shared state of service architectures. Stateful SOA applications are distributed applications that require integration with each other on two dimensions: communication and state. Many workflow scenarios fall into this category, as well as distributed computing applications. Normally, states are shared through a centralized resource – such as a file system or a database -- which often creates a scalability and performance bottleneck. Maintaining consistency in such environments also requires the use of a distributed transaction coordinator with an XA interface, which significantly impairs performance. This session will demonstrate how Mule and JavaSpaces can offer a single integrated solution for both delivering the messages and sharing state. The solution is based on a common clustering architecture and deployment environment.
Introduction to the scenario. (5m) Introduction to Mule and JavaSpaces (5-10m) (depending on audience experience) Presenting the first version of the application using Mule. (5m) The solution using JavaSpaces and Mule (10m) Why do we need stateful services? (code example) (10m) Scaling up and out (where existing solutions fail) (5m) Summary. (5m) Q&A (10m) Required experience Experience with object oriented programming and some knowledge of ESBs Expected audience Anyone involved in developing enterprise systems.

The talk will present experiences gathered in analysis and correction of performance and stability problems with BEA WebLogic and IBM WebSphere application servers and JVMs in general. The talk will not be product oriented, the topics presented are equally applicable to all servers/Java environments, although examples given may discuss features of popular application servers. The talk will outline simple measures to take when performing an analysis of perceived stability and performance problems. The talk will introduce experiences with both vendor, third party and freely available tools along with features of homebrewed tools. I will discuss some myths arising from vendor's best performance recommendations, possibly attempting to dispel some of them. Experiences in deployment topology will be among these. Some experiences not often discussed when reviewing vendor supplied "best-practices" whitepapers will be discussed. Part of the talk will delve into the JVM itself and attempt to explain what is going on in some frequently encountered failure situations and indications that may give you some forewarning. Some simple tools for analysis of JVM runtime behavior will be discussed. The Java Management Extensions (JMX) will be featured sprinkled throughout the talk and the role JMX can and should have in application development and deployment will be discussed.
Common traits of Application Servers Resources (get a handle on resource usage) Resources how much is too much? (very common questions surround things like thread pool, JDBC pools heap size. I will try to come up with some kind of pointers as to what may be good values and what are outrageous ones. Failure situations associated with poor resource control will be discussed like "out of memory" errors and "resource handle depletion") VMs: tuning (important aspect of good application server behavior, especially with regards to heap sizes and types.) VMs: what is going on? (How we can learn something about what the VM is doing in various situations, brief look at various garbage collection mechanisms that are available.) A kingdom for a stack trace! (How and what can be learnt form them, use them as a mechanism to analyze serious code problems that hinder maximum throughput) Performance and stability tools. Commercial offerings Make your own nix tools for dummies Use JMX JMX in application servers JMX tooling What is wrong with your test and development environment (often overlooked differences with test and development environments and how to simulate.) Never trust the flyers (Some real world examples of why vendor whitepapers often does not survive a reality check.) Q&A

As enterprises move towards business process optimization, they are looking for efficient mechanisms to orchestrate interactions between systems, services and people in order to achieve their strategic and operational objectives. In this session we will discuss how WS-BPEL a standards based infrastructure can be used in Java SE/EE platform to architect a workflow solution that is integrated with a rules engine based on JSR-94. This session will further drill down into a BPM implementation done at a call center, to show how WS-BPEL, workflow services and rules are used together to create a dyanmic process flow which includes service orchestration and policy based task assignment , escalation and load balancing tasks among users.
Why enterprises are looking at Service Oriented Architecture 5 mintues ? Composite applications & Orchestration 15 minutes ? o WS-BPEL a standard for business process orchestration Agility to business processes via Business rules 10 minutes ? o JSR 94 Can workflow be embedded into business processes 10 minutes ? o Workflow services o Policy & Task based workflow Implementation of a business process orchestration at call center 10 minutes ? o Details of implementations o Best practices What's new 5 minutes ? o WS-BPEL 2.0 Target audience Developers and consultants who are focussed on integration technologies and enterprise application integration. Attendees will be able to understand in detail about the standards for business processes and how to build agile business process with standards-based business rules and workflow. On top of this attendees will be also able to see the architecuture used for a call center application including best practices.

Much has been said about Service Oriented Architecture lately and everyone seems to have their own interpretation of what SOA really is. Not many have focused primarily on the core part of SOA – Services. This talk will not be about SOA and how it is the solution to all your problems. The focus in this talk will be on services and what a service really is in the SOA context. In the beginning of the talk I will introduce four conceptual service layers. We will then dwelve into an example guided tour outlining the characteristics of the different service layers. Characteristics include contractual elements, implementation strategies, implementation technologies and guidance of the correct choices.
Introduction (1 min) Objectives (1 min) Services and SOA (5 min) Service Layers (10 min) - Human Interaction Workflow services - Application to application orchestration services - Aggregated/Composite services - Core services Characteristics of the layers (10 min) Characteristics of the implementation strategies (10 min) Characteristics of the Implementation technologies (10 min) Resources (1 min) Q&A (10 min)

Service engineering is becoming a discipline in its own right, not only in telecom but in the ICT world at large. It is challenging because services tend to depend on each other, be distributed and dynamic. High demands on time to market, compositionality and robustness make the life of service developers hard. The trend is towards loosely coupled and collaborative services both in the business and the telecom/embedded domain. To master these challenges it is necessary to understand the fundamental nature of services and service composition, and provide tools, platforms and methodologies to support them. Considering the widespread use of services and the attention received by service providing systems and architectures (e.g., SOA), surprisingly few approaches actually do this. Most approaches are targeting the business domain and neglect the communication/embedded domain. This is unreasonable since these domains are increasingly being merged. We present a model-driven approach to convergent service engineering. It considers a service as a collaboration involving loosely coupled objects playing different roles. Service development starts by specifying the behaviour of collaborations and roles. The roles are then composed into active objects with precise behaviour descriptions in form of state machines, which are checked for consistency and then automatically translated to Java code. To facilitate the approach, we developed the Eclipse-based tool suite Ramses. It supports editing of state machines, automatic code generation, visualization of running systems, and extensive consistency checks based on new and scalable principles. It has been successfully applied on student projects to develop a large number of demonstrator services.
Introduction to service engineering and the challenges of convergent services and service composition Using collaborations to specify services, to define interfaces, and to visualize service executions, illustrated using a service example Using Ramses to define state machines and to check internal consistency Using Ramses to generate code and visualize the running system. Lessons learned from tool integration in Eclipse

From being something mostly associated with Artificial Intelligence (AI) and highly specialized Expert Systems in the early 90’s, Rule Engine Technology now seems to get a more important role in “ordinary” enterprise software architectures. This is most noticeable in the platform vendor space, where Rule Engine Technology is pointed out as one of the key component of a well-designed Service Oriented Architecture (SOA). These components are referred to as Business Rules Engines (BRE).   Selvaag BlueThink have several years of experience using Rule Engine Technology developing complex rule-based systems for the construction industry. The main motivation has been to offer flexibility in business critical applications, shorten the development time, along with the opportunity to implement products with great complexity. This presentation will give an introduction to Java based Rule Engine Technology in general, and insight into experiences from the development of one of Selvaag BlueThinks products, the Intelligent House Configurator (IHC). IHC is an application supporting the design/configuration process of housing products. This process is highly complex and the users must deal with an extreme amount of configuration parameters. Rule Engine Technology has shown it self as well suited for solving these problems.
Introduction Who we are Who Selvaag BlueThink is and what we do An Introduction to Rule Engine Technology (20%) Rulebased development: Rules, what is it? Motivation Rulebased development vs. tradition procedural development Rule Engines (RE) The main components of a rule engine Optimalization algorithms - Rete Examples of some Java based rule engines Jess Drools Standards Jsr94 standard Rule Engine API SBVR, RuleML and SWRL for rules Business Rules Engines (BRE) Experiences from The Intelligent House Configurator (IHC) (70%) An introduction to IHC What is it, and what target(s) does it have? The solution Our motivation and experiences Why use a rule engine? Experiences, have we achieved what we expected? Challenges we have had, and how we have solved them Some thoughts about the future The use of rules in a SOA and workflow perspective Combining rules and semantics Where do we see a rule engine fit in the future of the CASA Knowledge Suite?

Integration solutions have traditionally required the use of non-standard technologies to create functional systems. Java Business Integration (JBI) specification (JSR 208) defines the core of a service oriented integration bus and component architecture for SOA. It standardizes the common message routing architecture, plug-in interfaces for service engines and bindings, and a mechanism (Composite Service Description) to combine multiple services into a single executable and auditable unit of work. The presentation will include a demonstration using the OpenESB product. OpenESB is an open source, ESB implementation based from the ground-up on the JBI standard.
Introduction to JBI. o The motivation for JBI o The scope of the standard o Concept of an Integration MetaContainer. o Difference between the scope of JBI and ESBs as a whole JBI Architecture o Service Engines and Binding Components o Message Exchanges o WSDL 2.0 Message Exchange Patterns o Normalised Messages o Normalised Message Router o JBI Management and Administration o Service Units o Service Assemblies JBI Component Development Lifecycle o Develop, Package, Deploy, Run o Demonstration using the OpenESB product.

Based on actual real-world experiences (with names and details changed to protect the guilty), in this session Jonathan Purdy shares some of the best-kept secrets in the industry, including architecture and development tips that are certain to push projects over budget and beyond deadlines. Mr. Purdy will count down through the 10 biggest mistakes that lead to project failure, from specifying the wrong mechanism for data access to failure to do system testing throughout the development process. He will also discuss the best and worst practices for eliminating single points of failure in Java EE applications. A number of case studies will be presented as "evil rules", i.e. a tongue-in-cheek "do this to totally botch stuff up" set of instructions, which will show how something that seems reasonable at first blush is actually quite dangerous. Some attendees may mistakenly use this information to avoid pitfalls, errors, and other common causes of project failure.
Overall Presentation Goal: In these slides, you will see why that zillion dollar project failed. You’ll likely laugh - you’ll want to cry! To see these practices revealed. Agenda The Top Ten Ways to Botch an Enterprise Java Application Eliminating SPOFs 4 Evil Rules For Designing Non-Scalable Applications Q&A

The "anemic domain model" antipattern was proposed by Martin Fowler in 2003. The antipattern describes how domain objects often become data containers instead of exhibiting behaviour. Part of the problem is making model objects aware of the persistence mechanism used so they can make changes to the persisted state of a system. Telio has since the summer of 2005 been using dependency injection (DI) in domain objects to alleviate parts of this problem. The session will show the architecture of the solution in use at Telio, which is based on Spring and Hibernate. The technique that is described has its own set of problems. Some of these problems will be dealt with in the talk.
Walkthrough of the transaction script, domain model and anemic domain model patterns Using hibernate interceptors to inject dependencies Using the @Configurable annotation to inject dependencies (example) Comparison of the two injection technologies Comparison of the effects of applying the domain model pattern in a production application Summary and questions

Because of our expertise in online store web-application development, we were asked to develop yet another online storefront application by a company extending its business to online sales. Starting this new project was just about the right time to get started with JSF. Strong of our experience in such missions and outlining the requirements to the client, we soon realized a few pitfalls of the JavaServer Faces technology for such public website development. Stepping through the usual development process we encountered challenges using this new technology. Still we kept on going with it, solving every aspect of the problems coming across. Resulting is a web-application making use of JSF, Spring and Hibernate. We would like to share our experience solving the problems we ran into with JSF developing such a public web-application, like: proper doc-type declaration, templating, EL (c:forEach, c:if tags), search- engine friendly URLs, ... We also show how to make JSF integrate smoothly with the Spring framework and Hibernate ORM. This talk will cover the complete application development cycles as we implemented the solution for our client, showing how Java, using JSF together with other commonly used frameworks, enabled us to deliver a high quality web-application meeting the requirements of such public commercial websites.
Presentation Introduction - Introduction of the talk (what you’ll learn and so on) The mission - Project evaluation and requirements definition Architecture - This will cover what decision were made and why The JavaServer Faces technology - First why we have decided to give JSF a chance Templating Facelets Shale - Covering templating, we’ll see how these two technologies did not pass our tests and were both rejected for the project Separation of concerns The Spring Framework Hibernate ORM service - We’ll cover the integration of JSF with these both well-known and widely adopted frameworks Wiring everything - Actual deployment of the solution Front-end JSPX URL based navigation Internationalization - This part will cover how JSF did suit the requirements set and what problems were encountered actually fulfilling these Backend Remoting - Covers how the solution was managed by the customer Conclusion Q&A

The Google Web Toolkit (GWT) is a Java-centric framework for creating AJAX applications. GWT cross-compiles Java source into JavaScript, allowing Java developers to use their existing Java skills and tools to easily create AJAX applications with virtually no learning curve. After a short introduction to GWT, we will dive quickly into a few key topics including high-performance AJAX, internationalization, and integration with existing web applications.
- What is GWT? A short introduction to GWT with a "Hello, world" demo. - What capabilities does GWT provide? - What kind of skills are needed to use GWT? - Why did we choose Java as the source language? - Why does translating Java into JavaScript make sense? - Why didn't you do X instead? (where X is a huge list of alternative ideas) - How to internationalize GWT applications. - How to maximize performance of GWT applications. - How to integrate GWT with existing web applications. Intended audience: (The topics are of general interest to all types of audience members, but probably skewed toward Developers, Architects and Technical Managers) Developers, Architects, Project leaders, Technical managers Level: Intermediate-to-advanced, although since GWT is relatively new, the bar for "advanced" isn't that high yet.

Traditional web applications are incredibly vulnerable to bugs and performance problems relating to state management. Developers are forced to handle issues like back button navigation, multiwindow browsing, and session size management in an utterly ad-hoc fashion. Web frameworks offer only extremely fragile state management constructs such as HttpSession and HttpRequest. Access to transactional components from the web tier has also been problematic. J2EE provided no way to have simultaneous access to state held in contexts associated with the web request, and state held in transactional resources accessed via EJB. Finally, J2EE had no first-class construct for representing state associated with a long-running business process.
JBoss Seam is a new application framework for Java EE 5 that introduces the notion of declarative, contextual, application state management. Seam integrates EJB 3.0 with JSF and, optionally, business process management via jBPM, providing a uniform component model for Java EE. This presentation will discuss problems affecting stateful web applications, introduce Seam’s declarative state management model, and demonstrate how easy it is to build robust web applications using EJB 3.0, JSF, and Seam.

WATIR stands for Web Application Testing in Ruby and is an open source functional testing library for automated tests to be developed and run against a web browser. The Watir project is actively being worked on and it's becoming more and more popular. This presentation covers the projects experience using the Watir test framework. How we got started with simple Watir scripts that evolved into continuous integrated executable acceptance specifications. Slides in English, talk in Norwegian
Introduction to Watir Writing and running Watir tests in Eclipse Adding assertions Watir as part of the agile process: Executable specifications Incorporating Watir into the continuous integration loop Lessons learned, tips and tricks Summary and QA Required experience Understand programming basics (some Ruby experience would be beneficial). Slides in English, talk in Norwegian

Can a client-side Ajax solution and server-side Faces solution co-exist and play well together? Or are they each solving a similar problem in a different and incompatible way? This session will discuss how the JavaServer Faces framework can be used to embrace Ajax today, while protecting Web applications from radical rearchitecture each time there is a change in direction of client-side technology. The session will address key aspects of Faces component development, and introduce innovative techniques to adopt Ajax. Jonas and John will discuss how to best leverage Ajax to create extremely interactive rich Internet components, and issues that developers encounter when building Ajax-enabled JSF components. The session will also cover advanced techniques such as dynamic content type negotiation, JAR-based resource delivery, and dynamic render kit selection. The presenters will be using the Dojo toolkit in combination with JSF, HTML and XUL to illustrate their points.
Ajax Philosophy (10 minutes) From AJAX to Ajax - Brand name for a set of very useful technologies Cross-browser support? - Writing to W3C standards doesn't work File Upload Functionality Need a Sane Development Model - You need a framework to help you focus on your application Don’t re-invent the wheel - Use available Ajax toolkits Strengths of Ajax - Provides highly interactive clients and provides separated channels for server-side communication and UI refresh (XMLHttpRequest). Weaknesses of Ajax - You're still writing your Web application's UI in JavaScript and next generation of legacy applications Demo of Ajax (5 minutes) JSF Philosophy (10 minutes) What is Faces? Component Model & Rendering Abstraction UI Behavioral Split Rendering (HTML, XUL, HTC, whatever) Formal Phases - Initial Request and Postback Extensible - It is possible to override any aspect of JSF to customize its behavior Strengths of JSF - JSF is next generation ready Weaknesses of JSF - The total complexity can be intimidating Demo of JSF’s Rendering Capabilities (5 minutes) Can Ajax & JSF work together, for real? (15 minutes) Consider Joe Developer... Joe knows JSP and Swing. How can Joe use Ajax? Ajax and Faces: Friend or Foe? Handling Ajax Resources - The "Installables" problem Handling Ajax Resources - "Installables" solutions, loading resources out of JARs Ajax JSF Data Fetch - No side effects, no change to JSF component tree, no need of JSF lifecycle, right? Ajax JSF Page Refresh - Different Ajax JSF solutions Handling DOM Differences Who's Controlling the Content Type? - What impact does this have on my Ajax JSF components? Any Proof? Demo of Rich Client Development with JSF (5 minutes) QA (10 minutes)

Aranea is a web framework that facilitates Object-Oriented techniques like encapsulation and polymorphism by using POJO components, explicitly managed by the programmer. Aranea is also a full-stack web framework providing both a powerful controller that supports nested flows, and a custom JSP tag library. This talk however is not so much about Aranea (which we dive through in about 10 minutes), but about the object-oriented programming techniques applied to the web development. We want to show how usual OO idioms and patterns can make challenging tasks suprisingly simple and how many inherent problems just seem to go away. We will also briefly discuss the integration facilities that Aranea provides and how it can help to unite the fragmented web framework ecosystem.
Why Object-Oriented web matters? What's wrong with the current situation? Aranea crash course Applying OO with Aranea, OO idioms and GoF patterns Bonus perks for using OO (popups, multi-submit, back button) Uniting the web frameworks  

RIFE is a full-stack, open-source Java web application framework, offering fast results with the promise of maintainability and code clarity. While many are attracted to RIFE for the productivity gains it offers, the framework actively tries to solve difficult problems with creative solutions that combine power and flexibility with comfortability. RIFE has pioneered many novel ideas in Java web application development and we will go over a series of concise practical examples to demonstrate: RIFE's focus on developer comfortability with instant reloads and centralized declarations, native Java web continuations, metaprogramming through constraints and meta data merging, run-time POJO-driven CRUD generation, bi-directional logic- less templates, automatic context-aware components, and the integration of a content management framework.

You’ve heard the terms. You’ve seen the debates on the blogs. But what does it really come down to? What are SOAP and REST? Is one actually better than the other? Is SOAP too complex? Is REST too simple? Does Amazon’s REST API really get 5 times more usage than the SOAP one? Does this mean you shouldn’t bother with SOAP? This talk will pit the REST and SOAP against each other in an attempt to come to some answers as to which one you should choose!
Outline What is REST? What is SOAP? Debate topics: Are SOAP and REST opposed to each other? Is SOAP too complex? Is REST too simple? What is easier to get started with as a web service writer? What is easier to get started with as a service consumer in Java? In .NET? In Ruby? What about transactions, reliability? What pitfalls are there to each approach? (Ideally the audience would share some experiences here). Conclusions on when to use SOAP and when to use REST

Selenium is a test tool that allows you to write automated web application UI tests in any programming language against any HTTP website using any mainstream JavaScript-enabled browser. This talk will start with a quick demo of writing/recording automated tests using the Selenium IDE, then discuss how you can use Selenium together with your existing Java tests. We'll discuss how you can use Selenium to effectively test Model-View-Controller web UI applications (using a JSF application as an example), how to write robust tests, and how to structure your tests to make them more reusable.
Key points Introduction to Selenium, with Demo (10m) Unit testing vs. Functional testing (10m) Writing testable web applications (10m) Testing a Model-View-Controller (MVC) framework (20m)

The Sun Small Programmable Object Technology (Sun SPOT) is a small wireless sensor that runs a version of Java™ technology called Squawk that is compliant with the Java ME platform. The Sun SPOT platform, developed at Sun Labs, is a small, battery-powered wireless device with an application development environment based on the Java programming language. The Sun SPOT, smaller than a deck of cards, comes equipped with a 32-bit ARM processor and an IEEE 802.15.4 radio for wireless communication. Stackable boards include sensors and actuators such as accelerometers, light detectors, temperature sensors, LEDs, push buttons, and general I/O pins. The devices can be duty-cycled to run for months on a single charge of their rechargeable battery. The small-footprint Java virtual machine, called Squawk, can host multiple applications concurrently and requires no underlying operating system. The full platform includes tools for programming, deploying, configuring, monitoring, and debugging the Sun SPOT network. Join this session and learn all you need to know about Sun SPOT and enjoy the demos.

JSR-001 is the specification for real-time Java giving extremely low latency response from the JVM even with garbage collection happening. This session will look at the realities of real-time Java, how to write programs that use this functionality and some examples of its application. There will also be a discussion of the Mars rover project that used the real-time Java impplementation to test the use of Java in autonomous extra-terrestrial vehicles.
<TBD>

The convergence of the telecom and the IT industry has enabled new and innovative applications and services. Telecom operators are starting to provide open API's (such as OSA / PARLAY and CPA) that the application developers can use to get the position of the mobile, send and receive SMS and MMS, and to set up calls between mobile phones. Most operators today support IP communication (GRPS/3g) with the mobile. The Mobile network and the Internet have thus merged into a technology arena where the IP protocol integrates the different worlds together. This trend will be further strengthened when laptops come equipped with 3g connectivity. The combination of Java enabled (J2ME) mobile phones and GPRS/3g, enables programs running on the mobile phones to communicate with application servers being somewhere on the Internet. In this way a broader market for applications and services is emerging. However, the telecom and the information system industry have different demands on the underlying architecture and communication mechanisms needed to support distributed applications. The telecom industry uses a Peer-2-Peer architecture where the distributed applications communicate asynchronously using messages (objects that contain the information). This is necessary in a world where all parts can take the initiative to a communication and are inherently distributed. The information system industry uses client-Server architecture. This is sufficient where only the client application (user) takes the initiative. In a truly convergent framework both have to be supported, but how can this be done? Ericsson (and now TellU as subcontractor to Ericsson) has as part of the ARTS research project, developed a Java framework (ServiceFrame) designed to become the desired converged technology platform. It can support loosely coupled applications that can be transparently distributed on Java enabled mobile phones as well as on application servers. This talk will present the underlying principles of ServiceFrame and how they are used to bridge the two worlds together.
1.Introduction, (10 min) a.Background, Research project b.Telecom opens APIs, OSA / Parlay c.Convergence of the two industries 2.Network services ( 10 min) a.The difference of the two industries b.Characterizing of services c.Communication style, asynchronous versus synchronous d.Differences in modelling languages, tools and platforms 3.ServiceFrame – a Java framework for service development and execution (20 min) a.Overview b.Concepts used, Actors (UML2.0) c.The execution framework, features, d.Mapping to different Java Technologies (J2ME, J2EE) e.Tools, code generation, hot deployment, viewers f.Examples 4.Summary (5 min)

There's a new umbrella JSR coming to town, the Mobile Service Architecture (JSR 248), which groups together many Java ME JSRs, some old and some new. Come and see an overview of this specification, which JSRs it includes and what additional clarifications it holds. See how the Wireless Toolkit supports MSA by implementing the APIs and bringing supporting tools to aid developers in building MSA complaint MIDlets. See the demos that show off the different JSRs that are part of this new umbrella JSR.
Agenda: Overview of MSA New WTK tools to support the JSRs Demos of new APIs

Next Generation Mobile Java is a platform that brings the service-oriented architecture defined in JSR-232 to the mobile space. The platform promotes the creation of components and services which can be reused and extended, providing at the same time a framework to control their installation, management and security. The platform is built on the foundations of the OSGi framework and the JSR-232 environment. Next Generation Mobile Java provides the developer with a rich environment for the development of applications and services including support for applications using the MIDlet application model. This feature lets MIDP developers leverage their existing expertise and further enrich their applications using product quality services and components supplied by the platform itself or by third-party developers. In this tutorial we will introduce the Next Generation Mobile Java platform and show how applications are supported. We will then focus on the extended MIDlet application model and how it can be used to get the most benefit from the platform. We will show the full development cycle of an application using the MIDlet application model that uses the framework’s features, including shared packages, built-in and external services and the framework’s event bus. We will demonstrate the tools used to package and deploy such applications to a real device. This tutorial aims to introduce the Next Generation Mobile Java and show existing MIDP developers the benefits of the platform, giving them the tools needed to start developing applications for the platform.
1. Introduction, 3m 2. The Next Generation Mobile Java platform architecture, 7m 3. Application Models in JSR-232, 3m 4. Application design using the MIDlet application model, 5m 5. Basics of MIDlets in JSR-232, 5m 6. Use of package sharing, 5m 7. Security, 5m 8. Service consumption, 5m 9. User-interface construction, 7m 10. Packaging and deployment, 2m 11. Summary, 2m 12. Q&A, 10m Duration: 55m Required Experience: Knowledge and interest on MIDP development is expected as well as understanding of component frameworks. Expected audience: The expected audience consists of mobile developers wishing to understand the Next Generation Mobile Java platform as well as enterprise developers that want to extend their applications to the mobile space. Attendants will benefit by getting a first-hand experience on the subject and acquire a broad view of the platform.

Creating standalone applications for your mobile device can be fun, say a tip calculator or currency converter. However, we're talking about a CONNECTED device, so let's build an application that connects to something. Hey, how about our enterprise data center - so for example, I could track the status of my machines from anywhere in the world? And what if I could build that application using a drag & drop visual designer? Get it to seamlessly run on emulators from Nokia, Sprint and others? Better yet, how about using a debugger to walk through the application as it runs on my very own phone? All of this is possible today using NetBeans Mobility. This session is an introduction to J2ME development and demonstrates the features of the NetBeans Mobility Pack.
Creating standalone applications for your mobile device can be fun, say a tip calculator or currency converter. However, we're talking about a CONNECTED device, so let's build an application that connects to something. Hey, how about our enterprise data center - so for example, I could track the status of my machines from anywhere in the world? And what if I could build that application using a drag & drop visual designer? Get it to seamlessly run on emulators from Nokia, Sprint and others? Better yet, how about using a debugger to walk through the application as it runs on my very own phone? All of this is possible today using NetBeans Mobility. This session is an introduction to J2ME development and demonstrates the features of the NetBeans Mobility Pack. Visual Mobile Designer Mobile Client to Web Application Connection Generator Emulator support Preprocessor support for device fragmentation - develop code for any number of devices with a single code base. BlueTooth On Device Debugging Outline An introduction to Java ME (4 minutes) An introduction to NetBeans Mobility (4 minutes) Tutorial - Extending the Enterprise (45 minutes) Visual Mobile Designer (10 minutes) Mobile Client to Web Application Connection Generator (10 minutes) Emulator support (Nokia, SonyEricsson) (5 minutes) Preprocessor support for device fragmentation - develop code for any number of devices with a single code base. (10 minutes) BlueTooth On Device Debugging (10 minutes) Q&A (7 minutes)

Mobile based user authentication has been around for almost a decade, but has never really been a success due to lack of user friendliness, insufficient security or proprietary solutions. This presentation will focus on the emerge of a Java-based security product, which makes the mobile terminal an attractive and accessible security device for any service provider on the internet.
There is a growing demand for cost-effective solutions for secure user authentication. Mobile based user authentication has been around for almost a decade, but has never really been a success due to lack of user friendliness, insufficient security or proprietary solutions. This presentation will focus on the emerge of a Java-based security product, which makes the mobile terminal an attractive and accessible security device for any service provider on the internet. The presentation cover the enCap security product’s Java- and channel architecture, the functions and APIs. Applied technology is Java/JEE on the server side and JME/MIDP on the client side. The use of the new PATS (Program for Advanced Telecom Services)-lab supporting functions will be covered. The PATS-lab is a research agreement between the Norwegian University of Science and Technology (NTNU) Department of Telematics, Ericsson, Telenor and Hewlett-Packard. The experiences from using the PATS-lab and recent pilot-projects will be presented. Why has this been successful choices and what has been the main challenges, from a development point of view? The presentation will also elaborate on how proper authentication and a secure communication channel can boost mobile applications and services. There will be live demonstrations and possibilities for participation from the audience. Bring your mobile!

Case study av Bergen kommunes nye innbyggerportal basert på emnekart. Datagrunnlaget for portalen er fagsystemer, innhold fra publiseringsløsningen Escenic og eksterne kilder (LivsIT, Nasjonal Tjenestekatalog); alt dette sys sammen automatisk for å produsere portalen. Presentasjonen forklarer hva emnekart er, gir litt bakgrunn for prosjektet og beskriver selve den tekniske løsningen (arkitektur, datamodell og integrasjon) samt hvordan den resulterende portalen ser ut.
Hva er emnekart (8 minutter) Kort om prosjektet (2 minutter) Om løsningen (20 minutter) Konseptuel arkitektur Hva brukes emnekart til (og hvordan) Integrasjon mellom emnekartmotor fra Ontopia og publiseringsløsning fra Escenic. Hvordan er søk i portalen løst Erfaringer (10 minutter) Hva var suksess Hva var ikke Oppsummering Required experience: Ingen spesielle Expected audience: Alle som er interessert i nye konsepter

MyPage is a central part of the Norwegian governmental strategy to make everyday life simpler for most people by establishing a common gateway for electronic dialogue with the government. According to the “eNorway 2009 – the digital leap” IT strategy roadmap, all new public services should be made accessible through MyPage. By 2007 it should be established an electronically communication channel between citizen and public services as an alternative to the traditional channels. By 2009 all interactive public services should be reachable in MyPage. As a part of the same initiative there is established a common PKI infrastructure, “The Security Portal” which can authenticate all Norwegian citizens based on open standards like Liberty/SAML. This also enables single-sign-on, federation between all service providers sharing this security context.
The MyPage portal is a virtual service office, a web portal for easy access to aggregating all public services accessible on the Internet. It provides an intuitive and easy way to navigate and search for information, and insight into data that the public authorities have registered on each individual citizen. MyPage offers several personalized services for the citizen, and the citizen can themselves choose which service and that are relevant in their personal profile. Among the services offered in MyPage is register, transactional, messaging, calendar. The register service gives the citizen insight into data stored by the public authorities. The transactional service provides a single-sign-on feature across external services and service providers. The messaging service is a two way communication channel between the public authorities and the citizen, exchanging all kind of personal information, documents, schemas etc. The calendar service gives a personal view into all important personal dates between the citizen and the public authorities. MyPage is build on top of a portal framework based on java, and J2EE running on Solaris. The architecture is SOA enabled to easy aggregate new services at runtime. Web Services is used for inter service provider communication and exchange of data. There is ongoing work to support additional types of services like municipality services etc. within MyPage. The number of integrated services and service provider is most likely to increase heavily in the years to come. Required experience: Some knowledge about security, SSO, portals, Web Services, XML, XSL. Expected audience: Some interested in the above, and those who are interested in the development of the Norwegian citizen portal "MinSide", or a generic portal addressing the issues listed above.

InfoQ.com is a next generation web app/portal implementation combining the latest advancements in portal technology (JSR 170) and web development (WebWork, Spring, AspectJ). This session will walk the viewer through the good, the bad, and the ugly of building InfoQ.com. Walk with us from initial requirements (or lack theoreof), designs, implementation choices, and deployment issues, and all the lessons learned along the way. The talk will examine some of the most interesting features of the site and show their implementation in the web layer, domain model, and DB. The audience should expect an educating and revealing presentation on how to transition from standard web development paradigms to modern tag-driven CMS approaches.

Rikstrygdeverket valgte, i 2001, J2EE med IBM som leverandør, som strategisk plattform for modernisering. Rikstrygdeverket er en stor organisasjon med et svært heterogent applikasjonmiljø og mange samtidige prosjekter av forskjellig størrelse og omfang. I tillegg er det mange forskjellige leverandører inne på forskjellige prosjekter. I Rikstrygdeverket har vært at det er mange prosjekter som kjører og mange leverandører som er inne og leverer disse prosjektene. En stor utfordring har vært å skape en effektiv og standardisert utviklingsarkitektur som understøtter både god kvalitet, standardisering, produktiv utvikling og ikke minst ensartet deployment og konfigurering. Foredraget vil se på hvordan Rikstrygdeverket har bygge et utviklingsmiljø og utviklingsarkitektur for å effektivisere utviklingen og supportere mange paralelle prosjekter i en stor og kompleks infrastruktur sammensatt av mange forskjellige applikasjoner. Dette for å sikkre kvalitet i leveranser og holde orden på versjoner av applikasjonene kjørende i de ulike miljøene.
- Introduksjon - Dagens situasjon - Utfordringer - Løsningen - Resultater og erfaringer - Videre arbeid og utfordringer - Oppsummering - Spørsmål Required experience: Kjent med Java/JEE Expected audience Utviklere Arkitekter

Systemutvikling med fokus på drift og vedlikehold blir ofte forsømt av mange i dag. Dette skjer ofte på grunn av press på tid og økonomi, men også fordi man benytter verktøy som ikke er laget eller er velegnet for en drifts- og vedlikeholdssituasjon. Foredraget vil peke på en del ting som kan gå feil og som man bør tenke på. Eksempler er hentet fra relle prosjekter. Målet er å belyse områder som mange ikke tenker på til daglig, men som man bør fokusere mer på fremover.
Introduksjon (5 min) bakgrunn og erfaringer Anders Bjørnestad Problemområdet, konsekvenser, eksempler (30 min) Feller og feil, tips og triks (10 min) hva bør man tenke på hva bør man se etter Oppsummering (5 min) Q&A / diskusjon

In year 2000 Telenor established a new middleware integration platform for it’s fixed-line service. At present this platform is running over 60 different java enterprise applications developed by teams distributed around the company and the world. The platform integrates with over 50 of Telenor’s back-end systems. To support the developer teams, a centralized platform team has created a common application architecture backed by a standardized development process, tools, guidelines and runtime platform. The name of this platform is Metro and it acts as a distributed middleware factory! In this talk we’ll share our experiences from this process and some secrets from the past 6 years!
Outline of "(Evolution of a) Distributed Middleware Factory" What is a Distributed Middleware Factory? Epochs in Metro history Epoch 0 - Medieval Age - Kings and Kingdoms - Technologies Epoch 1 - Gunpowder Age - Distributed development model - Distributed vs. centralized model - Technology at the base - Layered architecture - Informal roles - Test Environments - Statistics Epoch 2 - Enlightenment - The 80/20 rule - Boiling soup on stone - Metro Roadmap - Roadmap in Jira Epoch 3 - Industrial Age - Documenting standards - We use Open Source - Leading Star Example - Automation through 3th party tools - Automation through self-made tools - Metro Certification - Certification benefits - Certification content Epoch 4 - Modern Age - Commercialization - Service Level Agreements - Code Quality - Continous Architecture Review - Application Monitoring - Automatic configuration, deployment and environment setup Key tools Key lessons Questions? Required experience: Knowledge of Java enterprise development and platforms, interest for project and platform management Expected audience: Project leads and developers involved in large development and distributed environments, looking for a sound development methodology Expected audience: Project leads and developers involved in large development and distributed environments, looking for a sound development methodology

Agile principles state that architecture should evolve in an incremental manner, continually adjusting to the requirements at hand. There is no room for Big Design Up Front, the traditional way of designing architecture top-down. So, is there room for an agile architect? This session adresses the role of the architect in agile development projects. As architects in a large project that has introduced agile methods in a previously waterfall-oriented organization, the speakers have struggled with finding the role of architecture in an agile project. It has been a journey from a world where the architect is a godlike superbeing ruling developers with an iron fist to a world where the challenge is finding out how to humbly help the developers do their job. We will talk about the biggest challenges, success stories and experiences - what we did, and what we wish we had done.

In my years as a developer and an architect, I have found that there are many tricks that can boost my productivity and value considerably. Some of these tricks are written down in various books, many are not. The talk aims to give beginners through intermediate developers ideas about how to improve the way they work. The talk covers aspects from writing better code, to writing better emails. The talk will be light and easy, with only an occasional dive into quantum mechanics (or maybe not)
Intro: Are you a coder or a developer? (5 minutes) Thinking better (10 minutes) Asking the right question Effective planning Talking better (10 minutes) Writing better emails and documents Agreement through conflict Coding better (15 minutes) Shortening the feedback loop Idiomatic programming Getting better (10 minutes) How much time to spend learning? When are you done learning?

The main goal of Domain Driven Design (DDD) is to make the system design to reflect and model the reality. However, faced with an already existing system that does not honor this, it might be hard to know where to start. A transition to DDD might then be percevied as a change to make, even considered the values it might add. The technique of domainlogical value-objects is a method for domain-driven programming that stays close to the code. The major advantage is that takes no immediate changes of the structural level of the code, but can be applied with a very small initial effort. In that way, it is possible to very fast start reaping some of the fruits of the domain driven approach, e g more structured in-data validation, more expressive service-APIs and clearer code in the buisiness logic (often EJBs or similar). I this session we present domain-logical value objects, and how you write and use them in practice. The concrete code examples are in Java, but the idéas and techiques can just as well be applied to code written in C++/C, VB or Ruby. The session is based on the speaker´s expericence of improving already-developed code and systems.
(5 min) Introduction/ Mindset / Domain Driven Design Fundamental ideas When a good idea or not (5 min) Green-field projects vs. existing code-base The challenges of a poor-quality code-base (10 min) Introducing DLVO through some examples Established Value objects (Integer, String etc) Standard general purpose domain value objects (e.g. Date (hmm...) and Currency) User-defined DLVOs (5 min) DLVO effect on in-data validation/error handling (5 min) DLVO effect on service API clarity (extensibility of client tiers) (5 min) DLVO effect on business-logic tier code (extensibility of application tier) (5 min) DLVO effect on testability (5 min) How to identify candidates for DLVO (5 min) Next step - taking the methodology further Composed domain logical value objects Habitat of more advanced computations

Presentasjonen er en erfaringsutblåsning fra STAY, BBS sitt store omleggingsprosjekt, der stormaskin/COBOL fases ut til fordel for UNIX/Java. Som mange andre av dagens programvareprosjekter har STAY hentet inspirasjon fra metodikker som Extreme Programming (XP), Test-Driven Development (TDD) og Domain-Driven Design (DDD). Målet ved prosjektstart var å følge prinsipper som korte iterasjoner med påfølgende release, delt kodeeierskap, automatiserte tester med mer.
Presentasjonen er en erfaringsutblåsning fra STAY, BBS sitt store omleggingsprosjekt, der stormaskin/COBOL fases ut til fordel for UNIX/Java. Som mange andre av dagens programvareprosjekter har STAY hentet inspirasjon fra metodikker som Extreme Programming (XP), Test-Driven Development (TDD) og Domain-Driven Design (DDD). Målet ved prosjektstart var å følge prinsipper som korte iterasjoner med påfølgende release, delt kodeeierskap, automatiserte tester med mer. Men det er ikke bestandig like enkelt med teori og praksis når man skalerer opp et prosjekt fra noen få, til flere titalls utviklere? Hvilke prinsipper kan man lempe litt på og hvilke er det viktig å holde på? For eksempel: Hvor viktig er det egentlig med delt kodeeierskap? Hvor langt skal man gå når det gjelder automatiserte tester? Skaper ”Continuous Integration” (CI) mer trøbbel enn nytte? Presentasjonen drøfter forskjellige ”grep” som er tatt for å holde på en del prinsipper? Hvilke prinsipper er nedprioritert? Og hvilke konsekvenser har det fått?

Over the last few years, anyone involved in software development probably (or at least should) have been reminded on numerous occasions of the importance of testing, TDD, test-first, coverage, automated integration testing, etc. It is widely accepted that focus on testing and test driven development increases software quality on many different levels. One could even say that if you don't have a firm grasp of testing, you're probably in the wrong business. However testing often proves more difficult than the standard "bowling pin score card" example would make you believe. Some real life scenarios prove hard and time-consuming to test, and over time tests can prove fragile and cause problems when refactoring or doing even minor changes, especially when the code base grows large. The problems we see are often related to: - External dependencies/extended use of mocking - Tests that rely heavily on resources, environment variables, properties etc. - Unit-testing integrations - Bad, ugly and undocumented test code - Poor test code structure Through real-life examples we aim to demonstrate how and why some of these problems occur, and outline techniques and patterns to help avoid them. This talk will stop hair loss due to pulling your hair out in frustration by showing you how to reap all the test benefits the evangelists have told you about.
Introduction(5 minutes) Intention of talk -What do we want to achieve through testing? Problem/Solution(35 minutes) Show by examples: - Common problems - Why they occur - What they will lead to - How to avoid them Conclusion(10 minutes) Conclude with some basic rules / patterns to follow. –How to achieve through testing. Q&A(10 minutes) Try to get some discussion going. Information Required experience: Some experience with software development and (unit-)testing Expected audience: Everyone. Main benefit will be a better understanding of the importance of test quality, and how to achieve it.

Studier fra andre fagfelt viser gang på gang at enkle matematiske modeller som oftest har langt mer nøyaktige estimater enn eksperter. Selv modeller av ekspertvurderinger fungerer stort sett bedre enn ekspertene de modellerer.Resultater fra studier innen estimering av software utvikling er ikke like entydige.
Professor Magne Jørgensen og Stein Grimstad oppsummerer studier som sammenligner estimeringsmodeller (COCOMO, Use Case Points, etc) og ekspert-estimering, og viser i hvilke situasjoner det lønner seg å stole på ekspertene, når vi bør basere estimatene på modeller, og når det kan lønne seg å kombinere estimater fra eksperter og modeller. De vil også oppsummere arbeid på hvordan man finner fram til de beste estimeringseskpertene.

Agile development is a phrase that it appears no buzzword-compliant software development project can be without. However, it is a proper understanding of the motivation and practices, rather than the buzzword conformance, that makes the actual difference in development.
The notion of agility has differing (mis)interpretations and (ab)use. Sometimes it is used as a synonym for Extreme Programming. By contrast, other people use it to mean a generic notion of something that is not quite Extreme Programming, but may borrow ideas from it. Some developers may label a project agile just based on the occasional use of JUnit. Others may use the label to justify not writing any documentation or to avoid agreeing on scope or delivery dates. To be fair, not all uses of the term are cynical or misguided, but the term has lost some of its potency through dilution. This session revisits the motivation for agile development, and goes on to explore the wide-range of perspectives that are encompassed by approaches that can claim to be agile, including both technical and non-technical aspects, in the large and in the small. The six faces of agility presented are the practices, organisation, architecture, tools, skill and attitude. And, like a cube, it is all too easy to focus on a couple of the faces without seeing the rest. Audience: Developers and managers, all levels

Prominent enterprises have lost their competitive advantage due to poor quality development practices. Most enterprises have core, infrastructure, and legacy systems. These core systems are an integral part of most new functionality. These core systems all have similar characteristics: they are fragile, have inadequate testing frameworks, and there are only a few developers left that know how to maintain and enhance them.
How did these core systems get into this condition? The enterprises built this problem into them, release by release. The engineering reasons have been exposed by Agile processes. As releases are built iteratively, each increment makes transparent the underlying quality problems that lead to these design and quality dead core systems. As we have tried to fix these quality problems, the underlying roots in dysfunctional customer-developer relationships that cause the poor quality have been exposed. We will discuss what enterprises can do to fix this quality problem and restore competitive advantage, and how hard it is to do so.

Planning Poker is an agile technique for combining user-story and task estimates of different experts, Empirical research has found that combining the opinions of different experts is a cost-effective way of increasing estimation accuracy. In addition, Planning Poker can ease planning, increase team commitment and reduce the risk of miscommunication. This talk will teach you how Planning Poker works, why it works, and when it does not work. The talk not only explores a technique, but also tries to explain underlying psychological aspects related to the behaviour of groups. Finally, variations you may consider when introducing Planning Poker at your project are discussed, as well as alternatives to Planning Poker.
(5 min) The crowd: mad or wise? (10 min) How does planning poker work? (10 min) Why does planning poker work? (5 min) When does planning poker not work? (5 min) Variations of Planning Poker : (10 min) o Estimating story points vs. ideal days o Fixed vs. flexible estimates o Consensus vs. average Alternatives to planning poker (5 min) Q&A (10 min) Full abstract Empirical research has found that combining the opinions of different experts is a cost-effective way of increasing estimation accuracy. However, the main challenge for software professionals is often when, and how, to combine expert opinion. At what stage in the process? Which experts should be involved? How many experts? How much formalism is sensible to use? Group processes is one of the most studied aspects of psychology, and “The crowd” as groups frequently is called, has both been labelled as mad and hailed as wise in various bestselling books. Group processes have a high relevance for software projects, especially concerning estimating and planning. Regrettably, due to misinterpretation of psychological research, a common misconception in software engineering textbooks has been that groups are “mad”, and that formal procedures are required in group estimation. However, recent research papers and textbooks in software engineering challenge this view, and indicate that a straight-forward combination of expert estimates through group discussion may increase estimation accuracy. Planning Poker is an agile technique for combining user-story and task estimates of different experts. It is an easy to use method that employs a semi-structured group discussion process with minimal formalism and overhead. In our experience, Planning Poker is an effective method for increasing estimation accuracy. It also eases the planning of projects, increases team commitment and reduces the risk for miscommunication. This talk will teach you how Planning Poker works, why it works, and when it does not work. The talk not only explores a technique, but also tries to explain underlying psychological aspects related to the behaviour of groups. Finally, variations you may consider when introducing Planning Poker at your project are discussed, as well as alternatives to Planning Poker. Required experience: Participants should have experience with estimating software tasks, but as the talk has a mainly psychological perspective, it is equally suited for all levels of software expertise. Expected audience: Developers, Project Managers, Project owners, Business strategists and Process Improvement Specialist

Lean thinking has had a dramatic effect on industries from manufacturing to banking to hospitals. In software development, lean principles lead us inevitably to agile software development – and beyond. Lean is not just about iterative development, it is about transforming customer needs into deployed software rapidly, reliably, and repeatedly. Lean is not about slowing down and being careful, it’s about catching errors the moment they occur so that you can reliably go fast. And finally, lean is about taking a look at the amount of work you have piled up in lists and queues – with an eye to getting rid of the queues entirely. This presentation deals with aspects of lean that you might not have thought about while implementing agile software development practices. It will challenge development teams to think differently about the way they approach their work.
Principles of Lean Just-in-Time – What does this mean in software development? Stop-the-Line – How does this actually work? Whole Team, Complete Product What is a value stream? What is a team? Go Fast Why Quality, Speed, and Low Cost go together How Queuing Theory works in software development

Business owners across the world are investing more and more in Business Intelligence (BI) solutions. It is the #1 or #2 IT spending priority in many companies. Business Intelligence realizes the promise of IT: that information systems will help businesses run better. This presentation is designed for technologists and technology managers who wish to learn more about the role of BI within an IT department, what the different components of an abstraction architecture consist of, and what open source technologies can be used to implement these components. The architecture is explained using a case study based on the need for regional hospital systems to: Realize emerging trends and patterns dynamically within and cross hospital systems Establish and evaluate trending thresholds Proactively notify appropriate resources when thresholds are crossed Provide data and information for advanced ad-hoc analysis Integrate multiple, disparate source systems with minimal coding or overhead Provide for "Enterprise transactions" that exist beyond a single transactional system This case study is based on a system designed by the author for the Vanderbilt University Medical Center to track SARS and Avian Flu pandemics.

Følelser. Brukere. Opplevelser. 50 millisekunder! Noen mener at dette er tiden en portal har til å fange en brukers oppmerksomhet. Vise seg fra sin beste side. Ihvertfall hvis det er snakk om eksterne brukere. Verdens vakreste tekniske løsning forblir den "stygge andungen" om ikke presentasjonslaget og brukeropplevelsen tas minst like seriøst som programmeringsteknikker og integrasjonsrammeverk. Kampen om oppmerksomhet gjelder ikke bare overfor brukerne, men også overfor portalens sponsorer og eiere - de som skal realisere sin konkurransekraft gjennom f.eks. en virksomhetsportal. Å forankre et slikt strategisk viktig IT-prosjekt hos ledelsen og andre sentrale ressurspersoner er en stor utfordring, men også en betydelig suksessfaktor. Foredraget tar for seg temaene brukeropplevelse, forretningsmessig nytteverdi og forankring. - med trender og eksempler. Det legger vekt på de ikke-tekniske sidene ved en virksomhetsportal, og betydningen av disse.
Portalens fallgruver/suksessfaktorer: Brukeropplevelse, nytteverdi og forankring - intro (5 minutter) 50 millisekunder (5 minutter) Hva er det som gir et godt førsteinntrykk? (15 minutter) Hvordan det virkelig er og hvordan det oppfattes at det er (5 minutter) Hvordan få dette til? (5 minutter) Forretningsmessig nytteverdi (5 minutter) Strategisk rammeverk, viktige veivalg (10 minutter) Forankring - opp, ned og til siden (5 minutter) Trender (5 minutter) Oppsummering

So you thought you'd seen it all? Come to this session to see some truly remarkable demonstrations of Java in action in ways you'd probably never thought of. We'll have some cool Java powered hardware being used to control a range of devices and applications in the most unusual ways. Want to know more? Come to the session and find out!

Traditional requirements written as text documents - such as use cases or requirement specifications - is an inefficient way to communicate functionality. Each developer has to interpret the text, details are omitted and the descriptions are frequently not maintained and kept up to date. These documents are essentially redundant; they mirror the executable application and the tests, and you have to keep tests, requirements and the application in sync manually. Example-Driven, executable specifications offers a more flexible and effective alternative by using User Stories and Fit tables to bring requirements and tests together in a document that both specify the desired behaviour of the application, and can be executed at any time to assess whether a feature is implemented and working. This BOF session provides a walkthrough of the process of writing and maintaining executable specifications, using tools such as FIT and FitNesse. We will also look briefly at WebUI specifications with tools such as Watir and Selenium. The session will be open to a large degree of questions and interaction from the audience. The speakers have been using these techniques on projects for the past 2-3 years, and will give concrete advice using real-life scenarios.

Forskerne fra Simula vil i denne sesjonen demonstrere hvordan du i praksis kan forbedre dine estimater og redusere sannsynligheten for overoptimisme og uønsket påvirkning. Store deler av sesjonen er interaktiv og avsluttes med et uformelt Norgesmesterskap i estimering hvor de som kommer på seierspallen kan glede seg over gavekort fra en av byens bedre restauranter.

Join this FishBowl to examine the 4-level categorization model for services and how these guide a Service Oriented Integration Strategy. We'll discuss the concept of a service, it's responsibilities and contracts and dive into the real world challenges for such a strategy. Keep your sugar and caffeine levels high for this one folks!

There has been a lot of "hype" around MDA the last two years, but is it really ready for serious business? Does MDA deliver when it comes to portability, interoperability and productivity? This talk will report on the current status of MDA and MDA tools from a real case in the company WesternGeco. The UML-tool will be TogetherArchitect-2006 and the examples will demonstrate the use of UML-models, UML-profiles and Model transformations to generated code. The model transformation tool is an open source tool called MOFScript developed by SINTEF as part of the ModelWare EU-project. It is available as an Eclipse plugin. The presentation will show how you can use UML-models and transformation-scripts to customize code-generation for your application architecture.
Required experience: Some knowledge of UML and MDA Expected audience: Anyone interested in improving quality and productivity through automation and code-generation.

The Norwegian Ministry of Justice and the Police have worked with a SOA strategy on an Enterprise Architecture level for 3 years. We are now in the middle of the first project (Schengen Information System II) implementing SOA and its principles. This presentation will show lessons learned when applying Enterprise Architecture and SOA principles in the project. Best practices from the developers point of view (J2EE developer and Service developers) will be discussed.
- About The Norwegian Ministry of Justice and the Police and the project Schengen Information System - Requirements from Ministry of Justice Enterprise Architecture - Experience implementing a SOA Methodology - Reference architecture - Purpose - Best practices - Service categorizations - Architecture - How things fit together (J2EE, ESB, BPEL, UDDI, Web Service Manager) - From J2EE developer point of view - High availability - Security - How to achieve a good governance process?

This experience report aims to demonstrate how Gjensidige Forsikring, a major Norwegian insurance company, introduced agile methodologies and tools to improve the software development process. The talk will provide experiences from using an environment for automated testing and continuous integration. The tools used were junit, jmock, fitnesse, maven2 and anthill pro. In addition, we will describe the challenges we faced when moving to this new infrastructure.
Introduction (5 minutes): - Identifying improvement opportunities in existing development process Standardised builds using maven 2 (15 minutes): - Demonstration Automated testing (10 minutes) - Demonstration Continuous integration (10 minutes): Migration process (10 minutes): - How to move to a new development infrastructure - Issues Q & A (10 minutes) Required experience: Basic knowledge of the java language and java build environments is required Expected audience: Experienced software developers and architects wanting to improve their software development process using agile methodologies and tools.

How do you really set-up and run an agile project? At Amazon.com you can by hundreds of books focusing on agile software development in one way or another. You can attend seminars and conferences home or abroad. This is a great way to get a theoretical foundation, but once you get started, practical challenges and questions start popping up. This session provides insight in how agile software development principles were applied to a 6 month project involving a 10 person development team. The objective is to leave you with practical solutions you can apply to your own project tomorrow, with regards to planning and tracking releases and iterations as well as continuously improving the process. Simplicity and visibility is the key. Plain tools like index-cards, whiteboards and a huge LCD screen can give the team and other stakeholders total control at any time.
Introduction – to give you some backgrond (5 min) Scope management in a changing environment – a good story makes the difference (10 min) Release planning and tracking – how velocity can tell you when you are done (10 min) Iteration planning and tracking – a practical approach using index-cards and white-boards (10 min) Continuous integration and automated testing using Selenium – instant feedback on quality, coverage and doneness using a huge LCD (10 min) Iteration retrospectives and corrective actions – if it's broken, fix it - now! (10 min) Wrap-up and Q&A (5 min) Required experience: Experience from software development in general and a good understanding of the underlying principles of agile software development Expected audience: Anyone who are in the process of adapting agile software development

There are many aspects of testing web applications that makes it far from enjoyable to say the least. In this session we will present and demonstrate CubicTest, an open source Eclipse plugin that tries to make web tests easier to write, maintain and run for technical as well as non-technical users. CubicTest uses a graphical user interface to let users model tests instead of writing test scripts. The tool focuses on enabling test driven development of web applications, but also supports testing of existing web applications. The goal is to make it possible to replace a detailed requirements specification and manual test scripts with tests written in CubicTest. There are features in CubicTest that makes it quite unique. It has support for testing with a set of changing parameters and to use internationalization to run the same test against the same web site with different input parameters and languages. CubicTest can create a mock-up (HTML skeleton) of the modeled web application based on the tests, with e.g. forms and site navigation present. CubicTest also has an intuitive way to model tests for sites using Ajax technology. Hierarchical test composition is also supported to make it possible to hide test details behind abstractions, which makes it easier to read and write larger test sets. Tests can be exported to other test frameworks (e.g. Watir and the CubicUnit test framework). CubicTest is an open source project at http://cubictest.sourceforge.net and distributed under the GNU General Public License v.2. The tool is still under development, but a 1.0 release is planned for Q3 2006.
1.Background (5 min) 1.Agile software development 2.Existing web test frameworks - too low level 3.Involving the customer in creating and maintaining web requirements tests 2.CubicTest (5 min) 1.A tool for customers and developers 2.Eclipse plugin, model tests (GUI) 3.Test-driven focus 3.Demo (30 min) 1.Make tests for a demo web site 2.Test orchestration, parameterization, export and web mock-up 4.Future (5-10 min) 1.Our newest ideas

Fri programvare får stadig økt aksept og utbredelse. Dette gir nye muligheter for utradisjonelle forretningsmodeller i konsulentbransjen. Disse mulighetene er både økonomiske, organisatoriske og ikke minst markedsutvidende. Eller med ordene til politisk rådgiver Jørund Leknes i Fornyingsdepartementet, til Linux1.no, 2006-03-30: «Fri programvare baserer seg på nye samarbeidsformer og forretningsmodeller som kan gi viktig stimulans for utviklingen av norsk kompetanse og næringsvirksomhet på IT-området.» I BOF-sesjonen presenteres ulike forretningsmodeller for utvikling av fri programvare. Alternative modeller diskuteres og eksemplifiseres med prosjekter og pågående initiativer. Stafettbasert modell innebærer at ulike interessenter bidrar med sine krav og tilhørende finansiering til hver sine utviklingsfaser av en løsning. I dugnadsbasert modell samarbeider flere interessenter om krav og finansiering innenfor samme fase. Med donasjonsbasert modell er gjerne utviklerne initiativtakere og søker bidrag fra allmenheten eller større pengesekker. Eksempler som presenteres: Unified Consulting AS har utviklet en kompetanseportal for kommunenorge, med utgangspunkt i Kongsberg-regionens kommuner. Den GPL-lisensierte portalen er basert på stafettfinansiert utvikling med dugnad underveis. Prosjektets to første faser er finansiert av kommuner i Buskerud og Telemark, samt leverandør Unified Consulting. For tredje fase pågår en dialog med flere interessenter om finansiering. Ekstra-funksjonalitet til CMS-løsningen eZ publish for sammenligning av innhold (Content diff), ble utviklet i vår. Finansieringen var en dugnad mellom tre kunder og to partnere av eZ systems. Content diff ble sluppet i vår (eZ publish 3.8). Norske eZ systems er i ferd med å etablere initiativet eZ Open Funding for å koordinere og hjelpe konstellasjoner av interessenter for finansiering av programvareutvikling. Eksemplene drøftes i lys av utfordringene og forutsetningene de ulike modellene gir. Foredraget vil i utgangspunktet ta for seg bestemte eksempelprosjekter, men dersom publikum har relevant prosjekterfaring, er det åpning for å presentere / diskutere disse på bekostning av planlagte prosjekteksempler.
Introduksjon til foredraget og foredragsholder/firma. (2 min) Presentasjon av ulike forretningsmodeller for programvareutvikling. (15 min) Modeller / varianter (Stafettbasert, dugnadsbasert, terskelfinansiering, open funding, ++) Muligheter (Nye markeder, oppdragsgiver-økonomi, leverandør-lås, samfunnsøkonomi, ++) Utfordringer (Styring, tillit, vedlikehold) Koblingen til fri programvare Prosjekteksempel med stafettbasert utvikling (6 min) Erfaringer fra prosjekt i Kongsbergregionen Styrker / utfordringer Prosjekteksempel med dugnadsbasert utvikling (6 min) Erfaring fra utvikling av Content diff til eZ publish Styrker / utfordringer Hvordan etablere spleiselag. (6 min) Fødselshjelperen "eZ Open Funding" Styrker / utfordringer Sammendrag / diskusjon (4 min) Spørsmål / svar / kommentarer fra salen (10 min) Lengde / Duration: ca 40 minutter + spørsmål og innspill fra publikum. Forkunnskapskrav / Required experience: Ingen forkunnskaper kreves. Det er allikevel en fordel å kjenne sentrale begreper innen fri programvare (GPL, fri programvare, åpen kildekode, navn på kjente åpen kildekode-prosjekter) Målgruppe / Expected audience Målgruppen er alle med interesse for fri programvare, enten interessen gjelder utvikling eller rent forretningsmessige aspekter. Foredraget vil gi deg en gjennomgang av muligheter og utfordringer med ulike typer finansering av fri programvare. Temaet belyses med eksempler.

Modeller gir et høyt abstraksjonsnivå for utvikling og man kan se knytning til forretningsprossser. Modeller gir god oversikt og bidrar til problemorientert løsning og gjør det mulig å skjule implementasjonsdetaljer. Komplekse systemer vil ha stor hjelp av kodegeneratorer for å ivareta ønsket arkitektur og korrekthet. Samtidig kan man oppnå høyere produktivitet, bedre kvalitet og uavhengighet til målmiljø. I foredraget lages et kjørende system med arkitektur fra et virkelig eksempel der man vedlikeholder modell, ikke kode og er uavhengig av kjøremiljø.
Kort om Esito (3 min) Visjon Modelldrevet utvikling (7 min) Motivasjon Modelldrevet eller MDA Erfaringer Modelldrevet utvikling med Genova (15 min) Historikk Verktøyarkitektur Forklaring av modellene Fra modell til modell Hendelser og tjenester Templates og kodegenerator (10 min) Ulike målmiljø, fokus på java Fra modell til implementasjon Applikasjonsarkitektur Lag din egen template Referanseprosjekt (5 min) Erfaringer fra et stort pågående prosjekt Kort demo (10 min) Eksempel forklart med modellene Generering av javakode Kjøre generert applikasjon

GlassFish is a recent and active open source community which has delivered a production-ready Java EE 5 compliant application server in May 2006. Although missing clustering capabilities, this first version is used in production by several demanding web sites and applications. Grizzly (nio web framework), web services, documentation, administration, and monitoring tools are some of its key features. Also, full Java EE 5 support means you can use features such EJB 3 and JPA (Java Persistence API), the new JAX-WS 2.x Web Services stack and JSF (JavaServer Faces) 1.2 MVC framework. This session will focus on Version 2 of GlassFish (due to be released in the Fall of 2007) and will cover clustering, OpenESB (a JBI implementation) integration and the new Web Services stack called Metro (JAX-WS and WSIT, aka "project Tango" combined) for secure, transactionnal, asynchonous, and reliable Web Services. Performance and ease-of-use features are also key features in this release. Some of these features will be demoed during the talk including IDE integration. Open Source clearly isn't about good enough and the GlassFish community believes that there's still plenty of room for innovation at the application server level. So this session provides technical details on the preview of GlassFish v3 (modular HK2 architecture, startup time). Finally, the presentation will touch on the GlassFish community from users to partners.
This is a 1-hour technical overview for a developer audience which includes /several short but live demonstrations/.

The Java Posse is a popular weekly podcast with news and interviews related to the Java technology world. In this session, you meet the four hosts of the show as they record a situation report from the JavaZone conference.

Etter mange år med utvikling av enterprise-applikasjoner med JEE (Java Enterprise Edition) har utviklere blitt mer kritiske til hva man faktisk trenger av pakken. I dette foredraget vil jeg gjennomgå fordeler og ulemper med den komplette pakken man får av JEE. Jeg vil også gjennomgå hvilke krav en enterpriseapplikasjon vanligvis faktisk har. Gjennom hele foredraget vil jeg vise hvordan man kan bruke JSE og nyttige påbygg for å levere applikasjoner som oppfyller alle drifts- og forettningskrav, men som ikke går i veien for utvikleren. Jeg vil vise at ved å lage selvstendige applikasjoner som er uavhengig av en stor applikasjonstjener, kan man få et billigere produkt med færre feil. Med min erfaring som konsulent på Maven-relaterte oppgaver så har jeg sett hvilke hindringer JEE-applikasjonstjenere legger i utvikling og utrulling av ellers enkle applikasjoner. Jeg vil i dette foredraget vise en oversikt over problemene og komme med konkrete metoder man kan bruke for å lette hverdagen til utviklerene, arkitektene og drifterene.
Introduksjon Hvorfor er Java EE så vanskelig å bruke? Lange turer mellom skriving og kjøring av kode Utrulling og produksjonssetting, hvorfor er det så vanskelig? Miljøforskjeller mellom utviklerens maskin og miljø til produksjonsmiljøet Hvordan løser man disse problemstillingene med JEE Hvordan løser man disse problemstillingene med JSE Hvilke problemer kan Java SE ikke løse Oversikt og arkitekturer som illustrerere løsningene Bruk av embedding som et alternativ til å kjøre applikasjonene i en applikasjonstjener Oppsummering: Praktiske erfaringer ved å ikke bruke appservere Hvor passer det og hvor passer det ikke Påkrevd forkunnskap Krever kjennskap til Java SE og grunnleggende forståelse for de problemene som JEE prøver å løse. Forventede deltagere: Utviklere og arkitekter som er interessert i en enklere og mere feilfri hverdag.

The designated Sun Executive will deliver a keynote address illuminating key issues impacting the software industry. They will provide the vision and strategy for developers to collaborate by leveraging communities, technologies, and products in the current fast paced environment of software innovation, while highlighting key Sun technologies that facilitate this process This session will provide technically and visually compelling demonstrations that illuminate Sun's key technologies and platforms. Each demo will be displayed via rapid interaction and visual presentations that identify and highlight the Java and Solaris platforms, technologies and tools used to create build and deploy a series of impressive demos. The demos will be delivered in such a manner to show how Sun's technologies can easily be deployed using comprehensive wireless, desktop, bleeding edge and enterprise applications. The goal and objective being to show in easy rapid succession the use of Sun's technologies in innovative and progressively more challenging applied solutions.
The session will start with a three-dimension representation of a virtual workplace that allows remote interaction and collaboration. The second demo will use Java ME and Sun SPOTS demonstrating the ability of robots communicating and interaction in an environment . Then a visually compelling demo will incorporate several key Sun technologies that create an environment that enable various devices reacting to sensors and external stimuli.

This will be a live demo of a financial services grid using GigaSpaces as the grid provider, this will be very similar to a large customer's set up (detailed above). We will put through several thousand SWIFT messages and demonstrate dynamic scalability, Spring abstraction and resilience through the grid while converting them into ISO-20022 message. If we get time we'll do a more eye-pleasing demo (using the same set up) but calculating Mandelbrot fractals. We will go on to talk about just how fast the same set up works using Azul. We will use several laptops for the demos.

Mule is the leading open source ESB and integration framework. It's focus has always been on the developer with the aim of simplifying the difficult task of implementing an integration or SOA project. The focus Mule 2.0 is to make things even easier, more powerful even more robust. This talk will pivot on some of the new features of Mule. - New Xml configuration. Xml editor and developer friendly - no more class names! - The new extensible configuration model - Enhancements to the Mule runtime environment - How mule works with BPM and where BPEL fits in - OSGi support, For dynamic component loading and hot deployment - Data Streaming support Ross will also discuss the Mule roadmap for 2007/2008 including new arrivals in the Mule ecosystem and some a couple of Mule Customer case studies.

This talk will consider some challenges when implementing a high performance, server application in Java and our responses to them. While implementing the application in Java 5, we have found three major areas where libraries/JVM provided insufficient support. First: Thread control – how to make sure you application maintains control of those threads. Second – Interrupts, how to deal with them. Third: Garbage collection – how will it behave in production? We will give a compact introduction to each of the challenges before detailing our response to them. Hopefully you may be able to learn from our actions.

Garbage collection is an invisible but extremely helpful part of the Java language. Investing a bit of effort in understanding garbage collection can yield big benefits in terms of application throughput and responsiveness, but care must be taken. It is common to try and improve application responsiveness by tuning the garbage collector to shorten garbage collection pauses. However, short pauses alone do not guarantee good application response times. Judging whether an application is performing well or poorly on the basis of pause times alone is dangerous, because big pause times often go along with great application performance. Even the total amount of time spent paused for garbage collection is not a good predictor of the impact of garbage collection on application performance. Although garbage collection is often treated as a performance cost, garbage collection can actually outperform manual memory management. Verbose garbage collection logs contain lots of information but it's not always obvious what it means or how to use it. Verbose gc can guide gc tuning decisions and also give insight into application behaviour. Verbose gc can help diagnose application response time problems, detect memory leaks and spotlight pathological patterns of object creation. I will demonstrate using verbose gc analysis tools to quickly find memory leaks, choose the best heap size, and choose the garbage collection policy which makes an application go fastest.

Java integrated development environments (IDEs) have offered unparalleled productivity tools for developers. Refactoring, code completion, and static code analysis are all made possible by the Java programming language's static typing system. Dynamic languages, on the other hand, have traditionally left much to be desired in the tools department. Their proponents have argued that tools are not as necessary, because there is less code to write, and that unit tests can replace static checking. With dynamic languages such as Ruby being hosted on the Java platform, new efforts have been made to bring the features of Java IDEs to the dynamic language world. The results are promising: as a dynamic language developer, you can have your cake and eat it too. This technical session covers recent developments for Ruby in the NetBeans IDE and discusses future directions for research in this area, such as direct and statistical type inference, wide-ranging refactoring support, more-accurate code completion, and multilanguage editing and debugging.

In this session we intend to demonstrate to the audience, using source code examples and live demos, how it is possible to develop rich, snappy, native-looking, desktop applications using the framework Qt Jambi. Qt Jambi is the Java version of the popular Qt C++ cross-platform framework, opening a world of possibilities for Java and C++ programmers alike. It is an officially supported technology aimed at Java programmers who want to create great-looking GUI applications using a first-rate GUI framework. The Qt C++ framework has been at the heart of commercial applications since 1995. Qt is used by companies and organizations as diverse as Adobe®, Boeing®, IBM®, Motorola®, NASA, Skype®, and by numerous smaller companies and organizations. Qt's classes are fully featured and provide consistent interfaces to assist learning, reduce developer workload, and increase programmer productivity. Qt also has a long history in the Open Source community, among other things as the foundation of the K Desktop Environment (KDE). In our presentation we will demonstrate Qt Designer by example and at the same time introduce Qt Jambi's signal and slot mechanism, layout management, and Qt Jambi's ability to customize user interface look using cascading stylesheets (CSS). We will also demonstrate some of basic of Qt's model view framework. Qt Designer is a WYSIWYG tool for graphically designing user interfaces. Qt Designer can be used purely for GUI design, or to create entire applications with its support for integration with popular integrated development environments (IDEs), like Eclipse. Using Qt Designer for our examples, we will see how Qt Jambi's layout management and signals and slots works. Signals and Slots are Qt Jambi's object communication mechanism, gluing components together in a simpler manner than traditional listener interfaces. Attendees to this presentation are expected to gain insight a new way of developing desktop applications using Java. Expected requirements from the audience is a basic knowledge of the Java Programming Language and GUI development.

The talk is about how an ESB, and Mule in particular, can be utilized to create Mashups. Mashups and ESBs serve as catalysts for learning new technologies and thus stay in touch with the latest buzzwords (if that it a personal goal). The notion of Mashups fuels creative ideas and an ESB like Mule makes it easy to realize them. This talk promotes the idea that Mashups and Mule is a perfect match for learning the new techonologies. GeoMail is used throughout the talk and serves as an example that illustrates the road from an idea to a final Mashup. GeoMail retrieves the IP address of the originating sender of your incoming e-mails, resolves a geographic location from that IP-address using a public Web Service and plots the locations asynchrounously om GoogleMaps using a custom Mule Ajax Transport. The result is a live view of how widespread your mailinglist is or how international your contact list is. This talk will present how GeoMail is created and the choices that were made in order to stay buzzword-compliant.

Have you ever struggled to figure out why some part of your application runs slowly? Have you ever seen hard-to-reproduce OutOfMemoryErrors that shut down your application? What do you need to make profiling of a Java application easy? The answer is simple: powerful tools that are well integrated into your development environment. Recent advances in the JDK software have increased the power and flexibility of profiling tools for the Java platform. Further advances in integrated development environments (IDEs) have made profiling tools even easier and more convenient to use. Finding performance problems, threading issues, and memory leaks has never been easier. This session focuses on specific advances in the integration of powerful profiling tools into the NetBeans IDE and includes demonstrations that show specific use cases.
Outline 1. What sorts of problems can an integrated profiler help you solve? 2. The state of the art today: NetBeans Profiler version 5.5.1 3. Case Study: A memory leak in HttpUnit. 4. Upcoming enhancements to make things even easier: A preview of NetBeans Profiler 6.0. 5. Case Study: JRoller performance problems. Required experience Attendees are expected to understand the basics of performance and memory usage problems in Java applications. Expected audience Anyone who has experience with or wants to learn more about tracking down performance bottlenecks and memory leaks in Java applications.

OSGi is a mature and powerful dynamic module system for Java which recently has gained a lot of interest in the Java community. OSGi offers real modularization within a Java Virtual Machine, including dynamic updates of modules (or “bundles” in OSGi jargon), as well as a service oriented API for communication between the modules. A well known example of a rich client application based on OSGi is the Eclipse IDE. The Spring-OSGi project aims to make it easy to build Spring applications that run in an OSGi framework. Spring-OSGi achieves this by letting services, used for inter-bundle communication, be exported and referenced with methods familiar to Spring developers. This talk gives a brief introduction to OSGi and then continues on to show how Spring-OSGi may be used in order to modularize a rich client application written in Swing. The talk will include lessons learned from OSGi development, and solutions to problems typically encountered. The presentation will also show some practical steps you will need to go through in order to start using Spring-OSGi.
- Introduction to OSGi and Spring-OSGi (10 minutes) - Modularizing a Swing application using Spring-OSGi (30 minutes) - Lessons learned (10 minutes) - Q & A (10 minutes) Required Experience: Knowledge of J2SE, class loaders, Swing, the Spring container Expected Audience: Anyone considering OSGi as a platform for rich client development. Attendees will learn what OSGi is and how it may be applied in such a scenario.

The java.net project "Hundred Kilobytes Kernel" (HK2) is a module subsystem coupled with a simple yet powerful component model to build software. It is a great technology to use in any Java software development and can be used in small devices such as phones up to enterprise applications. HK2 is designed to be friendly to existing technologies such as OSGi but it will also provide a path to the implementation of modules (JSR 277) in Java SE 7. HK2 is used as the foundation for GlassFish V3.
Outline Introduction to component models, 2 min o OSGi o JSR 277 HK2 overview o Modules, 20 min + Modules - Module definition - Module packaging + The module subsystem - Instances - Unloading - Modules and classloaders + Repository + Registry o Components, 20 min + Services - The build system - Runtime - Instantiation - Life Cycle + Inversion of Control - Injection - Extraction - Instantiation cascading Live demonstration, 5 min How HK2 is used in GlassFish V3, 5 min Q & A, 10 min Required experience None Expected audience Architects and developers

There is a common misconception among many end-users, consumers, and developers that Ajax is the ultimate solution for the Web, and that it can provide all the same functionality as a rich desktop solution. Sure, Ajax can cover most of our expectations for a rich client, mimicking functionality provided by a desktop application, but there is still one area that has yet to be fully integrated - scalable server-initiated message delivery - Enterprise Comet. Comet is an advanced technique to enable real-time messaging from a Web server to one or more browsers, even if some of those browsers are behind a firewall or proxy server. Imagine being able to monitor any real-time data source from server statistics to your favorite stock portfolio, directly from your Web browser with no polling, no plugins and no pain! Grizzly enhances the Glassfish project with Comet support via Asynchronous Request Processing (ARP), addressing any server-side scalability concerns with Comet. The Dojo organization provides the Bayeux Protocol, used to coordinate shared access to the Comet notification channel coming from the server.
In this talk the presenters will discuss scalability, security, and performance implementing support for Enterprise Comet using GWT, Bayeux, Comet, and Grizzly.

The topic of this presentation is about innovative use of AOP in open-source Java grid computing framework that is trying to change the grid computing landscape in much the same way as Spring or JBoss have changed JEE landscape in the last couple of year – removing complexity, clutter and over-engineering of traditional computational grid solutions. The presentation will concentrate around live demonstration of writing a simple application like a HelloWorld and grid enabling it to run on a small grid right in front of the audience and with audience participation. Demonstration will be performed on Windows XP using Eclipse 3.2, Java 5 and GridGain framework (LGPL open-source Java grid computing framework available at www.gridgain.org). CDs will be made available before and during presentation for anybody who would like to become a part of ad-hoc grid during demonstration (simple 1-minute installation for Windows XP/Vista or Linux is required). All coding during demonstration will be done live. Detailed and in-depth explanations will highlight that grid computing in Java can be fun, simple and productive to use in everyday applications and systems. Special attention will be paid to the fact that grid computing can be used by businesses of any size: small, medium or large. Real-life examples will be discussed. Technical content of the presentation will focus on how AOP is used in this example to achieve transparent grid-enabling or grid-enabling without even touching a source code. It will also discuss during live demonstration some of the innovative features of GridGain such as peer-to-peer deployment and hot re-deployment, resource injection, unique support for split/aggregation and Spring/JBoss integration.
It’s important to note that 1/2 (30 minutes) of the entire presentation will be devoted to a live coding demonstration and slides only support introduction and conclusion parts of the presentation. Introduction o Nikita Ivanov o GridGain, www.gridgain.org o Live demonstration Why is Grid Computing? o Grid computing o Huge potential o However, compute grids today are o Leading to Why Java? Why AOP? o Grid enabling Java application = grid enabling a Java method call o Grid enabling is a cross-cutting concern o Transparent grid enabling o AOP in GridGain Live Demo o Windows XP, Eclipse 3.2, Java 5, GridGain 1.0 o Join the grid (DVDs are available) – Win32/Linux/Mac OS X are welcome! o We will take simple HelloWorld Java app o We will grid enable it using GridGain o We will run this example on the grid right from the Eclipse Conclusion o Grid app in less than 30 minutes from scratch o Transparent grid enabling o Transparent deployment o Grid logic is separated from business logic o Fun, simple and productive :-) Required Experience: Java 5 Basics of AOP Expected Audience: Audience is expected to include developers, architects and technical managers who are interested in grid computing technology that breaks away from traditional mold and makes Java grid computing fun, simple and productive to use. We are expecting this talk to be really interesting and popular among he attendees as it includes a live end-to-end demonstration of something that not so long ago would require weeks and months of just configuration and was part of only privileged projects in the government research and large corporate sectors.

Java SE 6 now has over four hundred command line options that can be specified for the Sun JVM. Understanding what these options are and how they affect the performance of an application is a daunting prospect. This session will look at the major areas of tuning for the Sun JVM: garbage collection, thread synchronisation and bytecode interpretation. We'll look at how the JVM works internally, and the affect that changing various parameters can have on the JVM and, consequently how this will impact your applications performance. We'll also briefly look at freely available tools that can be used to monitor and profile an application giving you greater insight into the things that can be changed to improve performance.
Expected audience: developers

Generics are the largest and most important change to the Java programming language since it was introduced. Although the fundamentals of generics are easy to absorb, misunderstandings persist and common use-cases are not well understood. For example, what is “migration compatibility,” and why is it central to the design of generics? What strategies do you have for migrating an existing library? What pitfalls need to be avoided when combining generics and arrays? What do wildcards really represent, and how should you use them? This session will use the ideas underlying generics to answer these and other common questions.
• Motivation for generics (5) o Cleaner code, stronger compile-time typing, more expressive interfaces Benefits of implementation by erasure: migration compatibility (15) o Migration strategies: surface generification, stubs, wrappers Problems with erasure (15) o Array typing vs generic typing, converting a collection to an array o Principle of Truth in Advertising , Principle of Indecent Exposure Wildcard types: what they are and how to use them (10) What next for generics? (5) Experience: Participants should be familiar with the basic ideas of generics Audience: Practising programmers working or soon to work with Java 5 or Java 6

Many modern systems are riddled with performance issues. Proper performance testing helps ensure that problems with responsiveness and throughput are detected and corrected during development, before the system goes live. The presentation gives a practical overview of performance testing in an enterprise setting, and demonstrates how to utilize the popular open source tool JMeter for performance testing. The presentation also outlines some tactics on how to handle performance problems if they are found.
Background, speaker presentation (3 min) Definition of performance testing (3 min) Preparing for performance testing (8 min) Running the performance test (5 min) Tactics for handling performance problems (5 min) JMeter overview (3 min) Demo: Testing web applications with JMeter (5 min) Demo: Recording and parametrizing test scripts with JMeter (5 min) Demo: Distributed performance testing with JMeter (5 min) Demo: Testing web services with JMeter (5 min) Alternatives to JMeter (2 min) References (2 min) Questions and answers (10 min) Required experience: Participants should have some experience developing web applications or other enterprise systems with Java technology. Parts of the presentation are technology agnostic, and should be of interest to developers using other languages as well. Expected audience: Software architects, developers, and QA testers concerned about performance in enterprise systems.

Code testability has become the norm these days. Unit testing represents a good start towards testability, but sooner or later you will find out that more is needed. Test'N'Groove represents the happy marriage of the tools that will allow you to write more than unit tests and build trust in your code by creating functional, integration and even stress tests.
The session will walk you from the TestNG basics towards those most appreciated advanced features. Test'N'Groove through its Groovy nature will bring a breath of fresh air to your tests. Requirements: basic Groovy knowledge, Java knowledge

The jMaki framework is a client side JavaScript library that abstracts away the complexities of using various client side JavaScript widgets for Ajax and DHTML behaviors. It supports server side authoring in a variety of languages (including Java, PHP, Ruby, and server side JavaScript) and frameworks. Also available is optional tools support for NetBeans and Eclipse. This session will introduce jMaki to application developers, and demonstrate using jMaki to help you build the front end UI for your application, using a variety of technologies on the back end.
(1) Introduction (1.1) Setting the context (1-2 slides establishing how jMaki fits in to the Web 2.0 / Next Generation Web) (2) The Zen of jMaki (2.1) Overview (2.2) Key Features (2.3) Client Side Capabilities (2.4) Server Side Integration (2.5) The jMaki Value Proposition (3) Using jMaki With Server Side Languages (3.1) Brief demos of jMaki with server side PHP, Ruby, and Server Side Javascript (4) Using jMaki With Java Based Web Technologies (4.1) Using jMaki with JavaServer Faces (including Shale and Seam) (4.2) Using jMaki with Struts (version 1 and version 2) (4.3) Using jMaki with Other Frameworks (precise list TBD) (5) Summary Expected Audience: Attendees should have working knowledge of Java web technologies (including at least one server side web framework), a basic knowledge of client side JavaScript programming, and a basic understanding of how Ajax asynchronous interactions work. Attendees will leave with an understanding of how to use jMaki to simplify their client side UI development practices (no matter what server side technology they are comfortable with), and to expand the number of widget libraries that may comfortably used together, without having to learn new APIs and paradigms for each individual library.

One of the design patterns of SOA is to move control flow to an orchestration component which connects multiple reusable services into a composite application. The result in practice is that these orchestrations, often bpel processes, tend to be a mixture of business services which offer well-defined business value, and technical services which offer technical capabilities which are always required in IT solutions – for instance authorisation, logging, etc. What is required is an aspect-oriented approach where these technical services can be injected into a composite application. This allows a business process to concentrate on business functionality, remain understandable to business analysts, and most importantly, allow different aspects to be injected within a business process thereby removing the need need to have multiple versions of the same process depending on the governance contract it is expected to meet. This talk discusses and demonstrates how an aspect-oriented approach can be implemented for composite applications which are developed and deployed to OpenESB. OpenESB is an open source, ESB implementation based on the Java Business Integration (JBI) standard. It will show two design patterns for injecting patterns into composite applications. The Facade pattern allows the user to apply a chain of aspects that serve as a façade to a deployed provisioning service. The Weaving pattern allows the user to weave an existing application with chains of aspects between services within a Composite Application. OpenESB supports different types of aspects: - Technical aspects. For instance, authentication, authorisation, and caching. - Aspects which enforce enterprise integration patterns. For instance, scatter-gatherer, queueing, auto-reconnect, and prioritisaton. - Business aspects. For instance, chargeback, audit trail, and lease management. Finally the presentation looks at how version 2.0 of JBI will include standards support for service invocation interception and policy enforcement for improve aspect orientation
- SOA and Composite Applications: - Patterns for injecting aspects into a Composite Application - Aspects that can be injected into composite applications - Demo + Show how to implement Caching, Data Transformations using the Gateway approach + Show how to implement Caching, Data Transformations using the Weaving approach. - Improvements to version 2.0 of the Java -Business Integration standard for supporting Aspect-Oriented Composite Applications - Summary

Web service developers have generally been limited to two different development models, each with its own advantages and disadvantages. The "code-first" model provides a familiar environment and a flexible development process, but has historically suffered from impaired interoperability. The "contract-first" development model allows for elevated interoperability, but at the cost of a high entry barrier, a steep learning curve, and a heavy development process. In an effort to leverage the best of both worlds, Web service developers are increasingly adopting a "code-first, contract-aware" approach. The proposed presentation will attempt to sort out the complex issues that surface when establishing a flexible, reliable development model for interoperable Web services. The Enunciate project will be introduced as a possible solution to contract-aware Web service development. A concrete demonstration of contract-aware Web service development will be provided using Enunciate. A rich set of services and domain objects will be published as a fully-documented, interoperable web application that exposes its service endpoints via SOAP, REST-XML, and JSON. Client code for multiple platforms will also be generated and exercised to demonstrate the powerful interoperability features of the deployed application. The application will be much more than a simple "Hello, World" service, sporting complex objects, one-way operations, and MTOM binary attachments.
Web service development models Code-first development, advantages and disadvantages. Contract-first development, advantages and disadvantages. The best of both worlds: code-first, contract-aware. Enunciate and its "compiled contract" philosophy. Enunciate's features and goals. Compiled-contract development. Demo: Publishing Your Web Service API with Enunciate Q&A /ul>

The benefits of automated testing are many, and a lot of programmers and teams are doing test-driven development and extensive automated testing. Yet many struggle with maintaining their test suite, and end up in situations where every little change to the code breaks some tests. Often it is not clear why the change causes the tests to break, thus requiring the programmers to spend an annoying amount of time working out whether the tests are failing for a good reason or not. This talk looks into the issue by identifying a number of test smells that contribute to this problem, and suggests some patterns and strategies that will improve the current state of practise.
 

This session discusses advanced painting techniques in Swing that make it possible to implement many neat effects, including translucency, nonrectangular components, overlay and transition animation effects, and many more.
- Advanced effects - Custom components - Playing with opacity - Custom RepaintManager - GlassPane - Layering in UI delegates - Rainbow demo - Q&A Required experience: Basic knowledge of the Swing library is required Expected audience This presentation will be interesting for active Swing users as well as for people who want to discover Swing capabilities

This follow-on to last year's JavaOne sleeper hit "The Top 10 Ways to Botch an Enterprise Java Technology-Based Application" explores best practices for protecting against scalability and reliability in Java Enterprise Edition applications and compute grid environments. Starting with simple abuses of messaging and clustering technologies, this presentation navigates a wide swath of options available to enterprising architects seeking to limit the effectiveness of scale-out environments. After last year's presentation, we were disappointed that some attendees mistakenly used this information to avoid pitfalls, errors, and other common causes of project failure. We hope for better results this year.
   

Traditional Spring-based architectures focus on the notion of a central service layer, with the communication between the services designed as synchronous method invocations. Spring 2.0 introduced extensive support for "Message-Driven Objects" and general asynchronous task execution, allowing the use of messaging and concurrent execution within the heart of a Spring-based application. This talk provides a tour through the messaging and concurrency facilities that Spring offers, including Spring 2.1's JMS configuration namespace and JCA 1.5 support.
Message-Oriented Architectures: messaging versus asynchronous task execution (10 min) Synchronous JMS Messaging in Spring: JMS setup examples, JmsTemplate usage (15 min) Asynchronous JMS Messaging in Spring: message listener container examples (20 min) Spring's TaskExecutor abstraction and other related Spring facilities (10 min) Expected audience: People with an interest in Spring as well as messaging, ideally familiar with the JMS API basics as well as the Spring fundamentals. Attendees will learn about the sophisticated functionality that Spring offers in the JMS space, as well as about the general use of asynchronous execution within Spring-based application architectures.

While WS-deathstar may get a lot of attention in the scalability, reliability, and security areas, RESTful HTTP services have a lot to offer you that you may not be aware of. What's more, the resulting architecture may be simpler and more easily maintained. This session will examine strategies for building scalable, reliable, and secure RESTful web services for the enterprise environment, and examine the reasons for doing so. Along the way we'll cover topics such as ETags, SSL, idempotent methods, various programming toolkits, XML Encryption/Signature, and much more.

The Java Persistence API (JPA) is fast becoming the popular choice for object-relational persistence not only in Java EE environments but also in enterprise applications that make use of other technologies, such as Spring. Since the JPA standard has taken hold, the developer base has gotten more experienced with the persistence model, and the questions that arise are now more of an intermediate or advanced nature. In this talk we will introduce a few of the common features and use them as a platform on which we can discuss some of the higher order JPA topics. As part of this discussion we will show how to use multiple persistence units, define and tune identifier generators, create and invoke native queries, and use XML mapping files for overriding annotation metadata. We will also show how JPA can be used in Java SE and Spring environments. While attendees that have some experience using JPA will profit from this talk, even those who are interested in JPA, but who have not yet started writing applications with it, could also enjoy it. Some kind of experience with Java persistence would be beneficial, though.

Mange applikasjoner er avhengig av batchjobber for å utføre forretningskritiske prosesser. Felles for batchjobber er at de behandler store datamengder, og utføres uten brukerinteraksjon. Batchjobber prosesserer store datamengder, formaterer inndata, utfører datavalidering og implementerer komplekse forretningsregler. Spring Batch er et omfattende lettvektsrammeverk som støtter disse prosessene. Spring Framework har lenge vært det mest populære rammeverket for utvikling av applikasjoner for Java SE og Java EE. Spring Framework legger til rette for POJO-basert utvikling og dependency injection. Spring Batch er utviklet av Accenture i samarbeid med Interface 21. Sesjonen tar sikte på å presentere Spring Batch, og vise hvordan Spring Batch flytter vanlige batchoppgaver som restart, skipping og jobpartisjonering vekk fra utvikler og inn i rammeverket. Presentasjonen vil vise Spring Batch arkitekturen og demonstrere bruken av den ved å gå igjennom en enkel eksempelapplikasjon.
Bakgrunn (Hvorfor et rammeverk, hvorfor open source, hvorfor Spring) Hensiktene/Målene med Spring Batch Spring Batch oversiktsbilde Gjennomgang av de forskjellige konfigurasjonsstegene Demonstrasjon av eksempelapplikasjon Spring Batch roadmap Presentasjon av folkene bak Spring Batch Required experience: Det vil være en fordel for tilhørere dersom de har en grunnleggende kunnskap om Spring Framework. Expected audience: Arkitekter og utvikelre av batchapplikasjoner

This is a comprehensive, hands-on tutorial to using the Mule ESB in a mission-critical production environment. This HOWTO is based on the speaker's experiences deploying Mule ESB at the largest educational toy company in the United States and at the largest company in the world. The presentation will cover such topics as: how do you select an ESB? As a developer, how do you start working with it? How do you integrate it with Spring or other frameworks? Learn how to define the business and technology requirements, compare the characteristics of several ESBs (commercial and open-source), review the ESB architecture, and participate in a short development workshop. Bring your laptop!
- About the speaker (qualifications) - Do you need an ESB? - Enterprise integration architecture concepts - Services-oriented architectures, messaging, and web services - Enterprise service bus evolution - Commercial ESBs - Open-source ESBs - Decision cheat sheet: commercial or open-source? - The Mule ESB - Download, installation, and configuration - Integrating third-party adapters - Application integration - Defining the endpoints - Message routers (synchronous, asynchronous) and transactions - Translators - Extending Mule to handle application-specific messages, routing, translators, and service objects - Deploying the ESB - Embedded in a custom application - As part of Spring or other framework - High-performance dedicated deployment (server selection) - Production deployment - Planning deployment - Deploying the ESB and associated applications - System monitoring - ESB and application monitoring - Disaster recovery and fail-over - Expanding the ESB from a single application to becoming the enterprise backbone - Conclusions - Q&A Expected audience: Software engineers, systems architects, and integration specialists rolling out new applications based on SOA who are in the process of selecting modern and reliable integration platforms, and who want to learn more about the differences between ESBs, their configuration requirements, development and integration effort, and operational characteristics. The attendees will learn: How to select an ESB How to integrate exisiting (Java 1.4, legacy) applications and new technologies How to integrate non-Java technologies into an enterprise application (i.e. .Net) How to extend the ESB functionality through the service managers, routers, translators, and filters written in Java How to integrate the ESB in the environment by embedding it into the application or leveraging a framework like Spring Cost control is an imperative; approaches to reduce costs How to deploy and monitor ESB-based applications (tools discussion) A list of open-source technologies that meet of exceed the feature sets of commercial applications at a fraction of the cost and that will keep the IT organization engaged by participating in a community effort

One of the most popular features of languages such as Smalltalk, ObjectiveC, and Ruby is duck typing. The basic thought behind duck typing is that if an object walks like a duck and talks like a duck, then the language is happy to treat it as if it a duck. In other words: the object’s type is determined by what it can do, not by its class. Web services exchange information, often in a common, interlingual format such as XML. What happens when we apply the principles behind duck typing to Web services? This talk presents WS-DuckTyping: not a new W3C standard; but rather a way to deal with XML as if it were a duck. We will give a number of practical tips to implement this Anatidaeic development style, including working with XPath to extract information from incoming Web service request, whether and how to validate XML with a schema, and more. Finally, we will show some recent improvements into Spring Web Services which facilitate WS-DuckTyping.

Recently we have encountered questions such as "How do I invoke a method" in the context of dependency injection frameworks. The more difficult questions, like "how to invoke invoke a static method" has become senior developer material. The reason is of course that we are now using a ProxyFactoryBean from an XML configuration file, and not Java. The most popular tool for wiring is the Spring Framework, and it will be used in all examples. Wiring applications together using Spring may end up in a set of difficult-to-understand configuration files. There seems to be a belief among most developers that wiring of an application and the use of XML goes hand in hand, and that it is something not possible using pure Java. The speakers will present a Web project consisting of multiple dependencies, where Maven is used to help manage the dependencies. Two parallel approaches will be compared and shown using examples: One using Spring and XML, and one using pure java without a framework. We will compare the two approaches and recommend how wiring together applications using Java can be done, and may lead to a set of other nice effects as well, both in terms of testability, refactoring, and improved roundtrip time. How did we end up here?

OSGi is the server-side revolution that's just around the corner. Gain an early understanding of this important technology and what it can do for you. This session will shortly introduce OSGi and the benefits it offers to enterprise applications and then focus on Spring/OSGi project (Spring support for OSGi) and shows how to build an enterprise application that can take advantage of versioning support (deploy multiple versions concurrently), dynamic service discovery, runtime addition, removal, and update of modules (known as "bundles" in OSGi terminology) and more; all on a proven industry platform.

This tutorial will outline patterns and strategies that can be used to make work easier in large existing Java codebases. An emphasis will be placed upon specific patterns that can be used to identify and break dependencies in code, allowing pieces to be pulled into test harnesses at the unit, component, and subsystem levels. You’ll also learn how to introduce permanent scaffolding in your code to make system evolution easier. The session will consist of lecture and a set of guided exercises in Java. However, we will discuss the application of the techniques in other languages and environments.
- What is Legacy Code? - The Life of a Large Existing Code Base - Seams and Inflection Points - Seam Identification - Component Pruning Strategies - Benefits and Drawbacks of Dependency Injection - Dependency Breaking - Characterization Testing with JUnit and Fitnesse Required experience:This tutorial is for people who have experience working in large Java code bases. Intermediate level familiarity with Java is required.

This talk will cover common challenges when implementing enterprise security applications, such as authentication and authorization, showing how these challenges can be solved using Acegi Security. Acegi Security is an open source project designed for Spring, that overcomes these challenges and in addition incorporates many other useful security features. The next version of Acegi is expected to become part of the popular Spring portfolio.
Acegi Security, authentication, authorization (5 min) Challenges: Authentication and Authorization (10 min) Why not J2EE Security or JAAS? (5 min) Acegi Security - solving the aforementioned challenges (15 min) Demonstration (10 min) Pros and Cons (5 min) Q&A (10 min) Duration: 60 min, including Q&A Required experience: Basic security knowledge. Knowledge of Java EE and Spring Framework. Expected audience: Developers and architects interested in adding security to their Spring applications

One of the key outcomes of the work on EJB 3.0 was the introduction of the Java Persistence API - a new, simplified API for POJO persistence and object/relational mapping for use both in Java EE and in Java SE environments. While the Java Persistence API has received considerable attention since its initial release, it is still missing a number of features that are available in implementations today and that have been requested by the community for inclusion in the Java Persistence standard. The purpose of Java Persistence 2.0 is to augment the Java Persistence API to further address the needs of the community, by expanding its object/relational mapping and query language capabilities, correcting areas that lead to lack of portability, standardizing features that are currently designated as optional or are underspecified, and improving integration with other Java EE platform technologies.
This talk will discuss work in progress on Java Persistence 2.0, currently under development through the Java Community Process program: what our goals are and why; what we have accomplished so far; and what we still need to do.

Structuring a large code base maintained by multiple teams working in parallel can be a real challenge. If you are not disciplined about code structure overtime you will end up with a tangled, unmaintainable mess that cannot adapt to change and risks ossifying into legacy. In this session Juergen and Arjen will pull from their experiences working on large projects to provide important guidelines on code structure. In this session we will pull from their experiences working on large projects (including the Spring Framework) to provide general guidelines on: - Packaging and package interdependencies - Layering and module decomposition - Evolving a large code base We will also discuss how tools can play a role in enforcing architectural soundness. Attendees will leave with practical techniques to improve and sustain the overall structure of their code bases, as well as an understanding of the benefits gained by doing so.
After a short introduction and agenda, we go into code organization. We will explain why code organization is important, but also see that it is often ignored. Next, we will talk about package interdependencies, and show typical examples of code bases that get this wrong. This section will take approximately 10 minutes. Then, we go one step up in granularity, and we talk about module decomposition. We discuss the properties of a module, and talk about the subtle difference between layering and modules. This section will also take about 10 minutes. Then we will look into the Spring framework. We will talk about the evolution of Spring, and the challenges that were tackled when Spring 2.0 was released. This will take about 15 minutes. We will also look at some tools which help you managing such a large code base. We will show these tools in a demo. This will take about 15 minutes. Finally, we offer a summary, and have about 10 minutes left for Q&A. Required experience: Basic knowledge of basic code quality measures is useful Expected audience: Developers working on larger code bases

Since Martin Fowler first wrote his seminal book on refactoring, developers have struggled to use refactoring techniques to extend a data model without spending excessive amounts of time on maintenance or introducing bugs. The talk will walk through this modification to the refactoring concept and what makes an extensible data model extensible. The testaco library and IDE plugin will be demoed during the talk as an example of the emerging tool support in this area.

In this practical session you will learn how to build a highly scalable work management framework using standard JDK 1.5 and POJOs, and how to turn it into a distributed grid implementation by using Terracotta's JVM-level clustering and Network-Attached Memory. We will start with a discussion of Data Grids and the Master/Worker pattern -- one of the most useful parallel programming design patterns in use today. You will learn about the identifying characteristics of the pattern and how best to use it in the real world. Following that, we will cover the production implications of operating and scaling a reliable work management framework, and give examples on how to address real-world challenges such as dealing with very high volumes of data, handling work or worker failure, ordering, routing schemes etc.
You will learn: How to identify cases where the Master/Worker pattern is the right solutions How to build a scalable work management grid framework with 100% POJO-based Java How to cluster the JVM and effectively use Network-Attached Memory

SOA is widely adopted for easy integration, development flexibility and leverage, and business agility. However, the inherent complexities and overheads in today's common SOA platforms make the running of stateful business-critical applications seem impossible. In this session, we will demonstrate that SOA ceases to be an oxymoron to high performance when exploiting simple and open, yet powerful technologies such as Spring and Space Based Architecture as the SOA execution environment. We will outline a clear path for turning existing applications into linearly scalable architectures that scale on-demand across a pool of machines, while discussing issues such as loose versus tight coupling, event driven messaging, synchronization, SLAs and high availability, and migration of legacy applications.
Expected audience: Developers

Har du utfordringer med koplekse data fra flere fagsystemer? Blir systemet ditt tregt fordi komplekse data krever lang tid for å lastes? Dagens virksomheter har ofte et forretningsdomene som spenner seg over flere ulike underliggende kjernesystemer, ofte referert til som silo applikasjoner. Domeneobjektene er adskilte med ulik datakvalitet og gjerne med SLA'er av varierende kvalitet. Dette medfører en arkitektur som skaper integrasjonsutfordringer og som vil får store konsekvenser i en tjeneste orientert kontekst. Typiske tilnærminger til disse integrasjonsutfordringene er master og multi-master strategier. Man har et kjernesystem som opptrer som master og er ansvarlig for å synke mellom "slave" systemene, eller en master for hvert kjernesystem. Enterprise Domain Repository pattern (EDRP) ser utfordringen med at samme data lever i forskjellige fagsystemer. Ved å benytte EDRP oppretter du komplekse objekter en gang. Deretter legges dette objektet i cache, for rask tilgang ved senere bruk. Når du oppdaterer data som berører objektet som ligger i cache, reflekteres dette direkte til alle brukere av tjenesten. Ved at oppdatering også går gjennom EDRP tjenesten vil alle brukere, og alle fagsystemer, ha mulighet til å få med seg oppdateringen. Vi vil i dette foredraget vise hvordan man kan ta kontroll over forretningsdomenet og integrasjonsutfordringene ved å benytte EDRP. Vi vil se nærmere på hvordan EDRP baserer seg på tjenester som korrelerer data fra flere kjernesystemer. Tjenestene vil eksponere forretningsinformasjon fra flere kilder samstilt, og i tråd med virksomhetens egne definisjoner. Ved hjelp av eksempler vil man se hvilke gevinster man får ved å benytte EDRP kontra en master/multimaster strategi.
Introduksjon (1 min) Målet med foredraget (1 min) Typiske integrasjonsutfordringer i dagens virksomheter (10 min) o Overlappende kjernesystemer o Master strategi o Multi-master strategi Tjeneste kategorier (5 min) Enterprise Domain Repository Pattern (20 min) o Hva er det? o Hva løser det? o Hvorfor? o Når bør man bruke det? Erfaringer med bruk av EDRP (10 min) Kilder (1 min) Q&A (10 min)

Apache Tuscany provides an open-source services infrastructure for constructing SOA solutions from heterogeneous and distributed services. To make the implementation and deployment of services straightforward Apache Tuscany is based on the widely supported Service Component Architecture (SCA) specification currently being standardized at OASIS. With the Tuscany implementation of SCA, application developers can easily create, reuse and customize services in different languages, for example, Java, BPEL or various scripting languages, and then assemble and deploy them in a distributed environment. Through slides and examples this talk will introduce SCA and the Apache Tuscany project. It will show you how to get started building and connecting services and how this approach simplifies the task of building SOA solutions.
What’s the problem – 4 minutes What are the business drivers for SOA and what are the problems being faced when using today’s development technologies. Service Component Architecture (SCA) – 6 minutes A description of how SCA provides a programming model for SOA and how it helps solve the stated problems. Apache Tuscany – 8 minutes A description of the Apache Tuscany open source project. The features available today. An explanation of how to get the software and run the samples. Some examples of how the software could develop in the future. An invitation to get involved and an explanation of the different ways to do this. Building a Service. – 5 minutes How to build a service to expose service interfaces. This also shows how to exploit this service from client code Connecting to other services – 5 minutes How to connect the service we have just created to other services that we may create or reuse from other applications Extending the application by adding in more services – 5 minutes How functionality can be reorganized and extended using the SCA model Alternative bindings – 5 minutes SCA and Apache Tuscany is designed to support many pluggable binding technologies so we look here at how different communication protocols can be selected. Alternative data bindings – 5 minutes A variety of data formats and representations are also supported. We take a look at how different data bindings can be selected and used. Bringing it together – 5 minutes Demonstration of an example SCA application. Summary and references - 2 minutes The contents of the talk are summarized and we review the stated problem and the SCA based solution in Apache Tuscany. A set of references for further information is provided. Q&A – 10 minutes Required experience: The talk is aimed at competent developers who want to apply these skills to SOA. No prior knowledge of Tuscany or SCA is assumed but knowledge of programming languages in general and some desire to understand how to apply existing programming skills to build distributed services is assumed. Expected audience: Architects, designers and programmers faced with the challenges of building SOA solutions. This talk presents an infrastructure for building and deploying the services of an SOA using the consistent model provided by the Service Component Architecture.

The key to any successful performance tuning exercise is in getting a measurement that offers the insight needed to understand the root cause of poor performance. Yet for many teams that measurement proves to be very elusive. Lacking any real evidence teams often resort to guessing at what the problem is. Although teams can successfully at guessing it is rarely an effective means to direct a tuning effort. In this seminar we will explore some of the reasons why teams fail to obtain that all revealing measurement. The session will introduce a conceptual tool that can be used to more effectively tackle performance problems. At the end of the day measuring is about tooling and so we will explore some tools that have been useful in exposing root causes of performance troubles.

In contrast to general programming languages like Java, a Domain Specific Language is a programming language that is target towards a particular kind of problem. Even if DSLs have been around in various forms for ages, the rising popularity of dynamic languages has made them a hot topic again. Most of the attention has been on how one can use these dynamic languages constructs to craft embedded DSLs. Unfortunately, most developers cannot use Ruby or Groovy in their everyday work and the advantage a DSL has to offer remains a theoretical possibility. This talk will introduce you to a variety of design philosophies, design patterns and programming techniques you can use to define embedded DSLs using nothing but plain old Java. After attending this talk you should be able to use your Java skills to extend” the language to enable you to write code that reads like plain English.
A brief introduction to Domain Specific Languages Design philosophies o What makes Ruby “elegant”? o Humane Interfaces Designing DSLs in Java (Patterns & Practices) o The Builder pattern - How the builder pattern simplifies object model assembly. - Using Java 1.5 static imports to extend the Java vocabulary. - Demo: “Skipping two versions” – Language level XML support in Java 1.5 (See http://andersnoras.com/blogs/anoras/archive/2007/04/25/xml-dsl-for-java-1-5.aspx for an example) - Demo: Building a DSL for XHTML Documents. o The Fluent Interface pattern - Creating expressive APIs that read like plain English using the fluent interface pattern. - “LINQ for J” - Extending Java with a query language. (See http://andersnoras.com/blogs/anoras/archive/2 007/03/23/guess-what-i-m-up-to.aspx for an example.) - Demo: Adding query capabilities for any Iterable resource. - Demo: Extending Hibernate to support the query DSL. “There is more to Java than Java” - Using the Java 1.6 scripting features to create dynamic DSLs.

Those involved in software have a lot to keep in mind as they negotiate the worlds inside and outside of their code and the relationship between them. For those interested in improving the state of their art there are many (many) sources of specific recommendations they can use to sharpen their practice.
This talk takes a step back from the busy, overpopulated and often overwhelming world of such recommendations to focus on five general considerations that can inform more detailed recommendations and specific decisions.

There is a big buzz and a lot of hype about Service Oriented Architecture (SOA) and the Enterprise Service Bus (ESB). A solid SOA architecture allows you to use standards-based, pluggable, and loosely coupled services to integrate and communicate the critical business logic from disparate systems. Apache Service Mix is one of the first ESB implementations in open source to offer a solid foundation for building SOA applications. This session will cover Apache ServiceMix and how it implements Java Business Integration (JBI - JSR208) covering Service Engines (SE), Binding Components (BC), and how the different components communicate via the Normalized Messaging Router (NMR). It will also demonstrate coding and wiring these components together to show how to begin building a SOA based application with a real world example.
1) Business Integration Problem 2) Past solutions 3) SOA - What is it? 4) ESB and open standards 5) JBI - What is JBI and why is it the answer? 6) JBI - The Answer 7) JBI Overview 8) ServiceEngines and Binding Components 9) WSDL 10) Messaging, Normalized Messaging Router 11) JBI Artifacts 12) ServiceMix - Opensource ESB JBI JSR-208 Compliant container 13) JBI ServiceMix Components 14) Developing and wiring a ServiceUnit 15) Xbean/Spring 16) Realworld examples 17) WSDL First 18) Loan Broker (JMS based Soap Messaging)

The Java platform comes with plenty of tools to ease software development. Since version 6, the JDK now includes Java DB, a 100% Java powered database. Leveraging the ease of use of the Java Persistence API, now also available in a Java SE environment, developers can easily take advantage of the power of these systems in their desktop applications. During this presentation we will cover what is needed to integrate these tools within a Swing application and demonstrate the benefits in term of speed and features both technologies can bring to your desktop software at almost no cost. Besides persisting your domain model, you'll also see how to persist your application state, enabling instant recovery from expected as well as unexpected terminations. Finally, beyond the desktop local data, we'll introduce remoting, synchronizing data with a remote Java EE application: on top of synchronizing modified data on both ends, it also export new instances to each database.
+ The application before: - Presentation; - Serialization; - Querying. + Java DB: - Quick intro; - Packaging within the app. + JPA - Quick intro; - Packaging within the app. + Refactoring the app - Your model as entities; - Life-cycle and tx management; - Querying; - Persisting your application's own state. + Beyond the desktop - Introducing remoting; - synching both sides; - Dynamic proxies. + Conclusion + Q&A

Deploying Maven in large organizations is not an easy task. Primarily it requires a change in mindset on how to create and maintain your software codebase over time. In order to successfully introduce Maven it is important to setup the necessary infrastructure components correctly. This includes the installation of Maven, a company internal artifact repository, establishing project object models and continuous integration, integrated with the company source control system. Also an internal Maven Proxy should be set up, in order to build on top of external repositories if this behaviour is desired. The presentation takes a practical approach to establishing all the required infrastructure components based on best practices and real-life project experience within large enterprise projects. I will address common challenges when deploying Maven and related products. Maven requires a somewhat different mindset than traditional solutions, like using Ant for purposes of build and committing binary artifacts to version control. Traditionally, many companies have invested lots of time into developing their own build scripts on a per project basis and these are very rarely reused. With Maven, the approach is different - the idea is to deploy a company-wide infrastructure which should be reused by all projects. Also, when reusing in a large enterprise context, the advantage of common rules for placing source code and configuration files are truly helpful as they secure an enterprise-wide point of standardization. Internal frameworks are much easier to reuse than before by continuously deploying company internal snapshots thus making them available for clients. Also, automation of code metrics and different types of reports are easy to publish. Other challenges one typically faces, of which will be addressed as part of the presentation are: - Implicit plugin versioning often causes problems. Without explicitly setting versions, the latest/greatest snapshot will always be downloaded and the quality of those can vary. - Many third party frameworks are distributed with poor dependency definitions, causing many unnecessary artifacts to be downloaded and deployed through transitive dependencies. - From time to time, people make mistakes like redeploying new versions of artifacts based on existing versions. This will cause clients to never download the new versions of those artifacts. - When introducing many frameworks at the same time, one risk that several artifacts have dependencies to different versions of the same artifacts and this can cause some difficult to solve side-effects in the runtime. - Many companies carry legacy build solutions and it is possible to integrate those with Maven. However, a mix of Ant, Maven1 and Maven2 is never a good idea in real-life.
Why Maven is useful in an enterprise context beyond building and developing standalone applications. Establishing an enterprise-wide artifact repository based on available open source products, like Maven proxies. Configuring the project object model to integrate the repository and source control. Establishing continous integration with Continuum. Q&A

After fighting complexity in configuration management, packaging, bureaucracy and deployment with Java EE servers for longer than we thought was humanly possibly, my team finally decided to go back to basics. Instead of a complex Java EE application server, we have put together a 100% open source application stack that runs in a standard Java SE environment, and addresses the development life cycle from programming and unit testing into production and operations. The solution has given us simplicity and control over the whole life cycle from development and unit testing, through continuous integration, packaging and configuration management, into staging and production environments. The presentation will focus around a practical demonstration of this life cycle. Our new solution, internally dubbed "the Java SE server", is a custom-built assembly of stable and widely used open source components like Maven, Jetty, Spring and Hibernate running on a standard Java VM. We are currently in the process of rolling out the solution on four systems, three of which are business critical, and more will follow. (Some roll-outs will be before JavaZone, some after)
What am I going to show you, and why? Semi-practical demonstration: Production deployment Releasing Continuous deployment Packaging Unit testing Benefits we experienced with this approach How it is done Challenges: Technical, organizational and legal Results: Performance and operational characteristics Q&A /ul>

Besides the wide variety of open source tools and frameworks for application development, the support for open source enterprise integration is growing fast. This presentation will provide the attendees with a selection of Open source Enterprise Integration tools and frameworks and will show these tools and frameworks with demos. The foundation of this presentation will be based on Mule. This Open source integration platform shows that implementing an ESB doesn't have to be complex and expensive. A more lightweight approach can be very benificiary in a lot of cases. To show that Mule can be used in enterprise integration scenarios, a number of the Enterprise Integration Patterns of Hohpe and Woolf are implemented. By using these patterns we can show the attendees a structured approach from designing an integration solution to the real implementation of the solution.
Goal of this presentation (overview of open source enterprise integration, structured approach from design to implementation) 3 min Overview of Mule (Mule history, architecture and UMO components) 5 min Hello world demo with Mule (Show the open source tools and frameworks) 10 min Case study (show a simple case study) 2 min In action demo (coding the solution during the presentation) building up the case study in parts (30 min) Start with a simple message channel (point-to-point and pub-sub) Show content enricher, canonical data model and message transformation with integration of NASA Map Show content-based routing with integration of Flicker

As web sites transition from simple content to full-blown, two-way applications the legacy cruft of the past ten years is becoming apparent. There are millions of sites and billions of pages that have been around since the 1990s. Many of these pages were designed for browsers like Netscape 3, Internet Explorer 2, or even Mosaic. They may have been redesigned several times, but the underlying structure and markup remains the same; and this is becoming a problem. These pages don’t work well with modern technologies and tools like AJAX, DOM, E4X, JavaScript, and more. Consequently, many web developers and designers find themselves faced with legacy code for the first time. Until recently most sites and pages just weren’t old enough for legacy issues to be a major concern. While legacy issues and the tools and techniques for managing them are well known to programmers, web folks are just now learning about these problems. As web designers begin to grapple with the legacy issues that have hampered programmers for so long, they’ll need to learn the same refactoring techniques programmers have used to manage these problems.
This talk help web designers, web authors, web programmers, and webmasters learn the tools and skills they need to clean up their sites so they can take them to the next level. Specific goals include improving accessibility and usability, optimizing search engine placement, and reducing the overall cost of development for web sites. by converting sites to web standards: XHTML, CSS, and REST.

It bransjen har gjennom ”SOA bølgen” hatt stor fokus på forretningsprosesser, noe som vises ved at mange produktleverandører fronter prosessmotorløsninger, gjerne sammen med deres ESB løsninger. Tradisjonelt sett har prosessmotorløsninger vært brukt til styring av backend integrasjon. Nå ønsker flere kunder en nærmere kobling mellom brukerne og forretningsprosessene, slik at it- systemene faktisk støtter hele forretningsdriften. I denne sammenheng finnes det mye uklarheter om hvordan man på best måte kan gjøre dette. En av utfordringene er hvordan brukerens skjermbiler og skjermflyt kan samspille med den overordnede forretningsprosessen. Vi oppklarer forskjellen mellom skjermflyt og forretningsprosesser, med å presentere scenarioer hvor dette samspillet demonstreres. Vi viser hvordan man pragmatisk og enkelt kan integrere en forretningsprosess med en Spring Web-applikasjon. Vi demonstrerer prosesser som spiller sammen med skjermbilder og forretningslogikk implementert i en Javaapplikasjon. Videre går vi inn på hvilke fordeler og bruksområder man har ved å la en forretningsprosess styre en brukerapplikasjon, og når man bør gjøre dette. Vi vil diskutere forskjellen mellom skjermfløytverktøy som Spring WebFlow og prosessverktøy som BPEL. Scenarioene i som presenteres er basert på erfaringer fra store norske prosjekter.
Introduksjon  Presentasjon av speakers Problemstilling: foretningsprosesser og skjermflyt Problemstilling: Pragmatisk implementasjon Presentasjon av teknologi Prosessmotor(ESB)- teknologi benyttet Rammeverk og annen teknologi Scenario 1: Bookingsystem Presentasjon av en avansert bookingprosess Interaksjon mellom forretningsprosess og skjermbilder Scenario 2: Saksbehandlingsprosess Presentasjon av en to-trinns saksbehandlingsprosess Applikasjonsarkitektur Interaksjon mellom forretningsprosess og skjermbilder Demonstrasjon av forretningsprosessen i benyttet verktøy Demoapplikasjon  Spørsmål / diskusjon Required experience: Grunnleggende forståelse av integrasjon og J2EE utvikling. Expected audience: Utviklere og arkitekter med interesse for enerprise arkitekturer.

Join Ben and Dion as they walk attendees through the rapidly evolving and often confusing Ajax landscape, covering the important topics and trends that will affect how you develop web applications. Far from a fickle fashion, Ajax is continuing to revolutionize the way software is built, from providing the new model for desktop applications to the new model for mobile applications. The Ajaxians will start the keynote analyzing the large impacts Ajax is having on the development landscape, including the latest in end-to-end JavaScript (i.e., JavaScript serving up JavaScript to the client) and server-less Ajax. They'll next discuss how the frameworks are changing to make development easier and it better address the challenges of cross- browser development. The final part of the talk discusses the state of the browsers, the Ajax community, and the future.

One of the most difficult things to do (in Java web development) today is pick which web framework to use when development an application. The Apache Software foundation hosts most of the popular Java web frameworks: Struts, MyFaces, Tapestry and Wicket. This session will compare these different web frameworks, as well as Spring MVC and Stripes. It will briefly explain how each works and the strengths and weaknesses of each. Tips, tricks and gotcha's will be plentiful. Lastly, it will provide attendees with a sample application that utilizes all 6 frameworks, so they can compare line-by-line how the frameworks are different. This sample application will include the following features: sortable/pageable list, client and server-side validation, success and error messages as well as some Ajax functionality. The frameworks will be rated on how easy they make it to implement these features.

This session provides an introduction to GUI development with JavaFX Script, an object-oriented, declarative Java scripting language.
JavaFX Script is a statically typed language that allows good integrated development environment (IDE) support and compile-time error reporting and has type inference, declarative syntax, and automatic data binding with full support for 2-D graphics and standard Swing components as well as declarative animation. You can also import Java class files, create new objects for the Java platform, call their methods, and implement interfaces for the Java platform. IDE plug-ins are available for both the NetBeans IDE and Eclipse. Both plug-ins support as-you-type validation, code completion, syntax highlighting, and hyperlink navigation (with Control-mouseover). JavaFX Script attempts to demonstrate that we're not exploiting the full capabilities of the Java platform for GUI development and that, together with supporting tools, the Java platform is highly competitive with or superior to competing GUI development platforms such as Adobe Apollo, Ajax/DHMTL Macromedia Flash/Flex/Open Laszlo, Microsoft WPF/XAML, and Mozilla XUL.

Norwegian start-up company Ezmo used Adobe Flex to eliminate waste from an early beta-release to enable a quick delivery with waste improvements. By removing JavaScript, Direct Web Remoting, Spring MVC and replacing them with Adobe Flex Ezmo was able to deliver what had taken 4 months in less than four weeks. Due to the support for rapid application development and the removal of architectural components which did not provide any added value. Developing web applications on the Java platform usually involves a lot of different frameworks, tools and platforms. In many projects all of these components are usually chosen before the requirements or scope has been determined for the project. Introducing the Adobe Flex framework enables developers to get a better understanding of requirements and scope without too much effort. Adobe Flex enables development teams to have designers and programmers work together in the same IDE. This makes the development faster and enables all team members to do what they know best. Introducing Life Cycle Data Services (LCDS) into Java development enables developer to create collaborative software straight out of the box. With push capabilities, support for partially connected applications, built in pagination and scalability LCDS is a powerful platform for Java application development
Reduce waste and complexity by removing your frameworks     Reduce use of complex patterns  Better User Experience with data driven applications      Experience and design matters, not frameworks. Live Cycle Data Services Data push  Reduce network traffic XML, foe not friend Rapid prototyping Functionality where it belongs Ezmo success story Required experience: none Expected audience: System architects, java-, web- and application developers.

Testing havner veldig ofte i annen rekke når man utvikler web-relaterte applikasjoner i Java. Dette er gjerne på grunn av tett knytting mellom de(t) rammeverk som benyttes og selve web-containeren. Alle som har prøvd å lage mock-objects e.l. for Servlet-klasser kjenner seg mest sannsynlig igjen i dette. Ofte ender man opp med å si at "vårt servlet-lag er så tynt, så vi trenger ikke teste det", en påstand som gjerne er mer en unnskyldning enn realitet. Dette foredraget vil vise hvor lett det er å komme i gang og bruke Struts2/WebWork, med fokus på testing av webløsningen. Ved hjelp av verktøy som Maven2, FitNesse og Spring kan man bygge opp et svært fleksibelt og oversiktlig system, basert på automatiserte kravtester. Det blir utstrakt bruk av eksempler og kode.
Introduksjon til problemstilling - problemer med testing av web-applikasjoner (5 min) Oversikt over Struts2 (10 min) - Oversikt over Struts2 - Installasjon og oppsett - Hva er nytt fra forrige versjon? Oversikt over støtteverktøy (10 min) - FitNesse - Spring - Maven2 Testing av Struts2 applikasjon - vise ved hjelp av eksempler hvordan man bygger og tester Struts2 applikasjoner (20 min) - Enhetstest - Integrasjonstest - Kravtesting/akseptansetest Oppsummering & konklusjon (5 min) Q&A (10 min) Required experience: Erfaring med utvikling av web-relaterte Java-applikasjoner (JSP/Servlet). Gjerne noe erfaring med forskjellige web-rammeverk. Expected audience: Alle som jobber med utvikling av web-applikasjoner i Java. Både nye og mer erfarne brukere av Struts2 vil ha glede av foredraget!

Web 2.0 is one of the most important buzzwords in the last years, however what does this mean for Enterprise Java developers? Based on the practical case-study "Parleys.com" (a web 2.0 video streaming eLearning site) we'll have a closer look at which Java API's and frameworks are available to develop such a project. This first part of the presentation will start with an introduction on what Web 2.0 really is, followed with some Java related technologies used within the Parleys.com case-study. More specific we'll have a detail look at the state of the Dojo toolkit, how Flash with JavaScript integration can be accomplished, JSON and Confluence as a web 2.0 development platform. Ajax do's and don't s will also get covered based on the practical experience of several web 2.0 projects. The third part of the presentation will look at emerging Web 2.5 technologies that are appearing from vendors like Sun Microsystems, Google and Adobe focusing specifically on JavaFX, Flex2/Apollo and Gears.
Expected audience: Developers

During this session Mike will challenge you with several JavaScript puzzlers. You will investigate some tricky parts of error-laden JavaScript code and see for yourself whether an IDE is just a useless "5th wheel" when struggling with errors like these, or if it could serve as your 6th sense and provide extra insight into code problems.
Expected audience: Developers.

Why stop object oriented programming at the web tier? Why settle for legacy ridden, prematurely optimizing, mind numbing frameworks when instead you could be having fun coding again? Enter Apache Wicket!
In this session, I will show you how you can use Apache Wicket to develop web applications with Just Java and Just HTML. I'll talk a bit about Wicket's philosophy and why it's developers believe it is important to take a novel approach. And then, because only code really talks, we'll take a deep dive to look at how to develop some custom, reusable components.

Direct Web Remoting (DWR) is an open source AJAX library. Its focus is on the core of Asynchronous JavaScript and XML(AJAX) programming; communication between client and server without having to load a whole page for each interaction. DWR basically lets JavaScript invoke Java functions on a server just as they were JavaScript functions running on the browser. The library supports a wide range of frameworks like Spring, JSF and Hibernate. For more advanced applications it also supports reverse AJAX. This means that the server can “push” data to web browsers instead of just having to respond to requests from the browser. Despite all its features DWR is quite easy to use and get started with and fits well into most Java Web applications. Therefore it is one of the most widely used AJAX frameworks around. This presentation is meant as an introduction to DWR. Its first focus is on DWR's features with examples on how they can be used in web applications. The second focus is on how to set up and to create an application. This will be accompanied with a few hits and tips from the use of DWR on real world applications. The purpose is for the attendants to be able to start using the basic features of DWR after the presentation.
Introduction – 5-7 min About the presentation About the speaker A DWR teaser Presentation outline Features - 6 minutes Possibilities Examples – 9 minutes Exploring the features What can we use DWR for Set up – 6 minutes Getting ready for creating the application Demonstration – 12 minutes Creating a little application Some tips along the way – 5 minutes Learn from some common mistakes Summary – 2-3 minutes Questions and Answers - 10 minutes Required experience: Basic knowledge about HTML, JavaScript and Java Web application development. Expected audience: The presentation is for those that want to get an introduction to one of the best known AJAX frameworks we have today and have some knowledge about Java Web development. They will know how to start using DWR on AJAX applications.

For developers who are currently using Spring and JavaServer Faces together, this session explains how to handle common application development concerns such as conversational scope, transaction management, and application partitioning.
Specific tools such as Apache MyFaces Orchestra, Spring Annotations, and Spring WebFlow will be discussed. At the end of this session, developers will understand how to build a full-stack JavaServer Faces/Spring/JPA application with features similar to those of JBoss Seam.

Gjennom dette foredraget vil dere få kunnskap om utvikling av applikasjoner for mobilen. Hvordan håndtere generelle problemstillinger som terminalforskjeller, minneforbruk, brukervennlighet osv. Vi ønsker å presentere hvordan vi i mBricks plattformen håndterer dette slik at du som applikasjonsutvikler blir mest mulig effektiv.
Innleding: mBricks, mobilmarkedet, produktet (5 min) Terminalforskjeller: Utfordringer, løsninger, en kode for alle terminaler, ulike implementasjoner av JSR’er (5 min) Minneforbruk: Begrenset minne, tips og triks for å holde minneforbruket på et minimum (5min) Brukervennlighet: Små skjermer, begrenset input muligheter, branding og pixelkontroll (5 min) Kommunikasjon: HTTP, TCP, UDP (5 min) Sikkerhet: Mobilkryptografi, lagring av sensitive data (5 min) J2ME vs. J2SE: Hovedforskjell mellom J2ME og J2SE (5 min) WAP vs. Java: Fordeler/ulemper (5 min) mBricks – en ny standard for mobilapplikasjonsutvikling: Hvorfor mener vi at mBricks bør bli en ny standard og hvordan har vi tenkt å gå frem for å få dette til å skje (5 min) Demonstrasjon: Kodeeksempler (5 min) Demonstrasjon: Applikasjoner utviklet vha. mBricks (5 min) Q & A (10 min) Required experience: J2ME og J2SE kunnskap Expected audience: Who should attend: Java utviklere, forretningsutviklere og personer med interesse for mobilapplikasjoner Benefits from attending: Økt kunnskap om J2ME, innsikt i utvikling av mobilapplikasjoner og markedet rundt dette.

The JME/Canvas API has been a preferred API for mobile games due to responsitivity and total control over the mobile screen. Several Canvas frameworks have been made to speed up UI development. Some of these have been very successful and have resulted in superior applications, even for mobile enterprise applications. This presentation will focus on why the Canvas-platform is the best choice for mobile applications with rich user interfaces, and how strong authentication and secure communication can be integrated, forming an easy-to-use framework for enterprise mobility The presentation cover the JME client architecture in general and the Canvas API in special. Available Canvas frameworks will be explained, and there will be live demonstrations of example applications. A security architecture for banking and enterprise applications will be exploited, based on a Canvas framework and commercially available Java/JME security components
J2ME evolution (5 min) The JME client architecture (10 min) The Canvas API (10 min) Canvas Frameworks(10 min) Integrated security (5 min) Example applications and demo (10 min)

Java has penetrated most areas in software engineering today, from small embedded device to large, distributed enterprise systems. However, one area where Java still is absent is 3D desktop games. This session will demonstrate how easy it is to write a complete 3D game using Java and show that it is a viable platform for writing real, commercial desktop games. It will focus more on the different software components and less on 3D APIs, so very little knowledge about OpenGL and 3D programming is required.
Presentation agenda Introduction to game demo Tools, APIs and frameworks Java OpenGL Custom scene-graph and loading of 3D models 3D navigation Collision detection Multi-player solution Required experience: Intermediate Java experience Expected audience: Anyone interested in writing 3D applications and/or games using Java Additional information: The game will be a very simple third-person shooter with multi-player support. The entire game, source code, models and textures included, will be available as open-source online after the conference.

Running Java with limited resources takes a different approax to selecting frameworks and getting good responsiveness from the applicaiton. Key decisions: Do not use persistence frameworks, database or other out of process storage Use the tools in in java.util.concurrency library for nonblocking algorithms To avoid locking and deadlocks, use message driven and asyncron Traditionally Java is used in areas with lots of memeory, CPU and disk, but there is no reason for not using Java when resources are limited.
What we mean by Embedded Software in TANDBERG The embedded setting A short introduction to video conferencing and protocols What consequences have limited CPU and memory and no harddrive Early decissions Benefits of Java outweights the negatives, e.g Garbage Collection hits and no predictable performance We need Java5 (wasn't available at decisions time, but SUN promissed later) Create a simple message driven asynchronose framework Fast, soft realtime and hard realtime What is Real time java, JSR-1? What is fast compared to real time Why we choose not to use JSR-1 What can be learnt from looking into a real time Java runtime. Challenges What is fast enough? How to handle large amount of messages? How to introduce Java in a C/C++ shop? The beauty of lean principles? Defer commitment and deliver fast Experience Java can be very fast The Java toolset is excelent Spring2 and JPA are not for everyone

When making large web application controlling page flow is traditionally not very flexible or maintainable in mainstream web framework like STRUTS or JSF. This talk shows how to use Spring Web Flow (SWF) to control flow and what benefits and problems we experienced on a large JSF-based project. The benefits include richer model for the lifecycle of objects and more configurable flow between web pages. The problems ranged from the usual headaches of using XML closely tied to Java classes, bugs in the current implementation and the need to make a good design for how the flow should be. The talk will discuss some of the limitations in SWF, like no support for inheritance, and provide some work-around’s. Description of SWD taken from www.springframework.org: “Spring Web Flow is a next generation Java web application controller framework. The framework provides a powerful system for implementing navigation logic and managing application state consistently across a variety of environments. Spring Web Flow is a component of the Spring Framework's web stack focused on the definition and execution of UI flow within a web application. The system allows you to capture a logical flow of your web application as a self-contained module that can be reused in different situations. Such a flow guides a single user through the implementation of a business task, and represents a single user conversation. Flows often execute across HTTP requests, have state, exhibit transactional characteristics, and may be dynamic and/or long-running in nature. “
Required Experience: Knowledge of JSF

This talk will explain how it was possible to develop an advanced and easy to use insurance sales web application in only 6 months, and at the same time ensuring adherence to good architecture principles and software development practices. The factors that that made the project a success and the lessons learnt in the following areas will be presented: Methodology and project organization GUI design and usability Architecture and technology Development tools and process The audience should gain a better understanding of how to set up and run a successful enterprise Java project.

If you havent lived in a cave the last 2-3 years you have no doubt felt the buzz around SOA – Service Oriented Architecture. Perhaps you’ve seen the slides and white papers from evangelists and thought ’Thats all nice but what does it all mean?’. The talk aims to highlight that issue from a developers/architects standpoint and with basis in real life project experiences. The SCA (Service Component Architecture) initiative is quickly picking up speed as the best-practice way to implement service-oriented enterprise applications. Or put another way: SOA is growing up and getting a life. Get the dirt on SCA and find out how you can adapt to this step in the evolution of enterprise applications today by leveraging existing Java technologies.
Overview of SOA, challenges and visions, 5 mins Overview of the Service Component Architecture (Service Data Objects, SCA modules, Technologies etc), 15 mins Architectural Case Study – Real project experiences from adoption of SOA/SCA concepts within automotive, 30 mins Q & A, 10 mins Duration: 50 mins, 10 min Q&A Required Experience: The conceptual parts of the talk can benefit anyone involved in service-oriented development but to get full benefit of the case study part a good general working knowledge of Java Enterprise development is preferred. Expected Audience: Developers, Designers and Architects of Enterprise Applications with service-oriented ambitions. Although SCA is largely technology agnostic this talk is geared towards Java-based implementions.

Simplicity is perhaps the most important quality of software development. This session provides lessons learned from simplifications in an enterprise application development project. After more than two years of development the program seemed increasingly far from completion. Multiple re-planning exercises turned out to be futile. The projects were weighed down by complexity, preventing progress and destroying morale. The presentation will give concrete examples of how things can be done in a simple manner - as well as hideous examples of complexity - in areas such as platform and infrastructure, methodology and documentation as well as development, testing and change management. Why do you need a Business Process Engine when the standard Java Runtime is sufficient? How many people should be involved in deploying an application to system test? Should you roll your own component instead of acquiring a third-party library? Seeking simplicity in all areas is likely to result in considerable increased velocity, and arguably lead to increased maintainability and testability.
- Introduction - Simplicity is the opposite of complexity (5 min) - Simple platform - The JRE and lightweight frameworks (5 min) - Simple infrastructure - Redundancy, scalability and transactions (5 min) - Simple deployment - Self-contained and automated (5 min) - Simple design - Domain-Driven Design can lead to Big Design Up Front (5 min) - Simple documentation - Travel as light as you possibly can (5 min) - Simple functional testing - Tester Developers and Developer Testers (5 min) - Simple technical tests - The unit test from Hell, and other tests to avoid (5 min) - Simple code - Threading madness, and how TDD keeps you honest (5 min) - Simple development environment - Shrink-wrapped and ready to roll (5 min) - Simple operations - Start, stop, rollback and monitor (5 min) - Simple configuration management - Lists are waste; prevent bugs from slipping in (5 min) Required experience: The presentation will touch many areas of enterprise application development, from testing and development to infrastructure and deployment. Experience from a Java development project is recommended, but except a few examples the presentation does not require deep technical knowledge. Expected audience: The presentation is from an architects perspective, and should be relevant for developers, testers, project managers and architects.

Ajax-teknikker gjør det mulig å gi web-applikasjoner et brukergrensesnitt som ikke tidligere lot seg realisere i en nettleser. 'Bygg for alle'-prosjektet har brukt Ajax for å realisere et svært dynamisk brukergrensesnitt for registrering og publisering av informasjon om tilgjengelighet i offentlige bygg. Dette erfaringsforedraget diskuterer hvordan Ajax påvirker MVC-arkitekturen til systemet, samt demonstrerer hvilke utfordringer man står ovenfor ved bruk og testing av Ajax-funksjonalitet.
- Bakgrunn og motivasjon for løsningen (5 min) - Arkitekturen i løsningen (10 min) - Datadrevet metamodell m/ dynamiske dialoger - Ajax og MVC - omfattende bruk av Ajax og asynkronitet i web-løsning - treeview er Ajax - alle dialoger under er Ajax-basert - Ajax og web-rammeverk - mister mye web-rammeverk funksjonalitet v/ bruk av ajax - hva vi valgte - Yahoo UI Library - Velocity - Spring MVC - Servlet - Hva vi ikke valgte - GWT - hot, men ferskt når vi startet prosjektet - metadatastrukturen vår kunne bli en utfordring - Erfaringer og gotchas (20 min) - Ivaretakelse av tilstand på flere nivåer i klienten - Asynkront kommandogrensesnitt basert på XML - Divider/scroll-bar problematikk - Enkoding-problematikk v/ dynamiske skjermbilder - Feilhåndtering og validering, tilbakemelding - Asynkront kommandogrensesnitt basert på XML - Retur av html til placeholdere - Nyttige utviklingsverktøy - Testing av Ajax-funksjonalitet (10 min) - Utfordringen med testing av JavaScript - Selenium + Fit - Testing mot flere browsere - Spørsmål (10 min) NØDVENDIG ERFARING: Noe erfaring med utvikling av web-løsninger er fordelaktig PUBLIKUM: Alle med interesse for moderne web-utvikling

BBS develops and operates the systems behind the electronic payment methods that are available between and through the banks in Norway. We have a number of batch applications for processing transactions between accounts and banks, that communicate by sending messages. Clusterability, fail-over and total transactional integrity are natural requirements for both the applications and the communication infrastructure. We have developed a simple messaging solution with inherent fail-over capability and some load balancing, all running in the same transaction as the application's database access. Originally we started out with a commercial XA-compliant JMS solution, thinking it was the simplest thing that could possibly work. As we employed features such as fail-over, load-balancing and distributed transactions complexity and internal errors sky-rocketed. After about a year we gave up JMS and developed our own very simple solution. We think the reason for the success of our solution is simplicity and the fact that we only keep state the one place it belongs: the database. The talk will present how and why the BBS "message pump" works in unit tests and when clustered, and also why we think the JMS solution becomes more error-prone the more fail-over servers you add.
- Hello and intro - "What do we do": Bird's eye view of BBS's services and the Norwegian inter-bank infrastructure - Our base architecture/service abstraction: communicating void-method java interfaces - Mediating communication asynchronously with message-passing and claim-check pattern - The need for clusters, transactional integrity and guaranteed execution. - BBS Message pump: A simple pojo-based solution: design overview, state-management - Contrast: setting up and using High-Availability JMS - (if time allows: experience from development and operation of advanced JMS solutions) - Transaction state management with XA/distributed transactions and our experience from how it's solved in JMS - "HA Transactional" JMS will be less stable the more redundant servers you add - Conclusion: A note on how and where to manage execution state in transactional clustered solutions, and where NOT to keep it. Required experience General knowledge of distributed systems and transactions are required. Expected audience Developers and architects working with enterprise integration and/or systems including batch processing or order processing solutions.

Java SE 6.0 introduces Java Specification Request (JSR) 223, the Scripting for the Java Platform API, which allows you to evaluate scripts from within a Java application. Scripting languages have the advantage of being dynamically typed; they are in most cases interpreted, and do not require variable declaration or compilation. We will look into Project Phobos - a lightweight, scripting-friendly, web application environment running on the JavaTM platform. With Phobos, you can write web applications using several different scripting languages. The interactive development environment allows you to avoid explicit compilation and deployment steps, but still retain the power of the Java platform. After attending this session you should be able to harvest some of the advantages of the scripting API -for instance by starting to use the Phobos web application framework in your projects.
Outline Introduction (5min) ° JSR223 Examples of script programming on the Java platform (20min) ° JRuby ° JavaScript ° Velocity Phobos (20min) ° Lightweight, scripting-friendly, web application environment ° Demonstration Conclusions (5min) ° Summary ° Benefits Q&A (10min) Level Introductory / intermediate Required experience Curiosity Expected audience If you want to learn more about the scripting abilities in Java you should definitely attend this session

Foredraget drøfter i hovedsak hvilke utfordringer som kan oppstå ved innføring av AJAX i en webapplikasjon, og hvordan disse ble løst ved bruk av Google Web Toolkit (GWT). Vi vil presentere versjon 1.0 av applikasjonen basert på JavaScript og tredjeparts AJAX biblioteker, samt endringene i versjon 2.0 ved innføring av GWT. Erfaringene fra versjon 1.0 sammen med nye krav gjorde at vi måtte velge en annen strategi for utvikling av versjon 2.0 av applikasjonen. Spesifikke områder som vil bli belyst er integrasjon mellom Spring MVC og Google Web Toolkit, og hvilke implikasjoner det får for systemets arkitektur. Vi vil også ta for oss kodeeksempler, byggstøtte, feilsøking og testmuligheter for begge versjonene. Siste del av foredraget tar for seg hvilke fordeler og ulemper vi ser ved innføring av GWT, og hvilke utfordringer vi står ovenfor ved videre utvikling av produktet.
1. Introduksjon - Foredragsholdere og introduksjon til prosjektet 2. Hovedinnhold - Versjon 1.0: Krav, valg av teknologi, arkitektur og utfordringer dette gav. - Versjon 2.0: Nye krav, nye valg av teknologier og ny arkitektur - Integrasjon mellom GWT og Spring. - Verktøy-/byggstøtte - Demo. - Fordeler og ulemper med valgt GWT løsning 3. Spørsmål og svar Required experience: Det kan være en fordel å kjenne til JavaScript. Tilhørere bør ha grunnleggende kunnskaper om AJAX, samt Google Web Toolkit. Det er også en fordel å ha kjennskap til Spring. Expected audience: Personer som har interesse av AJAX-løsninger.

In this _interactive_ session we try to analyze where the industry is going in the next five years. Together we identify issues and enlighten them by using Edward de Bono’s thinking hats.

FIT is a framework that comes in various guises (Fit, Fitnesse, Fitlibrary), and can be used in different ways. The core principle behind writing FIT documents is to promote better communication between the stakeholders of a system. By using FIT, we can get our customers more involved in the design and specification. With the help of FIT documents, we will collaborate more closely and evolve a better shared understanding. As the system evolves, the collective set of FIT documents will provide a living specification - the place that everyone refers back to, to understand what the system actually does. In principle, using FIT is a good thing, but in practice we find that some teams struggle to use FIT documents effectively. Based on our experience, we provide our advice on what to focus on, and what to steer clear of when writing FIT documents in your team.

Imagine that you are responsible for driving a truck across America, along highways, through cities and around detours, dealing with whatever idiosyncrasies that weather and traffic might throw at you. Now imagine that your job is not to drive the truck, but program a computer to drive the truck for you. How would you go about turning over everything you know about driving to computer? Trying to plan a large software development effort is not much different than trying to plan the development of a software package to drive a truck across America – without access to the truck. In software development, we have been asked to solve too many truck-driving problems. And when it turns out that we have been handed an impossible problem, it’s usually the developers – not the process or the scale of the problem – that are held responsible for the failure. At its core, software development is the process of gradually finding ways to turn over more and more of what we know to computers so that we have more space left in our minds to discover ever more interesting things. This talk will look at successful development efforts on the scale of the truck-driving problem – the development of the Internet, for example – and offer a proven but neglected theory about how to develop complex software.

During the past 3-4 years BEKK has delivered many software development projects using an agile software development process - the majority contractually regulated by “Statens Standardavtale” or “PS2000”, but also regulated by other “proprietary” contracts. Agile and standard contracts have a very different approach to how some of the key processes should be organized and handled, and this can be a mine field if the parties involved are unaware and neglect spending the necessary time initially regulating those areas especially. In this presentation we will give the audience an insight in the knowledge and experience we have accumulated from both small and large engagements.
Introduction – key elements of standard contracts (5 min) Potential conflicts between standard contracts and agile software development (15 min) Pitfalls and experiences (30 min) Q&A (10 min) Required experience: Experience from software development in general, and agile software development in special. A basic understanding of the most common contracts used in Norway is also required to benefit most from this presentation. Expected audience: Anyone who is in the process of adapting agile software development where “Contract Negotiation” still is a significant part of the work involved.

Our reputation as estimators –even when we us agile methods -- is bad. Agile methods provide useful techniques and practices for teams and their customers to improve accuracy without creating illusions of precision. Many of our estimation problems come from misunderstanding and miscommunication about what estimates are and confusion with other related concepts like planning and targets. Where do errors come from, what can we promise and how do we best serve the primary purpose of software estimation process?
Intro – a typical conversation about estimates. 5 min What is an estimate (accuracy, precision, … a glossary) (15 minutes with quiz) Estimation purpose and how much estimation do we need (10 min) Techniques for estimation (10 min) Techniques to talk about talk about our estimates  – perception management (10 minutes) Q and A – capita selecta Required experience: All levels interested in estimation – as estimator and as customer of estimates. Expected audience: All involved in estimation and planning processes and sales, managers and executives who expect and use the results of that process.

We started of with a brief project description sounding something like this: “Our current intranet is out of date and we need a new one to meet our current needs”. Together with the customers project manager we toured the company and performed a number of workshops and interviews, gathering only the high level information we needed to specify and prioritize the “most wanted” requirements as User Stories. Using techniques as Behavior Driven Development, User Stories, MoSCoW prioritization, Planning Poker and a lot of facilitation we developed the requirement specification, without tons of documentation and months of work. No thick documents. No nitty gritty details. Only simple and clearly defined goals, user stories, estimates and a high-level plan for the project well anchored with the sponsors – and employees. The project is accepted and will now continue with the detailing of user stories to acceptance tests for implementation along the iterations - until the customer has the intranet they need. This talk is about how an agile specification approach and a team based on trust can specify the necessary requirement in a few weeks with same – or better – results, as opposed to spending months on detailed documentation. By the time Tom does his talk the project will be done and he will share the actual results with you. Was this agile requirement specification approach really that good? What could have been improved?
OUTLINE Project background - (5min) The Challenge – “Our intranet is falling apart – we have no time to loose!” (10min) The Process – “We need to prioritize and figure out where we can start – without knowing all the details” (25min) The Result – “20 hand written user stories – will it do?” (10min) Q & A (10min)    Required experience: Experience from system development projects   Expected audience: Systems Developers, Project Managers, Technical Project Managers, Business Analyst

The results are in ... Many ideas in the Agile canon and folklore can actually decrease your velocity or can slowly posion your code. Other contemporary fads have well-known pitfalls that have been forgotten since their last round of popularity. In this talk I look at five of these common practices, why they are harmful, and how to avoid their pitfalls:
TDD: Use lightweight architecture and an appropriate scope of testing to avoid architecture rot, high test maintenance cost, and usability problems. YAGNI: Use Case Slices and lightweight architecture can help avoid being blind-sided On-Site Customer: Add a product owner to avoid burning out both the customer and the team. User Stories: Instead of deferring detailed scenario development to your development during TDD, use Use Cases to bring the analysis out to the person who matters: the market constituency Domain-Specific Languages: Take the value from the analysis and run with it; sometimes, building a domain engineering environment buys you only cost and headaches These remedies work well with each other. Required experience : Some level of immersion in an industrial software development project. Expected Audience and Benefits : These simple tips will help the audience think about and avoid common pitfalls. It's not rocket science, but it's solid information that can help projects avoid getting into trouble.

The most productive large software project ever documented with over 1,000,000 lines of code was delivered by distributed, outsourced Scrum teams based in the U.S. and Russia. It was linearly scalable, directly contradicting the "Mythical Man Month" assertion that adding more people to a project that was late makes it go slower. A CMMI Level 5 company has gone totally to Scrum achieving linear scalability, doubling productivity, and deliverling 40% fewer defects with higher customer satisfaction. This presentation will make the case that the larger and more complex the project, the more benefits achievable with Scrum.
Expected audience: People interested in hearing about the best scrums in the world.

This session will bring some clarity into the myths and reality of JCP and Open Source. - The "Magic Triangle" of a JSR - Licensing a Reference Implementation - Open JDK and JCP are just some examples of the topics that will be presented during this session.
Expected audience: all delegates

The world of software development is constantly changing and evolving. New ideas arise all the time and existing ideas go in and out of fashion. Software development processes find it very hard to keep up with this rapid rate of change, especially as they find themselves quickly going of fashion or becoming bloated as they bolt on more and more information. Teams find themselves struggling as they try to mix-and-match practices from various sources into a coherent way-of-working or work out where to start their improvements.
A new approach to capturing and sharing experience is required, one where: 1. Practices are First Class Citizens, 2. Practices can be made smart to truly help the developers in their work, 3. Practices can be used individually or in a multitude of combinations 4. Process is just a composition of Practices, and 5. Teams compose the process they need by selecting just the practice that they want to use To enable this a number of innovations are required: innovations related to the way that practices are collected, presented and applied. We will introduce the new paradigm and its support by EssWork which is an environment for working with practices. In doing so we will demonstrate how the Essential Unified Process is composed as a collection of eight separate practices. This talk promises to explore the outer limits of modern software development practices whether they come from the software engineering camp or from the social engineering (agile) camp.

Dårlige valg av metoder, teknikker og verktøy i systemutviklingsprosjekt kan ha alvorlige konsekvenser, for eksempel i form av lav produktivitet og kvalitet. Beslutninger ved valg av metoder og verktøy bør derfor i størst mulig grad være basert på gyldige forskningsresultater og systematisk innhenting og kritisk vurdering av erfaringer, dvs beslutningene bør være ”evidensbaserte”. Utgangspunktet for presentasjonen er at hyppig benyttede informasjonskilder, slik som guru-uttalelser, demonstrasjoner og referansekunder, lett gir et feilaktig bilde av gevinster og ikke minst at svært få innen IT-bransjen har fått opplæring i bruk av evidensbaserte beslutningsprosesser. Presentasjonen vil inneholde praktiske øvelser med formål å bedre deltakernes evne til å:1) formulere problemstillinger som utgangspunkt for valg av metoder, teknikker og verktøy, 2) innhente relevant og balansert informasjon fra forskning og praksis, og 3) vurdere informasjonens og argumentasjonens gyldighet i forhold til valg problemstilling.
1) Øvelsesoppgaver (10 minutter) 2) Eksempler på typiske prosessmangler ved valg av metoder, teknikker og verktøy. (5 minutter) 3) Kort øvelse relatert til vurdering av argumentasjon i tekst skrevet av høyt profilert XP-aktør. Brukes til å illustrere mangler mhp hvordan vi leser og vurderer argumentasjon, og hvor lett vi dermed blir påvirke av retoriske og markedsføringsmessige virkemidler. Gjennomgang av sjekklister og gode råd for hvordan vi bør vurdere argumentasjon av denne typen. (15 minutter) 4) Gjennomgang av stegene for evidensbasert systemutvikling. Applisert på valg av metoder og verktøy. (15 minutter) 5) Gjennomgang av øvelsesoppgaver fra 1) + spørsmål. (15 minutter) Expected audience: Utviklere, arkitekter og prosjektledere som ønsker å ta bedre beslutninger.

Open source software is used in almost all new software development projects. However, a strategy for contributing back to the open source communites is often missing. When talking to business managers and developers, one of the key questions is often "what is in it for me?". In this presentation I will address this question both from a programmer's and from a manager's perspective. I will also debate licensing and intellectual property issues and the process of how to get involved in open source development.
Outline Why contribute from a developer perspective from a business perspective The contribution process, how to get involved To fork or not to fork, that is the question Creating patches How to maintain patches while awaiting committer approval Licensing and IP issues Q&A - 10 min Expected audience This session targets business managers, project managers and software architects and/or developers curious of how to embedd Open Source in their business stragegies

PS: Send mail til totto@objectware.no dersom du har tenkt å delta på denne BOF-en!! Her blir det Governance in action, med både Govenors, Auditers, Policy Advisory Board, IT-sjefer, stressa prosjektledere og overarbeidete utviklere - og en vil få demonstrert effektene av brudd på viktige policy regler for både løsning og arkitektur. Med andre ord, så har vi et klassisk rollespill rundt arkitektur, design og konsekvenser i den virkelige verdenen.
Agenda: Utdeling av rollebeskrivelser til deltakerene Gjennomgang/intro av caset I: Designmøte rundt nytt krav o quick-fix strategien blir valgt II: Governance QA-møte, o nytt design i tråd med Governance Policies blir påtvungt prosjektet III: Prosjektmøte: o krisemaksimering fra prosjektleder, krigen starter IV: Prosjekteiermøte: o Governance policy blir klaget inn til Policy Advisory Board (PAB) V: Møte i PAB, o policy blir videreutviklet, incentiver og begrunnelse for regel blir forvaltet/videreutviklet VI: Prosjektmøte, o Policy blir ignorert av prosjektleder VII: Project retrospect o Gjennomgang av tid/kost viser sterkt svekket endringsdyktighet, og høy feilrate rundt implementering av det nye kravet

Som utvikler av en tjeneste er man interessert i når endringer gjør den inkompatibel med prosjekter som avhenger av tidligere versjoner. Vi vil presentere et konsept som går ut på å få bedre kontroll over slike endringer. Dette gjøres ved å kontinuerlig bygge prosjekter med flere versjoner av en tjeneste. Automatisering blir nødvending når antall prosjekter som er avhengig av tjenesten øker, og/eller vi ønsker å se på avhengigheter til flere tjenester. En Proof-of-Concept implementasjon basert på Continuum vil bli demonstrert. Tilhørerne kan forvente å lære hvordan avansert kontinuerlig integrasjon kan gi mer stabile tjenester. Vi vil også beskrive hvordan, og hvorfor, denne teknikken kan gi høyere tjenestekvalitet og bidra til økt gjenbruk. Stikkord: Kontinuerlig integrasjon, Continuum, Maven, komponent-orientert utvikling, versjonering
Skissere bruksområdet - Hvorfor er automatisering nyttig? (5min) Forklare konseptet - vise avhengighetsgrafer (10min) Svært kort introduksjon til teknologien utnyttet i PoC-en (Maven, Continuum og versjonering i Maven) (5min) o Egenskaper ved Maven og Continuum som legger til rette for implementasjon av konseptet Implementasjonen i grove trekk (10min) Vise demo (PoC) (10min) Nytteverdi (10min) Required experience: Grunnleggende kjennskap til Mavens Project Object Model (POM) og kontinuerlig integrasjon (CI). Expected audience: Utviklere og prosjektledere som ønsker å lære en ny CI teknikk.

Agile utviklingsprosesser har som utgangspunkt å tilby applikasjoner som er designet for å håndtere hyppige endringer i forretningsprosessene de skal støtte. Et av hovedpunktene i det agile manifestet, er å ønske endringer velkommen. Gjennom en iterativ utviklingsprosess skal applikasjoner utviklet gjennom en agile prosess raskt kunne tilbys kunden. En modelldrevet utviklingsprosess har som målsetting at man gjennom modellering skal kunne beskrive forretningsområdet som applikasjonen skal støtte. Videre skal man gjennom automasjon kunne transformere teknologiuavhengige løsninger over i et teknologispesifikt miljø, som så danner grunnlaget for genereringen av basisfunksjonaliteten i applikasjonen. Der den agile metodikken ønsker mest mulig ”hands on” gjennom hele utviklingsprosessen, baserer den modelldrevede metodikken seg i stor grad på automasjon. Dette er på mange måter to tankesett som står langt fra hverandre i innhold. Uansett, den uttalte målsettingen til begge utviklingsmetodikkene er å forbedre effektiviteten i prosessen og kvaliteten av det endelige resultatet. Siden begge metodikkene har den samme målsettingen, er det interessant å se hvordan man eventuelt kan bruke disse metodikkene - i en og samme prosses. Målsettingen til dette fordraget er derfor å se de på mulighetene man oppnår gjennom å kombinere agile utvikling med modelldrevet utvikling. Videre hvordan man kan nyttegjøre seg det beste fra begge ”leire”. Samtidig vil det bli rettet spørsmålstegn ved noen av de tradisjonelle ankepunktene knyttet til modelldrevet utvikling. Som f.eks at man trenger et veldig omfattende designarbeide i forkant av utviklingen, eller at kodegenerering tar bort friheten til den enkelte utvikleren.

Fjorårets norgesmester, Sindre Mehus, forsvarer tittelen i denne sesjonen hvor forskerne fra Simula kårer årets Norgesmester i estimering. Som i fjor blir det en interaktiv sesjon med intrikate oppgaver, og finalistene kan glede seg over gavekort fra byens bedre restauranter. Det blir også en kort demonstrasjon av hvor lett det er å manipulere anbudsrunder.
Expected audience: Ingen forkunnskaper er nødvendig.

Did you know you can run a Ruby on Rails application inside a Java Servlet container with the help of JRuby? Aslak will give a quick demo of how it's done and facilitate a discussion about why this is important for traditional Java shops

Maven er mer enn et vanlig byggesystem - det er et verktøy som kan gi merverdi rundt firmaets forettningsregler og krav. Ved å benytte de mer avanserte mulighetene Maven tilbyr er det for en organisasjon mulig å implementere og automatisere foretningsregler, som en integrert del av utviklingsprosessen. En sentral del av Maven er muligheten til å utvide funksjonaliteten ved bruk av plugins. Jeg vil i dette foredraget gi en introduksjon til hvordan man kan, med å skrive egne og/eller benytte seg av eksterne plugins støtte oppunder bedriftens byggebehov og forretningsregler. Eksempler på dette er kontrollering av lisenser, innføre krav til pakking av programvaren og validere/godkjenne tredjepartsbiblioteker. Jeg vil gi en oversikt over den utviklingen som skjer av Maven 2-plugins idag og hvordan man kan ta del i miljøet. I løpet av foredraget vil jeg gå i gjennom plugin-APIet og vise hvordan dette kan brukes til å utvikle plugins, som muliggjør praktisk inføring og garantering av regler som en del av en utviklingsprosess.

Ever since Struts, Web application development has changed : Web 2.0, and especially Ajax, has a big momentum, the introduction of JavaServer Faces in the new Java EE 5 stack has brought us new frameworks and concepts, while RAD has become a major factor to decision makers... Frameworks and tools available today have become more powerful, but also more complex. Hence choosing a framework for your web application has never been as difficult and important as today. Besides all these new functionalities, browser compatibility, URL friendliness, session management and the like remain as important to public web application developer as before. This session aims at sharing the information and experiences on frameworks available today, whether they builds upon Servlets or JavaServer Faces, but also those that will emerge in the future. We will emphasis on all the aspects of web application development and illustrate how different framework (such as Shale, WebWork aka Struts 2 and Rife among others) address those aspects in order to ease your web application development. This session will try to cover all different aspects of today's web-application development. Each aspect will be illustrated by how one of the available frameworks approaches it and solves it to enable the developer to focus on his part of the job: developing a high-quality web-application.

Hver 17. mnd kommer det en ny versjon av Java. Java Community Process er aktiv som aldri før - 700 personer/firmaer bidrar kontinuerlig til Java Spesification Requests. Nye språk kommer inn i den offisielle platformen (Groovy, JRuby, Scala) og et hav av rammeverk er tilgjenglig for deg som utvikler. Hvilke av de 323,000 treffene på "Java framework" i google er relevante? Hvilke av de 272,000,000 linkene om Java burde DU ha lest?
Sitter du i tidsklemma og sliter med å følge med? Få gode tips og kilder på hvordan henge med. Etter en kort innledning prøver vi i fellesskap å finne de beste metodene for å finne informasjonen, slik at du kan beholde nattesøvnen intakt.

Development tools, Software engineering lifecycle Being able to understand and maintain good project structure is the major requirement in large and healthy projects. At this BOF you will be presented a Dependency Structure Matrix - a scalable and highly efficient tool for visualizing and analyzing complex project dependencies. Various dependency patterns will be shown together with methods for coping with them.
Required experience: none

Har du en snikende følelse av at din trygge serielle hverdag er truet og at parallellisering antagelig er noe du bør ha et forhold til før eller siden, da er målet med denne enkle introduksjonen til parallellisering å kunne vise at dette ikke nødvendigvis trenger være veldig vanskelig. Noen ganger har man behov for å splitte opp større jobber for eksempel for å utnytte datakraften som er tilgjengelig over flere prosessorkjerner, prosessorer og servere. Teknikker, infrastruktur og rammeverk finnes for dette, men de er ofte komplekse å sette opp, vanskelig å forstå og påvirker designet i for stor grad. Jeg ønsker å gi en enkel (teknologi og produktuavhengig) introduksjon til parallellisering, hvilke forutsetninger som må være på plass for at oppgaver gjøres i parallell, noen problemstillinger knyttet til å parallellisere, teknikkene master - worker, og map og reduce, og eksempler på en del typiske problemer som er egnet for parallellisering. Dersom du allerede jobber med storskala parallellisering er nok ikke dette presentasjonen for deg, dette er heller ikke en presentasjon av googles MapReduce rammeverk. Etter en introduksjonen til parallellisering vil jeg beskrive noen konkrete problemstillinger fra BBS hvor vi har hatt behov for å parallellisere jobber. Jeg kommer til å forklare hvorfor vi trengte å splitte opp og parallelisere jobbene, hvordan vi gjorde det, samt hva vi oppnådde rent konkret ytelsesmessig.
* Intro * Noen teknikker for parallellisering * Problemstillinger knyttet til parallellisering * Eksempler fra BBS * Oppsummering * Q&A Language: Norwegian Required experience: None Expected audience: Anyone interested in parallell processing/programming, but with little or none practical experience with it.

Fri programvare handler om deling, gjenbruk og samarbeid - og flere store virksomheter velger nettopp åpenhet som sin viktigste innovasjonsstrategi. Fri programvare anslås å være en viktig driver for utvikling av framtidens løsninger og ha samfunnsøkonomisk betydning. Fri programvare gir lønnsomhet for kunder, leverandører og samfunnet generelt. Fri programvare representerer allerede store businessmuligheter i Norge, og Norden kan utvikle en sterk industri knyttet til fri programvare. Hvordan skape lønnsom innovasjon for kunder og leverandører?
Om Friprogsenteret: Friprogsenteret er en pådriver for verdiskaping i offentlig sektor og næringsliv. Som uavhengig kompetansesenter er vår oppgave å skape trygghet for valg, bruk og deling av fri programvare. Dette gjør Friprogsenteret ved å spre kunnskap, bygge nettverk og tilby arenaer for deling. Friprogsenteret eies av Troms og Buskerud fylkeskommuner, Rådet for Drammensregionen, Høyskolen i Buskerud, KS og IKT-Norge.

Did you ever want to be the Big Brother of the Java Virtual Machine? Being able to do non intrusive monitoring of method calls without access to the source code, performing this in a production environment without a noticeable performance hit? Do you want to know who is doing what to whom, that is, who invokes what method in context of which principal? Making certain that memory consumption is dynamically adjusted to avoid out of memory situations? Would you also like to use it in your legacy applications running pre Java 5 as well as utilize the new Java agent interface of the newer JVMs? You know you have to collect vast amount of data and process it effectively and in real time. Finally you figure out that the amount of data exceeds the capabilities of a traditional data model and you decide that the only solution is a dimensional data model, using MDX for multi dimensional analysis. There are numerous tools available for profiling and measuring your Java programs. However these tools are either: a) aimed at profiling or measuring your code in a development environment; b) expensive; c) not open source; d) requires a Ph.D. in debugging and profiling e) any combination of the above :-) Usemon (usemon.org) attempts to alleviate this by providing an open source tool which is easy to use, collects data from environments based upon Java 1.4 through 6, has a flexible dimensional data model stored in a SQL database and attempts to be non-intrusive. Usemon hooks into the Java virtual machine through a modified class loader on older JVMs or via the Java Agent Interface from version 5 and up. It automatically monitors Java EE components (EJBs, Servlets, MDBs, Queues, SQL Statements, etc), but can be configured to inspect any class in your JVM. Data is multicasted from agents to one or more collectors and stored in the DBMS of your choice. Usemon comes with a complete configuration for MySQL. The overhead of running Usemon is negligible and thus you may collect run-time statistics around the clock all year, which is rather fascinating, given that you have enough disk space. Usemon was developed for large Java EE environments at Telenor, which is one of the worlds largest telco to fulfill these requirements. You may utilize it in any environment in which you have control over the Java Virtual Machine start up parameters. For example Java EE applications, Spring based Web applications or simply your own home grown web application packaged in a .war file.
* Introduction * What sets Usemon apart from other profiling and performance measurement tools? * Modifiying the class loader using byte code manipulation * Architecture and extension points ** Using Soft references in the Agent to reduce memory consumption dynamically and letting the garbage collector (GC) to the job for you. ** Living in the Java virtual machine without affecting the production environment ** Collection of statistics and transmittal to the collector(s) using multicasting ** Receiving the collected data and insertion into a dimensional data model * Extending Usemon to your liking ** Usemon Live; A cool visualization app using the Processing (processing.org) framework and physics simulation model to show you what is happening in real time ** Dimensional data analysis, JasperServer to the rescue! * Q&A Expected audience Hard core developers with interest in performance and run time dependencies.

The Web as we know it is about to change. Welcome to the event-driven Web—a system that addresses the architectural flaws of the Web, and facilities uninitiated server-side messaging. That's right! The event-driven Web does not necessitate a "click" to deliver content. With this new paradigm, developers can initiate messages and events on the server—messages that are delivered to any type of Web client, including clients such as the iPhone, without the need for browser plug-ins or traditional polling. End-users receive streams of data, in real-time, making it possible to deliver data to clients as it arrives without the need to wait on a pool interval. Low latency delivery of information makes the Web an accommodating place for applications once thought to only be possible on the desktop, e.g., financial trading, auctions, sports betting, tools for analytics, business activity monitoring. To understand the concept of event-driven Web, you first must understand its origins, the technologies and requirements behind it, its place in your applications, and the pitfalls. In this session, we will introduce you to all of the above with special focus on the pitfalls related to reversing the Web with an event-driven paradigm. Considerations that we will discuss include connection limitations, network flooding, and scalability. In addition, attendees will be introduced to the various architectural options that are available to address these concerns. The techniques and technologies covered in this session include, but are not limited to Comet/Push implementations, Asynchronous Request Processing (ARP), and Java/JMS.
* Defining Real-Time Web * Correcting the Web (!) * Demo of Comet * HTTP Polling vs. Streaming * Scalability and Performance Concerns * Vertical Scalability * Horizontal Scalability * Message Distribution * DEMO * QA Required experience This session will go beyond Ajax with a dive into Java, so experience using Ajax and Java is required. Knowledge about HTTP is a plus. Expected audience This session targets anyone interested in providing realtime data over the Web using server-initiated message delivery and are looking for something that goes beyond, way beyond, boring chat examples.

With agile methodologies gaining adoption, organizations are quick to setup their CI infrastructure. Yet they soon realize that having a full CI strategy involves more than just a CI server. When is code being reviewed? Should the build break if a unit test fails? How to solve integration issues? Does your process need to go all the way up to releasing to production? In this Bird-of-a-Feather session we will share our experiences addressing these and more questions in large scale enterprise environments.
Required experience From none to years, this is a BOF, so you should just be interested Expected audience Anybody from developer to project manager

Lean and agile methods tell us to “see the system”. System thinking skills are important for all agile teammembers. However they are not part of our day-to-day toolkit we got in school or university. This session introduces the participants to 7 practical system thinking tools and visialisation techniques that will help us map and explore the dynamic complexity of our (software) projects. These tools can be used in retrospectives, kickoffs, to look at long term consequences of policies and choices. They support the (software) management process at all stages – from specifying problems, to construction and testing of hypothesis.
* Intro to systems and systems modelling (5 min) * Tradititional versus System Thinking skills (each 5 minutes – 35 minutes) ** Static -> dynamic (from focus on events to focus on patterns over time) ** System-as-effect -> system-as-cause (from viewing system as driven by external forces to ** placing responsibility for behaviour on internal actors who manage policies) ** Tree-by-tree -> forest thinking (from believe that really knowing depends on details to believing that we must understand context) ** Factors-thinking -> operational thinking (from listing factors of influence or correlation to understanding of causality and how behaviour is actually generated) ** Straight-line thinking -> closed-loop-thinking (from viewing causality as running one way to the effect of feedback and causes affecting each other) ** Measurement thinking -> quantitative thinking (from searching for perfect measures to accepting that we can always quantify but not always measure) ** Proven-truth thinking -> scientific thinking (seeking to prove to be right to recognizing frames and models have limited applicability) * For each of those skills we will present a good practice tool – model/drawing/brainstorm technique ** Dynamic thinking – behaviour over time diagrams ** System-as-cause – instead of blaming ask “how could those within the system make the system more resilient to external causes” – causal loop diagrams ** Forest thinking – focus on similarities rather than differences ** Operational thinking – ... * 20 minutes -- We will build a small model (requirements lack, change, shortcuts) with the participant (causal loop diagram) * 5 min> Q and A Required experience: Involvement in project at any level Expected audience: Managers, executotives, team leaders, scrum masters… interested in increasing their impact on systemic variable – quality, time to market…

In this talk we will attempt to summarize and share our experience from one year of developing commercial grade applications using JSR 296: Swing Application Framework. We will thoroughly cover the basics of Swing Application Framework, and dive into the most useful features, some best practices and potential pitfalls. Finally, we will reflect on the current state and future of SAF. The talk will act as a follow up on last years "Building Real Swing Applications", where we covered the fundamentals of building Swing applications. With more than twenty years of Java experience between them, this presentation will be given by Escenic's Harald Kuhr, lead developer of Escenic Content Studio, and Bouvet's Swing expert Yngvar Sørensen.
Language: Norwegian (slides in english) Level: Intermediate Required experience: Basic Swing programming Expected audience: Swing developers interested in learning about Swing Application Framework

Many are already convinced of it: the social network is bound to be the personal portal of tomorrow. Whether you are using MySpace, FaceBook, LinkedIn or Plaxo: expect a whole new wave of mini applications that are specifically build to use and access the sea of crucial information that hides in social networks. This talk will introduce you to developing applications for this exciting new world. No code. Just inspirations and all the links you can absorb to get going yourself. See you soon on FaceBook!

Software development is hard. It takes years to become a good developer and many more years to become an expert. How much of this time is necessary? Are there any shortcuts?
In his book 'Blink', Malcom Gladwell makes the case that experts don't "think through" problems when solving them, they arrive at solutions almost unconsciously. The thing that differentiates an expert from a novice is not the ability to "reason through" but rather the ability to see a problem differently than a novice would. This different way of seeing is something that experts arrive at through their experience and long periods of exposure to problem contexts. In this talk, Michael Feathers will work you through a set of examples and describe concrete strategies for cultivating design sense - the ability to instantaneously recognize appropriateness and inappropriateness in software design.

If you were the owner of an airline, what percentage of seats would you like to fill: 65% or 75%? If you were developing new components, what percentage should succeed: 50% or 100%? Surprisingly, a lean company would target the lower percentages and be more successful. How can this be? The first paradox of lean development is that by doing one thing at a time instead of trying to do many things simultaneously, everything will get done faster. The second paradox of lean development is that if you never fail, you never learn, and learning is the essence of product development. Come to this talk to hear why it is better to focus on throughput rather than utilization, and why you want to try lots of stuff and keep what works, rather than picking the winners in advance.
* Paradox 1: Thrashing, caused by overload, is much less efficient than leveling the workload and working at a regular cadence. * Queuing Theory applied to software development. * Six rules to reduce thrashing and speed software development throughput. * Paradox 2: Spending 10K on ten experiments is more likely to produce a winner than spending 100K on the best bet. * Set-Based design what it is and why it works * X rules to improve knowledge through exploring multiple options. Required experience General experience with agile development is useful. Expected audience Senior developers and testers, team leads, and managers. The objective is to get the audience to think, to challenge the assumptions that underlie how they organize their work, and experiment with new ways of organizing work to achieve dramatic improvement.

When the Spring framework hit the marked, it revolutionized the way we build our applications. Dependency injection, and inversion of control became well known terms, and it is difficult to imagine how we managed without them. But there is one aspect of the Spring framework that has been fiercely discussed for a long time; What is the best approach to configuring our applications for deployment in multiple environments? I have struggeled with this problem since my first encounter with the Spring framework, and over the years I have tried just about all the techniques there are. Some of them turned out to be bad - some of them turned out to be really bad. In this talk I will go through some of the techniques and approaches I have tried, and discuss their strengths and weaknesses. Based on these trials and errors, I have put together a framework that aims to enhance the Spring container - enabling it to be differently configured for different target systems. I will demonstrate how you can use this framework to make your applications dramaticly easier to configure, easier to test, and less prone to malconfiguration in production and test environments.
* The ultimate goal * Configuration techniques that failed miserably ** Using your build system for resource filtering ** JNDI as configuration repository ** Commons Configuration ** The evil PropertyPlaceHolderConfigurer * Introducing the Stage Enabled Spring Contexts project ** Brief introduction to annotation based configuration in Spring ** Choosing implementation of services based on the running environment ** Increase testablility ** Configuration options ** Handling property files * Customization options * Q&A - 10 min Language: English Level: Intermediate Required experience: Attendees will be expected to be experienced Java programmers with fairly good knowledge of the Spring framework. Experience with large scale enterprise applications would be a benefit. Expected audience: This session targets software architects and software developers, working on Spring based enterprise applications.

Utdanning og kompetanseheving er en kontinuerlig prosess, kanskje mer i IT bransjen enn i noen annen bransje. Nettopp derfor er det så viktig at kunnskapen formidles på en slik måte at alle har de beste mulige forutsetninger for å lykkes med å lære. Ulike roller og bakgrunn er med på å skape et komplekst bilde med lærende og lærere. Gjennom foredraget trekkes det paralleller mellom kunnskapsformidling internt i bedrifter, eksternt til kunder og til Bachelor studenter. Det pekes på utfordringer og muligheter knyttet til kunnskapsformidling og hva slags lærdom man kan ta med seg fra de ulike vinklingene. Man går også i dybden på den forskningsbaserte undervisningen som er et påkrevd fundament for alle høgskoler i Norge i dag og ser hvordan forskningsbasert opplæring kan være med på å gi kunnskapsøkning i bedrifter en ny dimensjon. Praktiske teknikker presenteres for å gi tilhørerne et konkret ”produkt” å ta med seg tilbake til egen hverdag. Gjennom presentasjonen settes det fokus på teknikker som forskningsbasert undervisning og hva det vil si både å gjennomføre dette, men også hva man får ut av det. I tillegg vies det blant annet tid til å se på prosjektbasert læring og prinsipper rundt scaffolding (stillasbygging). Norges Informasjonsteknologiske Høgskole (NITH) utdanner Bachelor studenter innen informasjonsteknologi og driver med forskning innen flere områder blant annet for å gi grunnlag for innovative og aktuelle utdanninger. NITH er den eneste høgskolen i Norge som har spesialisering på JEE5 og EJB 3.0 for sine programmeringsstudenter. I Mesan AS er det daglige utfordringer knyttet til kompetanseoverføring til kunder og andre eksterne aktører i prosjekter. Formidling av kunnskap er en av suksessfaktorene både for å kunne ha dynamiske, fungerende team og likedan for at man skal kunne ha en inkluderende dialog med kunde.
* Introduksjon Mesan og NITH * Formidling av kunnskap * Forskningsbasert kunnskap * Utfordringer ved kunnskapsformidling og opplæring * 3 ”best practices”, Forskningsbasert undervisning, Scaffolding og Prosjektbasert tilegnelse av kompetanse * Q & A

Domain-Specific Languages are an "architectural hot-spot", as coined recently by InfoQ editors. With dynamic languages such as Groovy, it is easy to create a mini-language modelling a particular business domain. Thanks to these DSLs, developers and subject matter experts will be able to share a common metaphor, to deliver, hand in hand, the final application to the end users.
Groovy offers a great deal of flexibility in terms of concise and expressive syntax, and through its dynamic nature. After an introduction to the Groovy dynamic language, and to the concepts of DSLs, their motivation, strenghts and weaknesses, Guillaume Laforge, project lead of Groovy and spec lead of JSR-241 standardizing the Groovy language, will guide you through the advanced Groovy concepts that will help you create your own embedded DSL. He will show you how to integrate them in your JEE application, and also explain how to best design such business languages to ensure their adoption by the end users, their quality, testability, andcapacity to evolve over time to suit the needs of the day. In the IT industry, understanding the domain within which customers evolve is a key factor in the success of a project. From this domain and its wealth of concepts, as software developers and architects, we can derive a design that is aimed at solving problems encountered in the day-to-day business. So far, we mostly solved these brainteasers with computer science paradigms like Object-Oriented Programming, n-tier architectures, or with tools such as rules engines to stay close to the domain at hand. In this session, our goal will be to investigate how the paradigm of Domain-Specific Languages can be leveraged to help our teams build solutions closer to our users' needs and requirements, and how it can provide a viable, efficient and expressive alternative problem-solving pattern. The technology of choice for enabling DSL solutions for your projects will be Groovy, a dynamic language for the Java platform.

This talk focuses on the ways that Groovy can turn a traditional Java developer's world-view upside down.
Summary We'll start by talking about how you can thumb your nose at The Man by leaving out many of the main syntactic hallmarks of Java: semicolons, parentheses, return statements, type declarations (aka duck-typing), even try/catch blocks. Of course, there's no way that we'd leave metaprogramming out of the discussion... What is metaprogramming? We'll add new methods to classes at runtime -- even if they were originally implemented in Java; even if they were declared final. (Thanks, ExpandoMetaClass!) We'll call methods that don't exist and avoid the dreaded MethodNotFound Exception. (Thanks, invokeMethod!) We'll narrowly scope our metaprogramming shenanigans using Use blocks and Categories, and then cast our changes to the wind such that every instance of a class gets our added juice. If you are happy taking the Blue Pill, this talk is not for you. You can continue using Groovy as a slimmed-down dialect of Java -- an "After" picture to Java's "Before". If, however, the Red Pill looks interesting, please join me. Remember, all I'm offering is the truth. Nothing more. Expected audience: This session is aimed squarely at Java developers. The more experience you have, the better, but even neophytes will appreciate what Groovy offers Java developers. Experience with other dynamic languages like Ruby, JavaScript, or Python will help, but certainly isn't required. Required experience: You should be comfortable with the basic syntactic rules of Java (so that we can mercilessly squash them). You should understand the basic "Laws of Java" when it comes to the semantics of a statically typed language (so that we can kick sand in its face). Most importantly, you should posses an open mind and a belly full of Dynamic-language KoolAid. This is not the forum for someone to vocally defend the merits of checked exceptions and static typing. You will be unceremoniously tossed out on your ear, Jerry Springer-style. Seriously. I'm not trying to convince you that this is the way you should write Java. The status quo can defend itself quite nicely, thank you very much. I'm here to show you how your code could look, if you so desire.

Amazon Elastic Compute Cloud (EC2) provides a fantastic way to deploy scalable machine images, but what to do when you want an application to scale across the machine images you have provisioned? This session discusses the Elastic Grid, an approach that provides dynamic allocation, management, and scalability of applications, using Amazon EC2 as the backbone. It also introduces the open-source technologies Elastic Grid is based on: Rio and Apache River (Jini™ network technology). The Elastic Grid provides an architecture for developing, deploying, and managing distributed applications composed of services. Key to the architecture are a set of dynamic capabilities and reliance on policy-based and quality-of-service mechanisms. The Elastic Grid reduces the complexity surrounding the development of dynamic services by introducing Jini network technology remoting for POJOs as well as by providing a simple component model. The Elastic Grid extends Amazon EC2's virtual grid environment, enabling users to manage and dynamically scale Amazon Machine Images (AMIs) based on declarable SLAs, as well as deal with partial failure of AMI instances. Rio reduces the complexity surrounding the development of dynamic services by introducing dynamic Jini network technology remoting for POJOs, as well as providing a simple component model. The presentation demonstrates how IntelliJ plug-ins for Amazon EC2 and Rio ease building and deploying a sample application distributed over the Amazon EC2 grid. With the Elastic Grid solution, the application will scale on the Amazon EC2 grid by starting and stopping Amazon EC2 instances accordingly to declared SLAs (service-level agreements).
Required Experience: None Expected Audience: Users of Amazon Web Services in need of a good solution for scalability and management of their applications.

Service Oriented Architecture is all over us. There seems to be some kind of consensus that one type of SOA services are services that are responsible for the core business objects - and vendors are monitoring and releasing their SOA Data Server products to close the gap. By pioneering the SOA space with EDR, we have gained lots of valuable of experiences of how to solve the Master Data challenges in SOA. This talk will discuss the main contenders for the ownership of your business objects definitions, and comment on their consequences - and then follow up with a "less is more" approach to enable companies to gain the combined advantages of all the platforms by extending the EDR pattern to also include Master Data Service (MDS) features.
* Introduction * Problem description * Solution strategies - strength and weaknes analysis * How to do more with less - EDR MDS concepts and tradeoffs * Experience reports * QA Required experience Intermediate knowledge of architecting and building SOA systems. Experience with Master Data Management chellenges and integration strategies. Expected audience Architects, Developer-leads and project managers.

Newspeak is a new programming language being developed at Cadence. Newspeak is directly descended from Smalltalk, with heavy influences from Self and Beta. Newspeak is a principled dynamic language, and incorporates lessons drawn from a decade of experience maintaining the Java language and VM specifications.
Newspeak takes the principle of programming to an interface to its logical conclusion: every operation in Newspeak is effectively a virtual method invocation. This includes references to fields, classes and superclasses. Classes my nest arbitrarily, as in Beta. Since all names are late bound, all classes are virtual; in particular, superclasses are virtual, so all classes act as mixins. There is no static state in Newspeak. Instead, top level classes act as module definitions, which are independent, immutable, self-contained parametric namespaces. They can be instantiated into modules which may be stateful and mutually recursive. Naturally, like its predecessors, Newspeak is reflective: a mirror library allows structured access to the program meta-level, including the ability to modify the code while it executes. Synergy between a small number of key design decisions makes for a language that is small, expressive, modular, and lays a foundation for security as well.

This talk focuses on integrating Groovy with your legacy Java codebase in a way that wouldn't raise an eyebrow in the most conservative of organizations.
Summary We'll look at the dramatic reduction in line of code you can achieve by simply flipping your POJOs to POGOs (Plain Old Groovy Objects). We'll talk about calling Java classes from Groovy, and calling Groovy classes from Java. We'll look at Groovyc, the integrated compiler that manages Groovy/Java dependencies without a hiccup. There are wild-eyed radicals out there telling you that Java is dead, statically-typed languages are passe, and your skills are hopelessly out-of-date. Those extremists are the same ones who don't bat an eye at throwing out years of experience to learn a new language from scratch, pushing aside a familiar IDE for a new one, and deploying to a whole new set of production servers with little regard to legacy integration. While this "burn the boats" approach to software development might sound exciting to some folks, it's giving your manager the cold shakes right now. What if I told you that there was a way that you could integrate seamlessly with your legacy Java code, continue to use your trusty IDE and stable production servers, and yet take advantage of many of the exciting new dynamic language features that those fanatics keep prattling on about? You'd probably say, "Groovy!" I would, too... Not once will I tell you to throw out the old in favor of the new. In each case, I'll show you how to integrate the new with the old. Don't throw out your Ant build scripts; mix in a bit of Groovy to spice 'em up. Don't toss out your existing unit tests. (You are unit testing, aren't you? AREN'T YOU?) If not, Groovy is the perfect excuse to get started with a new language in way that improves the quality of your Java application without actually putting the new code into production. That is, until you get hooked on doing things the Groovy way... If the Red Pill of Dynamic Languages scares the pants off of you (or your manager), don't worry about it. The Blue Pill still offers plenty of benefits. There is no other language on the JVM that offers you the level of deep Java compatibility such that you could rename your "dot J-A-V-A" files to "dot G-R-O-O-V-Y" and not skip a beat. Of course, they both end up with a "dot C-L-A-S-S" extension at the end of the day, so there's good chance that no one would ever be the wiser anyway. Groovy: funny name, serious software, and Java through-and-through. Expected audience: This session is aimed squarely at Java developers. The more experience you have, the better, but even neophytes will appreciate what Groovy offers Java developers. Required Experience: Nothing more than standard Java knowledge.

Scrum was designed to achieve a hyperproductive state where productivity increases by 5-10 times over industry averages and many collocated teams have achieved this effect. The question for this presentation is whether distributed, outsourced teams can consistently achieve the hyperproductive state. In particular, can a team establish a localized velocity and then maintain or increase that velocity when distributing teams across continents.

Building sexy software that users love is usually a challenging endeavor. The open source Flex SDK and Java are a perfect combination of technologies for building rich, sexy software - for the web and the desktop. Flex applications can run in the browser using the ubiquitous Flash Player or on the Desktop using the new Adobe Integrated Runtime (AIR). In both instances Java can be used for the back-end of the application. The communication between the Java back-end and Flex front-end can utilize a number of different communication protocols, but the easiest and best performing is the open source BlazeDS library. This session will cover the basics of using Flex, Java, and BlazeDS to build sexy software for the web and the desktop.
* Intro to Rich Internet Applications (10 min) ** RIA as the next generation of Software ** Back to the Client-Server Model ** Adobe's RIA Software Development Platform * Intro to building software with Flex (20 min) * What is Flex? ** Open Source SDK ** ActionScript & MXML Languages ** Components * How do you use Flex? ** Compiler ** Debugging * Intro to BlazeDS (Java Integration) (20 min) ** Installing BlazeDS into a Web App (WAR File) ** Remoting (RPC style object invocations over HTTP) ** Pub/Sub Messaging * Questions (10 min) Required experience Web app or Desktop app development Expected audience Developers who want to build better UIs


Development is about more than writing code. It is even about more than writing tests! In order to produce something of value, we have to deliver reliable software into production. In an organization where the consequence of failure is great, we need to make sure that what we deliver works as intended. At the same time, even in a seemingly static world, many problems are hidden until the very end of the project. To make matters worse, complex technology and organizational processes inhibit our ability to act to new information with sufficient speed. The talk shows how we can implement a rigorous, yet agile process. It is based around our experiences of putting the good idea of continuous integration and other agile methods into life and using this as the basis not just for the technical process, but for the whole improvement program for our organization. We have expanded our process to cover simulated production as a part of the testing effort. This way, we can guarantee that the actual delivery day will be uneventful. The audience will come away from the talk with a good idea on how to improve their build process. The talk will cover both practical aspects, architectural changes that improves continuous integration, and what change you need to make in your organization to streamline the value chain from a code change to production readiness.
Required experience: The participants should have worked with Java in an enterprise context or had architectural responsibility for such a project. Expected audience: Architects and developers will come away from the session with an understanding of what part of the agile hype is real, what it requires to adopt, and how to get started.

Scala fuses object-oriented and functional programming concepts into an elegant, statically typed programming language for the Java Platform. The name Scala stands for "SCAlable LAnguage."
It is scalable in the sense that it is designed to be useful in a wide range of tasks, scaling up to very large programs written by many people and down to short scripts written by individuals. The conciseness and expressiveness of Scala gives it the feel of dynamic languages such as Python or Ruby, but Scala also provides a rich static type system that can help programmers prevent errors. In this talk, Bill Venners will give an introduction and overview of the Scala programming language.

Thomas J. Watson (sjef for IBM ) skal ha sagt: "I think there is a world market for maybe five computers”. I tiår har folk ledd av dette utsagnet. Amazon lanserte i 2006 en løsning for ”Elastic Compute Cloud (EC2)”, dvs. virtuelle maskiner til leie. Fortsetter utviklingen med stadig mer bruk av EC2 er det ikke sikkert at Watson tok så feil…
Mange løsninger basert på moderne Java-arkitektur har behov for å lage skalere ytelse takt med at behovet vokser. Dersom man har et høy ytelseskrav (100 eller 1.000 vis av transaksjoner pr. sekund) krever dette avansert og kostbar infrastruktur med mange servere og gjerne eget lagringsnett (SAN). Som Java utvikler gir dette en utfordring i forhold til hvordan man skal få utviklet og testet en slik applikasjon. Hvordan vet jeg at valgt arkitektur skalerer utover et par testservere? Hvordan vet jeg at løsningen skalerer i produksjonsmiljø over tid når volumene vokser? Dette foredraget gir et praktisk eksempel på hvordan man kan bruke Amazon EC2 som skalerbar infrastruktur for en Java Servlet basert applikasjon. Foredraget forutsetter ingen forkunnskap om EC2 og vil gi en kort introduksjon på hva EC2 er, hvordan det virker og hva man kan bruke det til.

Apache Tapestry is an open source Java framework that combines the best features of two worlds: the heavy-duty performance and scalability of Java (not to mention its enterprise acceptance) with the productivity advantages of scripting languages such as Ruby. Java has emerged as the language for enterprise-class development: it has the widest adoption, the largest class libraries, the best performance, and greatest degree of enterprise acceptance ... and yet, traditional web development is a painful, unproductive slog: large amounts of configuration combined with constant recompiles and redeployments. Python and Ruby can be vastly more productive than Java but can't match Java in terms of performance and scalability, or acceptance in the enterprise. Tapestry bridges the gap between these two worlds. It embraces convention over configuration on many levels. It enhances productivity with live class reloading (changes to classes are picked up without a redeploy or restart) and best-of-breed exception reporting. Tapestry classes and templates are small, simple and immediately understandable. Tapestry applications are fast, efficient and highly scalable. Tapestry lets you work in terms of your objects and your methods: you can build entire applications and never think about a URL or a query parameter. Things just work! Tapestry is a component framework; we'll see how the built-in components provide broad functionality and yet are extremely extensible. Many of the components have built-in Ajax functionality, and building your own components is a snap. This session will feature live demonstrations and even a bit of live coding. We'll demonstrate how Tapestry keeps you happy and productive like a Ruby or Python coder but still delivers the results your boss and your customers need.
* Introduction * Action vs. Component Frameworks * Tapestry Pages and Components * Building a basic CRUD Form * Customizing the CRUD Form * Processing a Form Submission ** Event Propogation ** Return Values * Using the Grid Component * Customizing Grid Columns * Linking to a Detail Page * Using Ajax with Tapestry ** Autocomplete Field ** Dynamic Ajax Zones * Other Tapestry Topics * Conclusion * Q & A Required Experience: Basic understanding of Java, HTML and XML Expected Audience: Java web developers

FitNesse is becoming a buzz word in the Agile community. People have seen it used in small examples, but may not think it is appropriate for their project. This session will show how it has been a great success factor in a critical Norwegian banking project at BBS, and how it was valuable to both developers and domain experts. The talk will present technical tips and tricks with code examples for writing reusable and maintainable tests and code. It will take you through the obstacles we met along the way, and how we overcame them.

Project Hydrazine was announced at JavaOne'08, by Sun Microsystems Inc., to accelerate the development of Rich Cloud Applications (RCA) that deliver rich content and user experience across the four screens of a consumer life (PC, mobile, setop-box, TV, car).
Project Hydrazine provides a hosted developer platform with service-enablers, cloud service runtime, and Netbeans JavaFX tools to rapidly develop and deploy personalized, contextual and blended RCA applications. Project Hydrazine hosted runtime environment leverages Sun's unique open-source software infrastructure (OpenSolaris, Glassfish, mySQL, OpenSSO, OpenDS and OpenESB) to deliver an open, secure, scalable and reliable cloud runtime environment. In addition, Project Hydrazine will provide an extensive repository and catalog of services. These include foundation infrastructure services as well as ISV and community developed services. This talk will discuss the state of the art of cloud computing, differentiate Project Hydrazine approach versus Amazon's EC2 and Google's App Engine cloud computing platforms. The talk will present Project Hydrazine architecture and service-enablers, and demonstrate how to create and deploy new Hydrazine services.

Code coverage is a lousy test quality indicator. Mutation analysis and testing, on the other hand, provides a better technique to improve your tests. This involves mutation of source code by introducing or modifying statements in small ways. The purpose is to develop effective tests or locate weaknesses in existing tests. This session gives an introduction to mutation testing, available tools and techniques. The content will consist of many examples, demonstrating mutation testing and the effectiveness of this technique.
* What is mutation testing and analysis? * A few of examples setting the stage * An overview of mutation operators * Tools and integration with the IDE and build system * Mutation test demonstrations * Summary - Guidelines and caveats * Questions Required experience Knowledge of Java programming and testing is recommended. Expected audience This will be a techy session targeting developers and architects.

This talk will focus on a special kind of wicked software projects - enhancement projects. They are very common and generally overlooked. Wicked enhancment projects exhibit many of the following characteristics: * The project is delivering something like version 5.7 or 6.0 of a successful software product * There is a large, buggy, legacy code base with little documentation * There is a large number of product variations (configurations) * The customer and user base is large and inhomogenous * The original development team is long gone ** Sponsor/general management has lost interest (until something goes wrong) ** The current development team is doing all of support, O&M, and fresh development ** Activities other than developent consume a significant portion of the effort ** The developer motivation is low (churn is high) ** There is a high number of external dependencies ** Requirements are volatile ** Firefighting is the norm – defined processes are missing or frequently circumvented Enhancement projects are especially hard because their origin is a successful product. The risk is generally high (chance of jeopardizing the whole customer base), but not treated as such. Success is expected, but many of the mechanisms for ensuring success are not in place.
The presentation will give practical advice on how to manage such projects, and will cover: * What wicked projects are * The life (and death) of a software product ** Handling support and O&M in parallell with development work ** Improving quality ** Handling bugs, requirements and releases ** Handling estimation, planning and monitoring of progress ** Handling expectation management and communications in general ** Handling external dependencies We will focus on presenting practices that have proved beneficial in projects of this kind, and that should be part of any project manager's toolbox. Some practices we'll cover are: * Bug-Driven Development: Using bugs to improve overall code quality * Don't Estimate - Timebox. When not to estimate * Don't Judge - Count. Improving estimates by freeing developers from time estimates * Pay your debt: When and how to work off technical debt * Two-page Architecture: Sufficient technical documentation * Information Gatekeepers: Preventing information overload and thrashing * Prioritized Feature List: Controlling volatile requirements * Planning Horizons: How much to plan Language: English Level: Intermediate Required experience: Project management (software development) Participation in software development projects Expected audience: Project managers, project owners, other project participants

Good tools for automated web-testing have been around for quite some time, and many projects are starting to include them as a part of their build-process. We started using web-tests on Storebrand's online insurance-application back in autumn 2006, and the project is still supported by web-tests this very day. The talk gathers on experiences from this and various other Objectware projects, putting together a good bunch of experiences, recommendations, guidelines and hints for getting your project's web-testing in order. Topics include: * Why web-tests are evil! * When should you NOT use web-tests * How many web-tests should you maintain? * How you can get the users to report bugs by writing tests for you * Getting a CI/testing server to run the tests for you * Combining web-tests with FitNesse acceptance testing * Behaviour Driven Development using RSpec with web-tests * Project testing strategy (and where web-tests fit in)
* Background ** A trip down memory lane in Storebrand: How did we get started? ** How we learned to love web-testing, and ** How we learned to hate it. * Web-testing practices ** Testing the web and nothing but the web ** Black-box testing ** Acceptance/system testing ** Integration testing ** How to fit web-tests into the rest of your test-model ** How web-tests can give you good URLs and HTML design ** Running web-tests on the Continous Integration server ** Getting your users to help out: delivering bug reports with test-scripts ** Test fixtures * Advanced web-testing ** Acceptence web-testing combining FitNesse and Selenium ** Behaviour-Driven Development with web tests (Selenium combined with the RPsec Story Framework) ** Web tests from a test strategy perspective ** How to scale (with Selenium Grid) * Pitfalls ** Too many tests ** Too slow tests ** The tests break all the time! ** Some refactoring breaks all the tests ** Using web-tests for everything ** How to combine system testing with manual testing ** Capturing system requirements in web tests * QA Required experience: No particular experience is strictly required, but having tried out some web- testing tool could be an advantage. Expected audience: * Web developers * QA/testers * People interested in testing in general By attending this presentation, participants will learn... * How to get started with web-testing * How to keep doing it successfully * How to use web-tests as part of an agile project

Resource Oriented Computing systems process resource representations, execute transformations and computations by defining processing in terms of compositions and asynchronous sequences of resource requests. Application development and deployment using SOA faces problems when organizational changes occur if the participating systems (service providers and consumers) are too tightly coupled. In SOA, messages and systems are inherently synchronous, promoting dependencies that filter to the organizational level. Resource Oriented Computing solves system and application integration issues by leveraging ESB, domain-specific languages, and shared memory mechanisms for integrating coupling points, not the applications themselves, by promoting event-driven interactions between system components, and by creating logical mappings of resources such as data or computations that are abstracted from the physical manifestation of the system deployment.
Who should attend * Infrastructure architects * Application architects * Senior developers * Application development managers Why do attendees need to be aware of this information today? * Systems are built through the integration of decoupling points via ESBs, domain-specific languages, and shared memory mechanisms instead of direct integration of services, which is less flexible and more expensive in response to workflow or organizational changes * Event-driven systems allow for shorter time-to-market application development and integration independently of organizational changes * Treat computational resources as addressable entities (i.e. via object references, URIs, callbacks, etc.) that may be consumed on-demand rather than being intrinsically tied to specific applications * Event-driven systems can be implemented by leveraging existing infrastructure and SOA investment * Balance open-source vs. commercial products to avoid lock-in that results in higher costs and little or no flexibility during integration What basics should attendees know before attending this session? * Enterprise service bus * Basic understanding of distributed data caching technologies * Enterprise integration patterns and SOA * Event-driven distributed programming basics * Java 5 or later * Domain-specific language basics What problem(s)/challenge(s) will an attendee learn to solve by attending this session? * How to develop complex applications within very tight deadlines by formalizing system integration around a resource-oriented model * How to turn SOA-based systems into callbacks, breaking the rigid provider/consumer model * How to develop event-driven applications based on technologies and services already in production using a multi-language approach * How to integrate the existing applications by applying event-driven rather than centralized control techniques * How to extend SOA beyond transactions to include workflow processes and lossless transformations of resources from one representation to another What else will attendees learn by attending this session? * Real world applications that use Mule ESB, OpenSpaces, Terracotta and OSGi * Examples of architecture, service objects, configuration files * Approaches to solving distributed data caching

The revered Enterprise Integration Patterns (EIP) book is indispensable for handling messaging-based integration, but utilizing these patterns in your own code can be tedious, especially if you have to write the code from scratch every time. Wouldn't it be nice if you had a simple API for these patterns that makes this easier? Enter Apache Camel, a message routing and mediation engine that provides a POJO-based implementation of the EIP patterns and a wonderfully simple Domain Specific Language (DSL) for expressing message routes. This session will introduce and demonstrate the power of Camel. So go on, take a Camel ride!

In the current programming culture we have lost the OOP idea of objects containing both logic and state, the idea of reuse has largely failed due to impractical mechanisms, and combining pieces of code into larger structures using AOP has not quite delivered on its promises. Building large-scale software also gives us challenges with regard to complexity, enforcing architectural rules and codebase explosion. What if we could look at what we have and figure out a new way to address these problems, while promoting the idea from domain oriented modeling and retaining what works with what we have now? Composite Oriented Programing is a new way of dealing with these problems, and this presentation will show how the Qi4j implementation on the Java platform will enable you to get more done with less work, and in a way that allows you to avoid the mentioned problems. It will describe the COP terminology and show examples on how to use Qi4j to implement domain oriented models.
Suggested experience AOP, EJB, DDD, Java Expected audience Developers who want to understand what COP and Qi4j is all about should go. Understanding and using Qi4j will give developers a new tool that enables them to more easily write reusable code using the concepts from Domain Driven Design.

Alternative språk til Java som kjører på VMen er i vinden om dagen. Groovy, Jython og JRuby er eksempler på populære språk som fler og fler eksperimenterer med, og som bransjen er iferd med å ta i bruk. Felles for disse språkene er at kildekoden blir kompilert til Java Bytecode før den kan eksekveres på JVMen. Målet med dette foredraget er å gi en oversikt over veien fra kildekode til kjørende bytecode. Dette foredraget starter med en rask gjennomgang av kompilatorteknikk, etterfulgt av en gjennomgang av den fullstendige implementasjonen av et enkelt eget-utviklet språk - som kjører på JVMen. Vi vil forklare hvordan vi parser kildekoden og sjekker syntaktisk korrekthet. Neste steg blir å vise hvordan man genererer Java assembly-kode, som vi deretter bruker for generering av eksekverbar bytecode. Foredraget vil være en teknisk sesjon, med live-demoer av kjernekonseptene. Vi vil runde av foredraget med en kort diskusjon av mulige motiver for å ville utvikle egne språk for VMen.
* Kompilatorteori * Fra kildekode til bytecode ** Lexing ** Bygging av AST ** Semantikk ** Generering av bytecode * Motivasjon * Oppsummering Language: Norsk Level: Intermediate/Advanced Required Experience: Deltakerne vil ha en fordel av god forståelse av JVM-plattformen. Expected Audience: Utviklere som er nysgjerrige på hvordan språkene til plattformen vi jobber på til daglig fungerer.

In this session we'd like to show future and current state of Java ME development and also talk about incoming new mobile standards like MIDP 3.0. Major part of this session focus on the demos about Java ME development.
Subjects of this session *Present: ** Visual Mobile Designer for MIDP, Game Builder for Game API, Databinding library for Java ME, Device fragmentation solution, Deployment, Support for SVG *Future: ** Support for Open Source and non Open Source Java ME platforms: PhoneME, MicroEmulator or Sprint Titan ** MIDP 3.0 ** Visual Databindings * Why is Java ME so difficult * Give us some tools * Making better and nicer applications * Future of Java ME * Q & A

Some of the promises of Topic Maps, is the possibility of being able to easily structure and rearrange the model, as well as placing semantics where they are needed. Implementing such a dynamic and rich model, is not easy with an Object Oriented language like Java. The proposition of the authors, is that one can assist composing a song from audio fragments with the help of simple heuristics. Given that the audio is tagged with human recognisable information such as verse, refrain, lyrics, speed, starting and ending points. Storing such diverse information in a Topic Map is fairly trivial, but creating a dynamic Java model which can represent this is not, and the talk will discuss this topic further. The audience will be introduced to simple concepts of Topic Maps and music composition theory. The talk will finally present Vaudeville, the deliverable of the Customer Driven Project, made by students at NTNU. Vaudeville showcases Java technologies, assisted music composition and other concepts behind the project.
* Structure of the talk * About the authors * Aerobic Instructor/Deaf Composer - User Stories * Short introduction to fundamentals of music composition and DJing * Tagging music fragments with human readable information * Why working with Topic Maps is different * The problem of implementing rich models in OO * Creating a dynamic model from Java objects, while keeping complexity low * Presentation of Vaudeville - The DJ´ing application created in KPRO * Questions Expected audience Anyone interested in multimedia, Topic Maps and Object Oriented theory The audience will be introduced to simple concepts of Topic Maps and music composition theory. Basic knowledge of Object Orientation is preferred.

Mario Aparicio og Eirik R. Larsen fra Ciber presenterer erfaringer med bruk av webrammeverket Seam og prosessmotoren jBPM. VRVask er et system utviklet av CIBER Norge for validering, manuell korrigering, og rapportering av store antall banktransaksjoner. Systemet er todelt og består av en batch-applikasjon og en web-applikasjon som kommuniserer gjennom en felles database. For utvikling av web-applikasjonen ble webrammeverket Seam valgt. Bakgrunnen for dette valget er Seams abstraksjon av request / response modellen og støtte for lange brukerinteraksjoner, conversations. Batch-delen av løsningen ble utviklet som en standard Java-applikasjon med Spring og Hibernate. Vi opplevde Seam som et godt valg av rammeverk for web-løsningen da det gav enkel integrasjon mellom webgrensesnitt, domene og database. På enkelte områder støtte vi imidlertid på utfordringer som muligens kunne vært løst bedre med andre rammeverk. I utviklingen av batch-løsningen var Spring og Hibernate velegnede rammeverk for håndtering av database og dependency-injection. Derimot fikk vi problemer med håndtering av tilstandslogikk i batch-prosessen. Kompleksiteten ble undervurdert, og vi endte opp med å lagre tilstand i databasen og håndtere all tilstandslogikk programmatisk. Løsningen ble derfor vanskelig å utvikle og vedlikeholde. Etter å ha analysert problemene i batch-løsningen så vi at en prosessmotor med fordel kunne brukes for å håndtere tilstand. Vi valgte å se på prosessverktøyet jBPM da dette er et mye utprøvd verktøy som fungerer bra i et Java-miljø. jBPM er i tillegg godt integrert med andre JBoss-produkter som Hibernate og Seam. I presentasjonen beskriver vi positive og negative erfaringer med Seam i prosjektet og drøfter når det er fornuftig å bruke dette rammeverket fremfor andre web-rammeverk. Videre presenterer vi hvilke fordeler vi kan oppnå ved å bruke jBPM, og hvilke alternativer man har når man skal innføre et slikt verktøy i tilstandsfulle applikasjoner. Til slutt vil vi fremføre eksempler fra opprinnelig løsning og løsning med jBPM.
* Introduksjon * Presentasjon av nåværende løsning ** Forklare applikasjon og arkitektur ** Forklare hvordan Seam brukes i web-applikasjonen *** Hva fungerte og hva fungerte ikke ** Forklare hvordan batch-applikasjonen er implementert *** Problemer med applikasjonen * Presentasjon av utvidelse: jBPM ** Hvilke fordeler gir et prosessverktøy som jBPM gir ** Alternative strategier ved bruk av et prosessverktøy ** Forklare hvordan jBPM integreres med applikasjonen * Eksempel: ** Vise demo av opprinnelig applikasjon ** Vise eksempler med jBPM Required experience: Grunnleggende forståelse av Java EE utvikling. Expected audience: Utviklere med interesse for enterprise- utvikling og arkitektur.

Debugging of Swing application is not always easy because it is visual toolkit and in many cases you can not just write an automated test that checks if your UI looks good, all components have right sizes, all necessary information is visible and painting done correctly. The presentation will cover some common difficulties connected to visual nature of Swing toolkit and provide fast solutions for solving them using Swing Explorer tool developed as open source project https://swingexplorer.dev.java.net. You will learn how to answer the following questions: Which component painted this pixel? In which line of code? Does your application access Swing from the correct thread ? How does Swing perform painting step by step? And even more... If you are experienced or beginner in Swing and want to increase your productivity this session is for you. The session is going to present the latest debugging know hows appeared this year.
Expected audience: If you are experienced or beginner in Swing and want to increase your productivity this session is for you. The session is going to present the latest debugging know hows appeared this year.

Java SE is on over 90% of desktops and Java ME is on over 90% of mobile phones. Java is also making a big dent in the consumer space such as set top boxes, Blu-Ray Disc players and so on. Although Java client technology is ubiquitous, consumer applications are not because development and deployment for consumers is still too hard.
The talk will explore the features that are being explored to create leaner and meaner JRE that eases deployment and installation. The features that are being looked into will ease start-up time, provide a quick launch and on-demand installation, among other things. The talk will explore the Java Kernel and other features that ease applet and application instantiation and deployment. We will also look at features that enable building richer client applications with Java SE 6 Update 10. The talk will also look into features of Java SE 7. After attending this session attendees should be able to walk away with a good understanding of where the Java SE platform is headed and how this should ease their development and deployment concerns for consumers.

The topic of this presentation is about fastest growing open source Java grid computing framework called GridGain and how its focus on elegant simplicity and Enterprise Java integration is helping to revolutionize the grid computing for Java in the same way as Spring or JBoss have changed Enterprise Java landscape. The presentation will start with an introduction to grid computing and specifically data and compute grids. MapReduce will be discussed. Real-life examples will be discussed as well as common pitfalls, patterns and anti-patterns of using grid computing in real life. After introduction a comparison between GridGain and Hadoop (another popular MapReduce implementation) will be given with usual pros and cons of both projects. To underscore the topic of presentation it will also include live demonstration of writing a simple application and grid enabling it to run on a small grid right in front of the audience. All coding during demonstration will be done live. Detailed and in-depth explanations will highlight that grid computing in Java can be fun, simple and productive to use in everyday applications and systems.
* Introduction * What is Grid Computing? ** Compute grids (MapReduce) ** Data grids * Why is Grid Computing? ** Real-life examples ** When to use grid computing? ** When NOT to use grid computing? * MapReduce: GridGain vs. Hadoop ** Pros and Cons * What is GridGain? * Key Features * Live coding demonstration * Conclusion * Q&A About GridGain: GridGain is the fastest growing open source Java grid computing framework. In the first 6 months since the first release in august 2007 GridGain has been downloaded over 15000 times, used by more than 500 unique projects and grid node with GridGain starts somewhere around the globe every 60 seconds. GridGain has active production and testing users on all continents and in over several dozen different countries. GridGain project has financial sponsorship of GridGain Systems that sponsors the development and provides commercial services around it. Required Experience: * Java 5 * Basics of AOP Expected Audience: Audience is expected to include developers, architects and technical managers who are interested in grid computing technology that breaks away from traditional mold and makes Java grid computing fun, simple and productive to use. We are expecting this talk to be really interesting and popular among the attendees as it includes a live end-to-end demonstration of something that not so long ago would require weeks and months of just configuration and was part of only privileged projects in the government research and large corporate sectors.

Det utarbeides flere og flere selvadministrasjonsløsninger og det er et sterkt behov for å lage løsninger som gjør det mulig å tilby selvadministrasjon også får svært sensitive opplysninger, for eksempel helse opplysninger eller lignende. Data lagres ikke lenger i siloer slik som før og slik som Datatilsynet gjerne skulle ønske det. Denne presentasjonen gir deg konkrete råd om hvordan du kan lage et system som vil bli godkjent av Datatilsynet. Foredaget vil ikke bare ha hovedfokus på java men den omkringliggende infrastrukturen som er nødvendig. Utviklere vil få forståelse av hva som bør være deres ansvar i en applikasjon og hva infrastrukturen bør støtte dem med for at systemet skal håndtere alle risikoer.
* Innledning * Typisk oppsett for en SOA løsning * De mest aktuelle problemstillingene en SOA løsning står ovenfor * Hvilke krav stilles igjennom lover og forskrifter? * Datatilsynets råd og anbefalinger til løsning * Løsningsalternativ * Oppsummering Required experience Erfaring fra systemer med kompleks infrastruktur eller erfaring fra større utviklingsprosjekter Expected audience Software Architects, Senior developers

Rich Applications has achieved a new degree of sophistication with requirements to add multimedia and animation. With the introduction of the new JavaFX SDK and Java SE 6 update N, it is possible to incorporate the newer elements of a very rich client application into new and existing Java applications. Attend this session to get a very brief overview of the JavaFX programming language and the animation and media APIs that make it possible to create some sexy looking GUIs which was hitherto difficult in Java. After attending this session, attendees will walk away with a good understanding of JavaFX and Java SE 6 Update N and how to incorporate the features, such as audio, video and animation into their applications. They will also get an idea of the deployment options i.e. applets or applications.
* Overview of JavaFX 5 mins. * Language features (binding, sequences, etc.) 10 min. * Animation 15 min. * Media and support for media types 15 min. * Deployment 5 min. * Q&A 10 mins. Language: English Level: Intermediate Required experience: 2-3 years of Java development experience especially w/ rich client apps. Expected audience: Java developers

Stadig flere applikasjoner finner veien til mobiltelefonen. Kundene forventer lik (eller bedre) sikkerhet på applikasjonen når den er på en mobiltelefon som når den er på en vanlig PC. Java ME er kjent for ha en svært strikt sikkerhetspolitikk med høy grad av ”sandboxing”, men er dette nok for å lage en sikker applikasjon? Hva er det egentlig som skal til for å lage en sikker applikasjon, og har Java ME det som trengs? Hva med "write once, run everywhere”? Foredraget vil gi en oversikt over hvordan man lager sikre applikasjoner i Java ME med innslag av nyttige erfaringer og fallgruver.
* Introduksjon: * Signering av MIDlet * Sikker kommunikasjon i Java ME * Sikker lagring * Spørsmål og svar

4 years ago one had to spend literally millions of NOK just for the publishing rights to implement a good map solution with a detailed map of Norway. Additionally, many projects had a complex client combining javascript and a server side component for displaying the map in the browser, and probably a back end for rendering the maps. Then in 2005 Google launched Google Maps, opened its API, and one could add a map to a project in minutes. Decent map quality, free client and no need to pay a fee for publishing rights.
* Introduction ** What's in it for me! Why is an open source map client interesting? * A few concepts ** Projections. Why it matters, and what you need to know about it. ** Libraries for projections, proj4 and derivatives. A short, short ** slide about the math. * Map data ** Free WMS sources. NASA. Google. ** Why you need a tile cache, and how can make one. * Combining other geographical information ** Let's integrate and plot data from some sources. Perhaps Flickr and Yr? * Why Oslo Plaza suddenly may be in surrounded by water, if you didn't understand projections. * Demo ** Putting it together, combining map data and sources. * Tile cache ** How to determine if you need one, and how to size it. A simple demo in java. Required experience: Curiousness for map. The mapping concepts will be simplified. Level: Introductory Expected audience: Those who wants to implement a map solution, and those who have geographical data and wonder how they can use it better.

Byte code manipulation has become increasingly popular over the last years. It is used by JPA implementations, application servers, AOP libraries, web frameworks, monitoring systems, profilers, clustering solutions, scripting languages, workflow engines, and much more. In fact, most of today's applications will most probably rely on byte code manipulation, often even without realizing. Application developers however seem to be overly careful and often frown upon byte code manipulation as an arcade art that is risky and difficult to understand. This presentation will show you that it's easier than you think. We'll go over concise examples that illustrate the concepts. Distinct patterns, coming from different domains, will give you ideas about adopting byte code manipulation for your own products. You'll learn arguments to reassure skeptics and see how the manipulation can plugged into your tool chain. We'll finish off with tips and tricks to write maintainable code with the ASM library. After this session you'll see byte code manipulation as another tool in your arsenal and you'll have a good picture of how to start using it yourself.
* Introduction * What is byte-code manipulation? * Popular projects and what they use it for * Don't be afraid * Plugging in the manipulation * Code examples from open-source projects using ASM * Tips, tricks and gotchas * Q/A Language: English

As the number of services and applications inside your organization grows, it becomes increasingly hard to manage and control. When this happens it is important to start looking at implementing SOA governance. Because SOA governance is not widely understood (or is widely misunderstood), many common mistakes arise which result in duplicate efforts, less reuse, less interoperability and increased development time. During this talk we'll look at what exactly SOA governance is while exploring 5 common mistakes and how to avoid them.
* What is Governance? * What tools help you with governance? * What are a registry/repository? * 5 Common mistakes in SOA governance: ** Thinking governance is a product ** Not having a centralized source of truth ** Not enforcing architectural best practices ** Reinventing the wheel ** Inconsistent deployment strategies

Domain Driven Design with Object-Relational mapping is the state of the art for testable object oriented programming in domains with complex business rules. However, sometimes the domain contains natural relations and object graphs that are too large to fit in main memory. Even when you have sufficient memory, working with large object graphs that are naively OR-mapped can easily give you performance problems. Bjørn Bjerkeli and Eirik Maus present a few techniques they've used at BBS to handle the one-to-too-many-relations (almost) without sacrificing working on a pure domain model. These include domain object fields based on database queries, iterators that "page" entities in and out of memory and simplified methods for background fragment processing.
* Problem description * Relations and collections with Object-Relational Mapping libraries (Hibernate) * Fix for "running out of time": avoiding needless lazy-loading of large relation set for simple summation * Fix for running out of memory: Paged Iterations / moving objects out of memory again * Fix for running out of both time and memory: background fragment processing * Things we haven't tried yet that we think might work * Summary Duration: 50 + 10 min Language: The talk can be given in english or norwegian. Slides in english Level: Intermediate Required experience: Prior exposure to SQL databases and Object Relational mapping is recommended Expected audience: Developers and solution architects

Both Intel and Microsoft have recently said that we, as developers, need to start delivering more concurrency in our applications. The biggest obstacle to delivering more concurrency is the need to share data between threads.
In this talk we will explore recent advanced in the JVM that can help us reduce the impact the protecting data. We will also explore up and coming techniques that can help us meet the challenge of delivering more concurrency in our own applications.

Foredraget presenterer de vanligste sårbarheter i webapplikasjoner og trekker frem noen illustrerende skrekkeksempler hentet fra sikkerhetstester av norske webapplikasjoner. Vi vil så ta for oss hvordan Java-utviklere kan unngå å gjøre de samme feilene i sine utviklingsprosjekt.
summary Foredraget presenterer de vanligste sårbarheter i webapplikasjoner og trekker frem noen illustrerende skrekkeksempler hentet fra sikkerhetstester av norske webapplikasjoner. Vi vil så ta for oss hvordan Java-utviklere kan unngå å gjøre de samme feilene i sine utviklingsprosjekt. Required experience: Erfaring med utvikling av webapplikasjoner Expected audience: Utviklere som føler de kan for lite om webapplikasjonssikkerhet

The Jazz technology platform and IBM Rational Team Concert are developed by a team spread over eight sites and multiple time zones. The development is done using Agile practices based on the "Eclipse Way." For over a year our team has been using IBM Rational Team Concert to develop the product itself. This talk sheds light into how this is done and discusses best practices for using scaling up agility in a globally distributed team.
* Quick introduction to Jazz and Rational Team Concert * Our practices - the eclipse wayMe * Component based development * Our organization and roles * The artifacts we track * Isolating work not people * Planning, release and iteration planning, tracking cross team dependencies * Continuous integration - getting green builds * The endgame * Evolving the process * Experiences & Lessons Learnt

REST, the REpresentational State Transfer, is the architectural style underlying the HTTP protocol. In the last couple of years, REST has emerged as a compelling and simpler alternative to SOAP/WSDL/WS-*-based distributed architectures. In this session, Arjen will explain what REST is, how it can be used to build Web Services, and where it makes sense to use. We will look RESTful frameworks such as JSR-311, but focus on creating RESTful Web services with the Spring framework. This will include the features included in the current release of the Spring framework, and new features that are coming in the next major release.
We will start by giving an overview of REST: where did it come from, how does it work, and how can it be used to build a distributed architecture? Using illustrative examples, we will try to find an answer to these questions. Next, we look at some of the current frameworks and tools which can be used to build web services. We will look at Spring-MVC and JSR-311 (also known as JAX-RS) on the server-side, and also investigate client- side options, such as the plain HttpURLConnection, and the more mature Commons HttpClient. Prerequisites: Spring framework knowledge

You are a programmer on the Java platform, and you have been hearing more and more about Ruby, Ruby on Rails, and JRuby. What's this stuff all about? Why would a Java programmer care about these technologies? How will it make you, as a programmer on the Java platform, more productive? Over the past two years. Ruby on Rails has brought the Ruby programming language into the mainstream. Ruby offers a cleaner, simpler, faster, and much more fun language for day-to-day development. Rails has changed the face of web development with legendary productivity gains and minimal configuration. The two are now available for your Java platform projects with JRuby, an implementation of Ruby for the JVM. In this session, we'll walk through how you can get JRuby up and running. We'll demonstrate common use cases for JRuby like GUI development, web development with Ruby on Rails, and more. By the end of this session, you'll be ready to download JRuby and start adding it to your own projects, or start a few new ones. JRuby is ready for you!
* Introduction to speakers * Introduction to Ruby ** short Ruby features walkthrough ** short interactive demo * Introduction to JRuby ** short interactive demo of Ruby calling Java libraries * JRuby use cases ** Swing GUI development ** Swing demo ** Graphic development with Processing and/or JMonkeyEngine ** Graphics demo ** Web development with Ruby on Rails ** Rails demo * JRuby future * Conclusion, links, and discussion

Unit testing has become a mainstream task. Most developers do it. Most project leaders and architects expect their team to write tests. However, practice has taught us that a lot of teams write few tests, or spend too much time writing and maintaining them. Different development teams make common mistakes, run into similar issues and find their own solutions for them. This costs a lot of valuable time.
Unitils started in 2005, when a group of developers and architects joined in a task force to share their testing experience. These discussions resulted in a set of testing guidelines. The leaders of this task force started writing code to help implementing these guidelines. Unitils has emerged from concrete experience and lessons learned, with the ultimate goal of making unit testing easy, effective and maintainable. Unitils offers a lot of support in testing the database layer: automatic maintenance of test databases, automatic post-processing of the database to make it more test-friendly, loading test data using DbUnit and verifying the contents of the database after execution of a test. Unitils provides specific support for testing with JPA or hibernate, and offers integration with spring. It makes abstraction of the testing framework that is used for executing the tests, making it useable with JUnit3, JUnit4 or TestNG. But Unitils is not limited to persistence layer testing only: The reflection assert utility is a very useful alternative to the classic assertEquals method with a range of leniency options. Unitils also provides superior support for dynamic mock objects, offering a simple syntax for specifying method behavior and verifying expectations. During this talk, I will present the different features of Unitils using simple, concrete examples. I will talk about problems from real projects and demonstrate how Unitils helps solving these problems. * Introduction * Feature overview: Using examples, I’ll demonstrate the features of Unitils: assertion using reflection, test data management, test database maintenance, JPA / hibernate and spring integration, testing with mock objects. * Demo: demonstration of the database maintainer, JPA / hibernate entity-database mapping test * Architecture: Provide some insight into how Unitils works. * Summary and roadmap: What are our plans for the future * Q & A Required experience: Basic experience with unit testing. Knowledge of hibernate and spring is useful but not required. Expected audience: Developers, technical project leaders and architects, who are into unit testing and want to improve testing on their projects.

Med lang fartstid fra store smidige prosjekter vil Thomas, Anders, Geir Magne, Kristoffer, Benjamin og Steinar dele sine erfaringer - på godt og vindt - med publikum. Først innleder de med korte lyntaler før paneldebatten bryter løs.
* 3 innledende lyntaler (10min) om smidige metoder i store prosjekter * + paneldebatt (30-40min)

With the JavaFX SDK Technology Preview having been recently released, this session will get you up to speed on JavaFX regardless of whether you've had any experience with it.
Some of the topics covered will be: - A JavaFX tutorial - Binding the UI to a model - Using a graphical node-based UI approach to create "filthy-rich clients" - Understanding sequences -- the native JavaFX data structure - Using triggers to eliminate need for setters - Deploying JavaFX appl

This talk is about how to use the stresses of writing unit tests to improve your code. If I'm having trouble writing tests, it's often because the design of my target code can be improved. The trick is to listen to the tests and let them drive my development — that's a hint as to why it's called Test-Driven Development. As a developer, you can sensitise yourself to find the rough edges in your tests and use them for rapid feedback about how to improved the design of your code.
In this talk, I will work through examples of "smelly" tests, showing how they highlight design flaws and suggest improvements.

This session will compare a range of popular IoC containers. The containers that will be compared are: Spring, Guice, Tapestry 5 IOC, HK2
Summary Many Java developers have used a IoC container - or at least heard about Spring. Today there are a good number of IoC containers and each of them claiming to do Dependency Injection (DI) in a better way. This session will explain what IoC/DI really is, why we should use it, how the containers work and when to use each specific container. In this session, you will learn: * What Dependency Injection can add to your applications; * How various frameworks, including Spring, Guice, Tapestry 5 IOC, HK2 and PicoContainer, work; * Tips on when to use each specific container. Required experience Knowledge of an IoC container Expected audience People eager to know more about IoC containers

This presentation explores the challenges and solution patterns for managing data and compute tasks in scale-out environments. It is based on experiences with using a wide assortment of software solutions for compute and data management in scale-out environments, including newer scale-out technologies such as data grids and compute grids as well as getting the best results out of traditional database and messaging solutions.
In the past two years I presented the talks “The Top 10 Ways to Botch an Enterprise Java Technology-Based Application” and “The Top 10 Ways to Botch Enterprise Java Technology-Based Application Scalability and Reliability”. Now that people have plenty of expertise on how to botch their applications, I wanted to shift focus from anti-patterns to patterns. The "Top 10" theme remains as it keeps a quick pace and enforces a quick distillation of complex topics into simple concepts for the audience to remember. In this presentation I will use real world examples to demonstrate the challenges, solutions, and unexpected discoveries architects find when building scalable Java applications. I will site actual scenarios where each pattern has been used, and explain what the driving forces were behind these choices. (This talk consciously steers clear of discussing website scaling via content caching, as this is a topic well-covered by many whitepapers, presentations and other conferences. A few examples: For example, working on an ultra-low-latency JavaSpaces-based trading application was one of our first exposures to Recovery-Oriented Computing (ROC) for transaction processing in a production environment. The ROC concept can be used to achieve otherwise impossible results by selectively persisting only critical system state. Prior to this, we had generally steered clear of non-replicated in-memory data. But applying the ROC concept allowed us to achieve an order-of-magnitude latency improvement over what even the most efficient replicated-memory approach would have allowed, without compromising system availability. Likewise, working with a high-volume clearing application, a partner discovered that while serializable database isolation was required from a business perspective, and their database of choice enforced this optimistically, performing initial locking in-memory minimized the number of transaction rollbacks, substantially increasing system throughput. Much of this experience was acquired while working with customers in the usual early-adopter sectors: websites for retail, travel and hospitality; transaction processing and compute grids in investment banks; and more recently, the rush of so-called "Web 2.0" startups. While in most of these cases, the primary reason for being onsite with the customer was the Coherence product that I am involved with, many of the more interesting lessons came from working with 3rd party products from dozens of vendors and open source communities, and learning alternate solutions to common problems from the people involved with those products. Required experience Some experience with enterprise application development Expected audience Developers, IT Managers, Architects

This experience report will cover how our maven project moved from one single line of code in one webapp module to five webapplications and fourteen modules. There are very few best practises regarding how to organize a maven project over time. After talking to several peers and reading all available material I have not found any good solutions to this. This presentation is my effort to give something back to the java community and hopefully start a discussionon how you should organize your maven projects. Keypoints: * What is the best way to keep buildtime down to a absolute minimum? * Should the modules be organized in vertical or horizontal modules? * How should you use a maven repository? * How do you handle releases * When should you create a new module? * What is the downsize of creating a new module?
* Introduction * How it all got started * What was the result of our first refactoring? * How did we use CI-servers? * How did we use the maven:release-plugin? * What other useful plugins did we use? * Where did we end up and what did we learn? * Q&A

I sammenheng med utbygging av et kraftanlegg i Amazonas ble en indianer fra lokalbefolkningen trukket inn som vitne i rettsaken og stilt ovenfor den klassiske eden; "Do you swear to tell the truth, the whole truth and nothing but the truth so help you God?". Han svarer; "No, I can only tell you what I know". Vi som jobber med teknologi er alle meningsprodusenter idet vi lager en slags virkelighet som brukerne må forholde seg til. Vi har derfor på mange måter stor innflytelse i det å konstruere en virkelighet, en sannhet som mange brukere ikke setter spørsmålstegn ved. All teknologi handler mye om klassifikasjon av objekter og relasjoner mellom objekter, kategorier etc. Klassifikasjon vil si å dele inn objekter, personer, dyr eller andre fenomener etter kategorier eller typer. Et klassifikasjonssystem er en type kunnskap og kunnskap vil alltid ha et ideologisk aspekt. Men hvor bevisste er vi dette ansvaret? Gjennom en kort introduksjon av de tidligste sosialantropologiske studier av matklassifikasjon og totempæler vil jeg forsøke å vise at dagens semantiske web på mange måter er i tråd med disse tidligste fagteorienes hovedtanker, som for eksempel det å se det enkelte system som avgrensede enheter, som kan studeres alene. Avleggere fra tidlige forsøk på å se kunnskap i lys av klassifikasjonssystemer skinner i dag gjennom hos flere teoretiske tilnærminger som det til stadighet refereres til og jeg vil argumentere for at det er dags for å trekke inn verktøy koblet mot en metodikk som både er i tråd med tida vi lever i og som løfter blikket fra studier av avgrensende enheter og som retter blikket mer mot brukerens egenartede og unike forståelse av det samme fenomenet. Jeg er opptatt av å formidle tungt stoff på enkle måter – og vil bruke konkrete eksempler for å få publikum med på det som kan kalles en faghistorisk charterreise med konkrete eksempler hele veien for å illustrere poengene. De fleste vil nok sitte igjen med noen aha‐opplevelser samt få ett innblikk i en fagverden man har mye til felles med til tross for at man sjelden kobler fag som teknologi og antropologi sammen. Jeg vil anta at folk vil gjøre seg en og annen tanke – og trekke litt på smilebåndet!
* Innledning med tanker fra klassifikasjon av tidlig kannibalismestudie knyttet mot stekt/kokt mat og binære opposisjoner * Gjøre kort greie for hovedteorier innenfor klassifikasjon og kategorisering som vi kan dra/drar nytte av i teknologisk øyesmed. * Representasjon av virkelighet – eksempler på innhold vi tar for gitt å representere ’sannhet’ * Makt: definisjon, utvalg, navngivning, begreper, språk. * Subjektive fortellergrep * Søken etter det autentiske og egne funn om at innhold oppleves objektivt gjennom subjektive fortellergrep pga identifikasjon. Trekke ut noen gjennomgående trekk ved forståelse som identifikasjon, nær‐ og likhet og assosiasjon i menneskets tenkning. Lydklipp fra egne informanter som eksempel. Trekke tråden til eksempler på subjektive. fortellergrep formidlet gjennom www (twitter, facebook) og TV (reality, nyheter) * Avslutte med å presentere tall for mengden av elektronisk informasjon som distribueres på verdensbasis og (u)muligheten for deltakelse i den elektroniske verden på den ene siden og www som demokratiserende og deltakende på kryss av landegrenser på den andre.

Ved hjelp av rollespill vil Rasmus og Vidar dele sine erfaringer fra et smidig prosjekt. Sesjonen kommer til å bli delt i to: * I første del vil Rasmus og Vidar kronologisk fremføre prosjektets historie fra unnfangelse til realisering. De kommer til å demonstrere teknikker som er blitt brukt og hvordan disse passer inn i et smidig tankesett. * Tilhørerne oppfordres til å notere seg emner som ønskes diskutert under del 1. Dette kan være emner man lurer på, ønsker videre utdypet, er skeptiske til eller forslag til andre teknikker. I del 2 diskuterer vi disse temaene i plenum. Noen stikkord: Kommunikasjon, brukerhistorier, estimering, prioritering, risikohåndtering, leveranseplanlegging, retrospektiv med mer.

Many developers find the user experience uninteresting. "It's easy. Just skip the interface design phase and make everything beige. You can't go wrong with beige", some might think. This presentation will look at the theory behind great user experience. We will cover and kill some myths, talk about conventions, intuition and user intentions, as we go through the "classification process model" and give an overview of the laws of interaction design.
As we go along, we will show a best practice case study; how two senior Swing developers and a usability specialist transformed good user experience principles into a successful photo editor. The Photo Editor is developed as part of the new version of the Escenic Content Studio CMS client. Content Studio is used daily by more than 400 media sites worldwide, with several thousand end users, and is tailored to support modern newspapers' online publishing routines. The goal was to create an intuitive, task-oriented photo editor that fulfills 95% of our typical users' needs. These tasks include correcting image orientation, crop for aspect or composition, simple image adjustments as well as obfuscating incriminating details. Required experience None Expected audience Developers, Project Managers, UX-specialists

Turnaround is the time it take for the changes in code to propagate to the running application. It includes build time, deploy time and initialization time. Recently some developments in the Java ecosystem and IDEs made it possible to develop software with zero turnaround. This talk is an overview of these developments, which include dynamic languages like Groovy, JavaScript and JRuby, framework support for reloading like Tapestry 5 and RIFE, module approach in OSGi and generic class reloading approaches like HotSwap, JavaRebel and FastSwap.With each approach we discuss benefits and limitations. We also review how to set up your build environment to get least possible turnaround whether you program legacy code or start from scratch.
* Intro [5m] * Dynamic languages [15m] * Modular approach [5m] * Framework reloading support [5m] * Class reloading [10m] ** HotSwap ** JavaRebel & FastSwap * Setting up your environment [10m] ** Exploded development ** Build cycle ** Symbolic links and junction points * Q&A [10m] Required experience Familiarity with the Java development cycle. As an overview talk the goal is to show the possible options rather than discuss each of them in depth. Expected audience Software engineers and architects who want to improve their development turnaround time. The talk is based on experience of decreasing development time of 150 developers to almost zero. A lot of that expirience can be directly transferred to you.

Alle er enige om at dokumentasjon i systemutviklingsprosjekter er nødvendig. De fleste synes det er et kjedelig arbeid og vil heller gjøre andre ting, som f.eks. programmering. Mange skriver lange dokumenter som blir liggende bortgjemt i skuffer og kott uten å bli lest. Kanskje heldigvis, siden dokumentene ofte blir utdaterte over tid og dermed blir både ganske verdiløse og direkte skadelige. Dokumentasjonsarbeid er tradisjonelt både kostnadskrevende og lite lystbetont arbeid. Hvilken type dokumentasjon er den viktigste? Hvordan kan vi gjøre det både enklere, billigere og mer motiverende - og ikke minst, mer anvendelig? Dette foredraget gir noen refleksjoner rundt temaet med konkrete eksempler på hvordan dokumentasjonen kan gjøres mer levende gjennom en wiki integrert med andre utbredte støtteverktøy som Subversion og Maven. Vi ser også litt på modellbasert dokumentasjon med UML, hvordan krav beskrives i brukstilfellemodeller, og hvordan arkitektur kan dokumenteres.
* Presentasjon av meg selv og foredraget * Litt om hva trenger vi å dokumentere i systemutviklingsprosjekter, og nytteverdien av dette * Noen erfaringer med wiki-basert doumentasjon * Noen praktiske eksempler på wiki-basert dokumentasjonsstruktur fra et prosjektteam, bl.a. for krav og arkitektur * Noen gode råd for sunn dokumentasjon * Spørsmål og kommentarer Required experience None. However, some experience with participating in software development projects is helpful to understand the real-life challenges in this part of the work. Who should attend this session? Project managers, architects and other participants in software development projects How will the participants benefit from attending? Get some concrete examples of how to manage, communicate and maintain vital doumentation in software development projects. Get experience reports and reflections around the theme.

Mange smidige prosjekter opplever problemer med å holde oversikt over et stadig voksende antall brukerhistorier. Dette medfører ofte at prioritering og planlegging blir vanskelig og frustrerende, noe som kan føre til at vi tar feil beslutninger ift hva som bør inngå i hver leveranse. User story mapping er en enkel måte å samle og organisere brukerhistorier på. Teknikken fokuserer på hva brukerne forsøker å oppnå og hjelper oss å forstå hvordan vi kan skape leveranser som gir umiddelbar effekt. Brukerhistoriekart er et kraftig kommunikasjonsverktøy som sprer forståelse for hvilket problem som løses, hvordan og i hvilken rekkefølge.
* Intro * Et vanlig problem i (smidige) prosjekter * Tre strategier for å håndtere problemet * Realisering av strategiene med user story mapping * Oppsummering * Q&A FORKUNNSKAPER Ingen PUBLIKUM Alle som jobber med eller i smidige team

Spekulative markeder (slik som aksjemarkedet og oddsen) har i mange tilfeller vist seg å være bedre enn eksperter når det gjelder å forutsi hendelser. Dette har vært tilfelle innen en rekke områder - innen alt fra estimering av oljepris fem år frem i tid til å tippe hvem som vinner årets cupfinale. I dette foredraget vil vi gå gjennom teori og praksis for å vise hvordan slike marked fungerer, og vi vil vise hvordan teknikken kan brukes til estimering i systemutviklingsprosjekter. Foredraget er basert på aktuell forskning og våre egne erfaringer fra et systemutviklingsprosjekt hvor vi innførte denne teknikken.
* Introduksjon, 5 min * Hvordan virker et Prediction Market (PM), 10 min * PM som teknikk for å estimere systemutvikling, 20 min * Erfaringer fra innføring av PM i et prosjekt, 15 min Required experience: None Expected audience: Anyone interested in software cost estimation

Engineer tools like the familiar IDEs (Eclipse/IDEA/NetBeans etc.) have user interfaces increasingly different from office tools like Microsoft Office. When creating applications for end users it is important to aim for the look and feel this group is comfortable with rather than what would be intuitive for the engineer. At Exie AS we have developed an open source Swing look and feel component that dramatically simplifies this task. Just as it is important to utilize frameworks to improve productivity when developing web-based solution, so is the case with rich clients/desktop applications. A significant part of a desktop application consists of UI and IO plumbing. When should various menus, buttons and tool bars be enabled? Flexible docking frameworks, user preferences etc. There are various RCP frameworks available, however for a Swing based client the NetBeans RCP is perhaps the most complete. How to create an NetBeans RCP client and make it look like a member of the Microsoft Office package? It is quite easy, and I am going to show you how.
* Introduction * The needs of an advanced rich client * The main components of the NetBeans RCP * The Office 2007 LAF OpenSource module * (Demo) Creating a simple distributed, Internet enabled RCP from scratch * Conclusions * Q&A

As you hang up the phone after talking to your wife, you know you have to prepare an important dinner. You're not really motivated, neither sure where to find the right ingredience. But in fear for your wife you never consider objecting. Some time later, almost forgetting the task, you head for the grocery store. Since you're no expert on cooking you ask for help. Heading back home you decide to call a couple of friends to help you - since you really have more important things to do. When your wife comes home she stops suddenly with a strange look on her face; "What!? I can't serve rabit! Did you forget that we are having The Animal Foundation?". I respond weakly; "They don't like animals?". "They don't like killing them, you idiot! This talk covers the challenges we meet from someone defines a strategy and approves developing an IT-system to when someone else actually starts implementing it. Most of these challenges do not require "rocket science", so why does it happen over and over again? To finish of Tom will also show us a totally different approach where companies can meet these challenges and save months and millions, keep momentum and committment and gain tons of value! NB! This talk should also be interesting for developers who hasn't been involved in the stages before implementation, since you're the one they'll blame at the end.
* Introducing a classic scenario - From strategy, through requirement specification to development. * The problems - What are we loosing along the way? * A different approach - It only works if it's important enough and we lean in. * Q & A Required experience: Experience from software development projects Expected audience: IT-managers, Project Managers, Technical Managers or other experienced people who have been involved somewhere in the process from where a strategy is defined to the implementation of the IT-system starts.

In the last several years, I've taken a different approach to building software applications. Implementing various application concerns(1) generically(2) has enabled me to reuse the implementations across projects. * (1) concerns: such as forms construction, validation, ui navigation, search, authorization * (2) generically: in such a fashion that the implementation is decoupled from, or agnostic from the application's domain Specifically, I have constructed a framework that enables a very high degree of reuse, whereby I reduce application development to little more than defining the domain. Where implementations of the persistence, user interface, and other concerns can be reused across differing applications. In this talk, I will be sharing with you my experiences with this approach, and the results it has yielded. Live demonstrations of the various reusable features will be given.
* Introduction (1 min) * What's wrong with the way we build software applications today? (5 mins) * The scaffolds we see in rails, grails, etc.. are the beginning (2 mins) * Decoupling concerns implementations from the domain = Freedom to reuse implementations across applications (1 min) * How to decouple the model: coupling to the metamodel (5 mins) * Demonstrating sample applications constructed in this fashion (5 mins) * Overview of Generic Implementations: * Generic Create, Read, Update, Delete (2 mins) * Deployment (5 mins) * Analysis of the results (5 mins) * Conclusions/References (1 min) * Q&A (5 mins) Language: English Level: Intermediate Required experience: Participants should have experience in designing and implementing business software solutions. Code examples will be given using the following specific tool stack: the Java programming language, the Swing GUI Toolkit, the Hibernate O/R Mapping framework, and Java reflection, metadata concepts. Expected audience: Please consider attending this session if you are either a developer or manager with interest in exploring ways to improve the current state of software applications development in the areas of: developer productivity, usability, software application maintainability.

Alternative languages like Ruby, Scala and Erlang are being picked up by the large platforms and getting ever more attention. Many feel the need to learn a new language, but how does one choose which "other" languages to learn and develop in when there are so many worthy contenders? Pythonistas have historically not been very good at marketing. This talk will attempt to convince you that Python/Jython/IronPython deserves to be part of your developer toolbox. Language design choices in syntax, features and semantics influence what areas a language is suited for and the community that grows around it. Particular features and idioms of Python will be introduced and compared to choices made by other relevant languages. Finally, a demonstration of how effective development in Python can be using the Django framework which has emerged as the premier Python web-framework.
* Introduction * Python & Ruby * Python & Erlang * Python & Scala * Django * Q&A Language: English Level: The talk will be introductory but aimed at developers. Required experience: Developer experience Expected Audience: People who are interested in programming languages to use beyond and alongside Java.

Standards make the world go round. It would be impossible to mail a package or send an email message, drive a car or take an airplane trip, shop for food in a supermarket, obtain medical treatment in a hospital, watch TV or movies, enjoy a sports game, or do any of the other things the modern world offers without standards.
The Java platform is built on standards, and its success is directly attributable to the community-driven process through which the language and platform evolve: the Java Community Process (JCP) program. The acceptance and success of open-source development methodologies pose both a challenge and an opportunity for the JCP program. Are standards necessary in an open-source world?

Get ready for a challenge as Robert Martin dives deep into the topic of clean Java code by examining what makes a good function.
In this talk we will look at a lot of code; some good and some bad. We will experience how such code is analyzed, critiqued, and eventually refactored. We will understand the decisions made by an expert in the field as bad code is gradually transformed into good code. How big should a function be? How should it be named? How should it be documented. How many indent levels should it have? How should it deal with exceptions, arguments, and return values. This talk is all about code at the lowest level. And yet the principles and techniques presented have far reaching implications.

Four years after the release of the Portlet 1.0 specification, the new Portlet 2.0 specification introduces many new features that will greatly improve the interactivity of portlet applications and portals. The specification introduces advanced coordination features such as portlet events standardizing inter portlet communication and public render parameters which allows several portlets to share the same render parameters. The new resource serving feature allows a portlet to deliver personalized resources to the browser such as images or PDF documents based on the current user preferences and profile, it also offers the capability to serve markup fragments from a portlet providing support for ajax portlet development. Portlets are now allowed to interact with the portal request and response with the possibility to read or write HTTP headers and insert markup elements to the head section of the portal page. Others important features such as enhanced content caching and portlet filtering have been also introduced in the specification.
* Short introduction (3mns) * Portal & Portlet 1.0 (10mns) ** explain the role of an enterprise portal in the ecosystem and the solution it provides ** portlet history and concepts: brief recap of the Portlet 1.0 specification, its history, limitations and place in the Java EE ecosystem; brief overview of portlet containers * New Portlet 2.0 features focusing on advanced portlet coordination and AJAX applications based on the resource serving feature. Other features are reviewed albeit in lesser detail. Each major feature is explained, introduced by use cases. Differences with Portlet 1.0 are examined when relevant. Features are then demonstrated to get the audience to efficiently understand the concepts. ** Coordination features: portlet events and portlet public render parameters ** AJAX portlets based on the resource serving feature: the resource serving feature and use case for implementing AJAX portlet are explained. Some AJAX use cases are not covered by the specification, we'll explain why the expert group did not provide support for such cases and possible scenarii to address the issue. ** Quick overview of other features: sticky request attributes, GenericPortlet improvements, header access, portlet filters and caching, etc... * Conclusion (2mns) * Q&A (10mns) Language: English Level: intermediate Required experience: Web application development skills are expected, portal or portlet experience is not mandatory. Expected audience: Developers that wants to create applications for portals using the Java EE platorm and leverage the new features of the Portlet 2.0 specification. Architects that want to build a portal using several Portlet applications based on the Portlet 2.0 specification. Attendees will learn about the new features provided by the Portlet 2.0 specification and how to leverage them in their Portlet applications.

Deltakerne på denne sesjonen vil få innsikt i praksiser for effektivt å kommunisere og prioritere krav, estimere kostnader og gjennomføre utviklingsprosjekter. Ettersom dette er temaer uten fasitsvar legges det opp til mye diskusjon og interaksjon. Programvareprosjekter mislykkes ofte med å levere lovede resultater, og kostnadsoverskridelser er en stor og hyppig utfordring. Mangelfull kravhåndtering er ofte en underliggende årsak til disse utfordringene. Det finnes imidlertid en rekke indikasjoner på at gode samarbeidspraksiser kan redusere omfanget på problemet. Det har vært anslått at samarbeid og kommunikasjon utgjør opptil 70% av den totale tidsbruken i programvareprosjekter, og å anbefale en høy andel av samarbeid og kundeinvolvering er derfor ikke noe nytt. Utfordringen er imidlertid å identifisere hva som utgjør et godt samarbeid, og hvordan dette kan oppnås. Mange utviklingsorganisasjoner benytter seg i økende grad av iterative og inkrementelle prosesser, for eksempel Scrum. Imidlertid har også de smidige prosessene, og andre prosesser slik som RUP, mangler når det gjelder å involvere sentrale aktører som kunder, interaksjonseksperter og brukertestere. De iterative og inkrementelle prosessene er unektelig bedre utrustet enn de sekvensielle prosessene (fossefall) når det kommer til å håndtere disse behovene, men de er samtidig også langt mer innstilt på å tilfredsstille behovene til utviklingsteamet. Denne sesjonen skisserer samarbeidspraksiser vi mener øker sjansen for verdiskapning i utviklingsprosjekter. Hovedfokuset er praksiser for å: * Definere en prosess som forbedrer prosjektgjennomføring * Kommunisere og samarbeide om kravhåndtering og forretningsprioritering * Samarbeide om estimering og planlegging Et overordnet prinsipp for diskusjonen vil være å skissere et rammeverk for kravhåndtering som illustreres gjennom en kommunikasjonspyramide. Denne pyramiden skiller mellom fem generiske nivåer for kommunikasjon om krav, som er nyttig i de fleste prosjekter. Disse er: * Forretningsmål * Overordnede krav * Detaljerte krav (f.eks. brukerhistorier) * Utviklingsoppgaver * Kildekode (f.eks. konkrete funksjoner) For hvert nivå presenterer vi en oversikt over hvilke roller som typisk bør være involvert i kommunikasjon og samarbeid. Rollene som diskuteres inkluderer sluttbrukere, kunder, interaksjonsdesignere, utviklere, testere og prosjektledere. Det blir også presentert erfaringer fra et pågående forskning- og utviklingsprosjekt innenfor området.
* Introduksjon – samarbeid og kommunikasjon i utviklingsprosjekter * Effektive praksiser for å definere en prosjektprosess * Effektive praksiser for kravhåndtering og forretningsprioritering * Effektive praksiser for å samarbeide om estimering og planlegging * Hvordan binde det sammen – praktiske erfaringer * Diskusjon Required Experience Deltakere bør ha erfaring fra programvareprosjekter, enten som del av utviklingsteam, kunde, forsker, student eller lignende. Expected Audience Hovedmålgruppe er ledere, prosjektledere, kunderepresentanter, utviklingsteam og lignende. Vi ønsker deltakelse fra kunde og utviklingsside enten man er involvert i intern produktutvikling, skreddersøm eller produktutvikling for massemarkedet.

One of the core principles of domain driven design is that it should be focused on the domain and it’s logic, rather than the technology used to implement the system. However, many projects using the domain driven approach get tangled up in the technicalities of software development which increases complexity, reduces velocity and hurts both maintainability and reusability. In this talk I will demonstrate how to employ software engineering principles like "Don’t Repeat Yourself" (DRY), the single responsibility principle, separation of concerns and many more to keep attention on the model and at the same time cater for the concerns that clutter the designs of many domain driven solutions. After attending this talk, you should have a better understanding of how to separate your infrastructural con- cerns from your domain logic, build adaptable domain models that fit into many usage scenarios and keep those models maintainable throughout the entire project life-cycle.
* Introduction. This section is just a brief introduction to the ensuing topics. ~2 minutes. * ΄When Patterns Become Anti-patterns‘. This section will show how we unconsciously collapse our ap- plication structures by using design patterns to increase flexibility and let rigidity creep in to our designs. ~5 minutes. * The Strategy Pattern. The Strategy pattern enables us to select algorithms at runtime, but this comes with at the cost of forcing classes to have knowledge about the contexts in which these algorithms are used. Focusing on the implementation of a commonly used pattern drives attention to- wards how we can implement the same pattern with different means, which will be one of the themes for the rest of the talk. * The Collapse of Application Structure. Our implementations of common design patterns causes a ΄pattern lock-in‘ that can fragment domain logic and blur out the distinction between domain and in- frastructure logic. This can hurt the maintainability of our applications. Making Roles Explicit. This section will focus on improving the design of a domain model’s internals to achieve better separation of concerns and improved flexibility and maintainability. ~15 minutes * Our Objects Play Too Many Roles. Our domain objects, especially Aggregates, often violate sound software engineering principles. The upside of this is that it gives developers using these a better experience, the downside is that it hurts maintainability. In this section I will show how the common validation patterns we use in our models violates the single responsibility principle and eschew domain concepts. * Refactoring to Explicit Roles. In this section I will show how to separate the concerns in the previ- ous section into domain objects and services that adhere to the single responsibility principle and makes the solution more extensible. * Data Access is Infrastructure. This section will focus on improving the architecture of an application by clearly distinguishing between domain logic and infrastructure code. Towards the end we connect the dots by combining the lessons from this section with the ones form the previous section. ~20 minutes * Don’t Repeat Yourself! In domain driven design we use Repositories to abstract the data access layer. Different Repositories often share the same behavior and their implementations often violate the DRY principle. In this section I will show how to refactor the repository concepts into an application’s supporting infrastructure to increase productivity, reusability and maintainability without sacrificing the flexibility of hand-rolled repositories. * Lazy About Lazy Loading. Repositories are commonly used in conjunction with object/relational mappers to increase separation of concerns. As the real-world concerns of software development manifest themselves, these abstractions start to leak and soon our domain services get tainted with fetching strategies and similar. In this section I will show how we can combine the concepts from previous sections with Inversion of Control to keep our models clean. * Wrap up. In this section the emphasis is on separation of concerns, the DRY-principle and the importance of keeping roles explicit. ~5 minutes Required experience Attendants should have at least a basic understanding of domain driven design to get full yield. The design principles and techniques presented are generally applicable, and can be of interest to attendants with out experiences with domain driven design. Expected audience This talk is directed towards developers and architects who practice or want to practice domain driven de- sign. It should also be of interest to domain driven design skeptics who feel that this practice bring too much complexity into their designs.

Dynamic languages and frameworks come in different shapes and forms but they all get attention from architects looking at providing application agility and better development speed while preserving the systemic qualities of more traditional runtimes (scalability, manageability, etc...)
The first step is to have the dynamic language run on the JVM to benefit from the HotSpot investment, the second one is to have the associated web framework take advantage of an application server infrastructure providing pooling, recycling and other monitoring services. With the advent of modular architectures at the heart of modern application servers, it becomes now possible de make the wealth of Java APIs and the benefits of such a runtime available to artifacts beyond J2EE/Java EE. This talk will cover the value of dynamic languages to augment the value of existing applications and how these are implemented on the new, modular, OSGi-based GlassFish v3 architecture. It will discuss the integration of JRuby on Rails, PHP, Groovy/Grails, Python/Django and maybe other dynamic technologies in GlassFish. Demos and a couple success stories included. The list of APIs available to scripting frameworks include (but are not limited to): * Metro (JAX-WS and advanced Web Services) * Java Persistence API * Grizzly Comet for Ajax Push * JBI/ESB integration * JMS/MQ connectivity * Connector integration Audience Java and scripting architects and developers. They will be able to see for themselves the value and the maturity of mixing a traditional application server approach with the agility provided by scripting languages and frameworks.

Are you writing code that never gets used? Are you struggling to make the code fit your requirements? Behaviour-Driven Development (BDD) is a fresh breath of air in the agile community, and its primary focus is to deliver software that matters. -For the end users. BDD builds upon several agile tools and practices like Acceptance-Test Driven Planning, Example-Driven Devlopment, FIT, User Stories and TDD, and bring them together in a consistent whole.
This presentation will give an introduction to the principles and practices of BDD and demonstrate how you can make your plain text User Stories executable with RSpec's Story Framework, running against Java code. The RSpec framework itself is written in Ruby, but JRuby makes it possible to make your stories run against applications written in Java.

I HTTP-protokollen er det i utgangpunktet alltid klienten som initierer forespørsler. Men hva gjør du hvis en hendelse oppstår på serveren og du trenger å informere en eller mange klienter om dette så fort som mulig?
En vanlig løsning er å spørre serveren med jevne mellomrom ved å bruke Ajax. Slik polling gir dårlig responstid og fører til et unødvendig høyt antall forspørsler. Ved å trikse litt med HTTP kan vi imidlertid holde en forespørsel åpen over lang tid og la serveren sende data når det passer. Denne asynkrone push-arkitekturen kalles gjerne "Comet". Dette foredraget forklarer teknologien bak Comet, de nye mulighetene den tilbyr og utfordringene vi får på kjøpet. Foredraget tar utgangspunkt i servletcontaineren Jetty og Javascript-biblioteket Dojo. Sammen gjør disse det svært enkelt å utvikle Comet-baserte applikasjoner. Vi viser hvordan man kommer i gang med Comet og hvordan vi ved hjelp av Jetty og Dojo kan lage en webbasert chatapplikasjon på få minutter. Vi ser på flere eksempler der Comet er i produksjonskode og diskuterer ytelse og skalerbarhet i Jetty sin implementasjon. Vi viser også hvordan Comet støttes i forslaget til den kommende versjon 3.0 av Java Servlets-spesifikasjonen. * Why Comet? ** Increasing need for low latency, "always current" services ** Limitations of Polling, Ajax * What is Comet? ** Comet transports, long poll vs. streaming ** Comet is HTTP ** Asynchronuous IO (it's hard) ** Bayeux protocol * Some Comet examples (Screensshots / live demos / screencasts) ** SVNSearch real-time commits ** live.chess.com ** GMail ** Distributed Paint clone implemented with Javascript and Comet. * About Jetty ** Small, fast, testable, embeddable, and enjoyable open source servlet container. * About Dojo ** Javascript toolkit ** DOM manipulation, Effects, Widgets ** Plugin based ** Client side of Bayeux protocol implemented as a Dojo plugin * Chat example with Jetty and Dojo. (probably a mix of live coding and slides) ** Create Maven project ** Add Jetty, Dojo, Comet dependencies ** Add ContinuationCometdServlet to web.xml ** Adding a main method for Jetty with a SelectChannelConnector ** Creating a simple chat application with Dojo * Comet performance and scalability ** Greg's numbers? ** 20.000 concurrent users ** Comparison with polling * Comet limitations ** Container support ** OS/Container tuning (file descriptors, ) ** Firewalls ** Proxying (Apache mod_proxy?) * The future ** Servlet 3.0 ** Bayeux on Tomcat, Glassfish Required experience: Deltakere bør ha kjennskap til web-progammering i Java og ha grunnleggende kunnskap om HTTP. Erfaring med Javascript er en fordel.

For decades, enterprise systems have been built around the database - the original canonical data structure that everything had to integrate to. The DBA was the most powerful person in the enterprise, even messages standards were based on the database structures and it seemed everything had to have a table associated with it. The time has come to think about an enterprise free from the RDBMS - not free from persistence altogether, but free from the lock-in of the classic RDBMS. John will talk through some recent projects at several large financial institutions now building global trading systems without a database in sight.

What is internal quality and why are metrics helpful? A comparison with a cake will make it easy to understand: Not the optic and not the frosting on top of a cake guarantee a good taste and a healthy enjoyment. The ingredients, the recipe, the baking itself, the enjoyment of the cake, the great treat of it to keep in memory and the comfortable feeling afterwards are part of the total value and quality of the tasty cake. With the enjoyment of software is it likewise. The inner quality of software is crucial for your success in software development projects. This talk gives answers why this kind of quality is so important and how to gain better technical quality using different metrics based on the usage of the open source software XRadar (and others).
The quality of software can be divided into two parts. The first part is the outer quality, also known as functional quality. This is the quality seen by the user of the software. The second part is the internal quality, also known as technical quality. This is the quality seen by the software engineers. The testing of software is often only based on functional testing. Because the functional testing is driven by the functional requirements, the functional quality is easy to test and easy to measure. The technical part of the software is almost ignored, because the technical quality is harder to test. But the technical quality directly affects the functional quality. Sometimes you have non-functional requirements like response time for a certain function, but other non-functional requirements, like maintainability, are not measured. The talk will give the attendees ideas how to “test” or measure the technical quality of their software. I will give answers concerning basic questions on software quality, source code, object model, software metrics and their relationship. I will give a short introduction into basic terms and I will give a short overview on basic metrics and metrics on a higher, aggregated level. Then I will show some open source tools like PMD, ckjm, JDepend and will discuss the usage problems. Tools like SonarJ, Sonar and Xradar have more benefits. They consolidate the basic reports of the basic tools to create more readable and understandable reports of your software. The talk will have a focus on practical methods. I will also give examples based on daily project practice and the usage based on the open source tool XRadar (xradar.sourceforge.net). XRadar is a toolkit for quality analysis for java based software project. It is a reporting tool based on many other open source toolkits like PMD or JDepend. Motivation (5min) o Why do we need to control quality? o What big problems do we face when developing software? · What is technical Quality? (5min) o Definition of basic terms o What is quality, what is technical quality o What are metrics? · How to measure Quality! (5 min) o Introduction of different metrics o Introduction of methodologies o Basic to find quality criteria for your project. o Why it is important to have good tools (Example: XRadar) · Implementation within project ( 10min ) o How to do measurement within software development process o Showcase for some basic tools like PMD, ckjm etc. (Examples) o Why do we need good integrated tools · Comparison of different integrated tools (15min) o Comparing XRadar with other tools o Showing the pro’s and con’ s of different tools  XRadar  SonarJ  Crap4J  Sonar o Showing the usage of tools  Xradar  SonarJ · Conclusion (5 min) o Giving pro’s and con’s for controlling technical quality o Giving references to further reading, links, tools o Will give a summary of basic action steps. Required experience The attendees “should have” experience what could happen if they have bad quality within their projects Expected audience · Technical project leads, software architects and all people who are in charge for delivering good quality to your customer. · The participants will learn why they should monitor the technical quality. The will get an introduction into the basic methodologies as well as best practices. They will be able to start increasing their technical quality right after the talk.

The Applicaton Server is dead. But what about the Enterprise Service Bus? Are we facing phantom requirements and vendor-driven architecture all over again or does the ESB provide useful middleware services needed for enterprise development? Well, it depends on your requirements. In this talk we explore a real-world case and show how to implement a solution with and without an ESB. As it turns out, there are very good alternatives to typical ESB features. We consider pros and cons and present guidelines for the process of selecting the right tool for the job.
* Introduction * Features of an ESB * Case study: A system for collection, calculation and presentation of public pensions ** Overview of the functional and non-functional requirements of the system which has to integrate with numerous external systems. * A solution based on Mule 2.0 ** A message-oriented approach using transformations, aggregation, routing and other mechanisms supported by an ESB * A solution without an ESB ** A procedure-oriented approach using POJOs, Spring and other open source frameworks and libraries * Comparison of the solutions * Architectural guidelines * Summary Required experience: The attendants should have experience from development of enterprise applications. Familiarity with the concepts of web services is recommended. Expected audience: Architects and developers working on server-side business solutions should attend this session. The talk will be particularly useful to you if you are in the process of choosing a software architecture.

Åpne standarder, felles offentlig IT-arkitektur og fri programvare er begreper som du etter hvert har blitt en del av ordforrådet til regjeringen. Politisk rådgiver i Fornyings- og administrasjonsdepartementet Jørund Leknes vil i foredraget gå gjennom sentrale deler av regjeringens IT-politikk, forklare hvorfor valg av programvare nå står høyt på den IT-politiske agendaen og hvordan du som utvikler kan lage løsninger som forholder seg til dette.

Last November, Spring 2.5 was released. This version of Spring, the de-facto Java EE application platform marks the beginning of the introduction of alternative ways to configure components. In the, we've mainly focused on provided XML as the main language to perform Dependency Injection on object. Since 2.5, Spring has introduced several new ways to doing this. This session focuses on the various ways of using the Spring container to Dependency Inject objects such as the traditional <beans> XML language, the extensible namespaces, the @Autowired and @Component annotations, but also the innovative JavaConfig project that is capable of configuring Java objects using @Bean annotations. Each has drawbacks and advantages and this session will discuss which one you should choose in what scenario. After this code-intensive session, you will walk away with a clear understanding of when XML is a good choice for configuration and when to opt for one of the annotation-based options.
* Short introduction of myself * Short introduction of Dependency Injection as the general subject of the talk. There will be a lively, entertaining and mostly non-technical analogy for DI that will serve for thhe remainder of the talk * XML configuration option ** Introduction ** Demos ** Drawbacks, advantages, hints, tips and tricks * @Component/@Autowired configuration option ** Introduction ** Demos ** Drawbacks, advantages, hints, tips and tricks * @Bean/@Configuration option ** Introduction ** Demos ** Drawbacks, advantages, hints, tips and tricks * Comparison to other frameworks / DI approaches and conclusion The session is quite code intensive with relevant demos. Level: Anybody can join in, as it's entertaining even for those without Spring experience. For advanced users there's something to learn as well. Expected audience: Audience will leave with a clear understanding of Depedency Injection and the options Spring has to facilitate DI.

Given that object orientation underpins the Java language, it would be expected that anyone using Java would also know about OO. In one sense this is true, but there is more to effective modern object-oriented development than just creating a few objects and calling a few methods.
Many developers working in Java have not had the opportunity or exposure to effective object-oriented practice that would allow them to avoid common design pitfalls and to make more effective use of the language. Although object orientation is far from being a new approach (think Sergeant Pepper), and it's also far from being obscure, its mainstream adoption by programmers and programming languages alike is not always as effective as it could be, and sometimes the results can be less than desirable (to put it politely). This session aims to put a number of concepts many developers may be unsure of on a firmer footing, highlighting common pitfalls in OO practice -- such as abuse of inheritance, simplistic getter/setter interfaces, patternitis, use of singleton objects -- and emphasising techniques that promote an easier life -- such as loose coupling, unit testability, pattern-based design thinking, incremental and sufficient design.

The iLabs mobile toolbox is a an open source (Lesser Gnu Public License) java library for J2ME that makes it simple to make programs for social interaction on mobile phones.  The library is quite portable, since it abstracts away some of the notorious problem spots in J2ME programming: Keyboard handling, camera and sound handling.  It provides ready-made interfaces to Facebook, XMPP (Jabber), Blogger and other APIs necessary for social interaction.  The library includes a web browser library written entirely in J2ME that has proven extremely useful both for web browsing, and for user interface development when embedded in applications (clicking on an image on a "webpage" can for instance start a camera for image capturing). During the talk we will outline the anatomy of an application, the main elements of the library, and we will demonstrate how to build and deploy several small applications.
Required experience Some experience in program development. No experience necessary with neither ilabs Mobile Toolkit or J2ME. Some experience with use of social networking software an advantage (facebook, linkedin, orkut, or similar). Expected audience People with an interest in creating applications for mobile phones, either as developers (primary focus), or with ideas for mobile apps who need to know about things that are now simple to do using J2ME. After the talk developers will be able to start developing J2ME applications using the iLabs mobile toolbox, people with ideas will know that some of their ideas may be feasible within a reasonable amount of development work.

With the emergence of Web Services and the evolution of WS-* standards, the enterprise application integration vendors were quick to realise their traditional business model was under threat. On the back of their large installed bases, vendor products were offered to customers to help them deploy and manage their attempts to develop Service Oriented Architectures, with the implication that Web Services were of little use without additional middleware to deal with their alleged inherent complexity.
In this talk Jim will discuss how protocol-centric approaches like Web Services or the RESTful styles can constitute a robust integration fabric, providing the same benefits as proprietary middleware without vendor lock-in, and show how incremental, endpoint-centric integration is a viable strategy for enterprise service-oriented systems. * Historical perspective of EAI * Enterprise Architecture Today * Deploying an ESB * Enterprise architecture medium, long term * Spaghetti Oriented Architecture * Using commodity integration * Web Services example * Aiming for high cohesion with loose coupling * Arriving at SOA Required experience Participants in this session should be aware of general SOA concepts such as services and buses. Architecture experience is useful, but not necessary. Expected audience Architects and developers with an interest in SOA and enterprise architecture. No technical pre-requisites are necessary, but a sense of optimism, fun, and open-mindedness would be useful.

Through a project at NAV (The Norwegian Labour and Welfare Administration) for the pension program the presenters has significant experience using JSF, Spring Web Flow and AJAX as a platform for rich web-applications. The project is one of the largest java projects in Norway, and the presenters have been working with development of the new self-service application, and clerk administration application for NAV.
Through this talk the presenters will share their experiences using these frameworks, and demonstrate how these frameworks can be used to develop web-applications. They will give examples of both positive and negative experiences using these frameworks. The presenters will give a full demonstration of the technology, their architecture for the presentation layer and the structure of their code base by giving a demonstration on how they implemented “wizards”, menus, breadcrumbs and security using features of Spring Web Flow. In addition they will demonstrate the integration with JSF (MyFaces) and AJAX (Ajax4JSF).

This talk will cover best practices for OpenESB usage and integration.
* Basic OpenESB/GlassFish integration overview. * Basic JBI overview. * Scripting and automating deployments, clusters, node agents, service engines, binding components. * Working with NetBeans and OpenESB. * Structuring artifacts * Patterns for integration. * Tuning and performance considerations. Language English Required experience Java, JavaEE and some knowledge of integration using an ESB Expected audience Developers and architechts are the intended audience.

Dette er en erfaringsrapport fra MATS-prosjektet hos Mattilsynet, der Computas implementerer og integrerer en kartklient i webklienten og SWING-klienten. Rammebetingelsene for prosjektet var at kartserveren skulle være Java-basert og åpen kilde, slik at det ville være mulig å gjøre tilpasninger dersom det skulle være nødvendig. Videre var bare rene serverløsninger relevant siden klienten kom til å være egenutviklet. Valgmulighetene var derfor veldig begrenset; i praksis kun GeoServer. Selve klienten bruker OpenLayers, et åpen kilde JavaScript-bibliotek som støtter de viktigste protokollene. Det ble vurdert å utvikle en egen kartklient i SWING, men dette ble forkastet på grunn av begrensningene for minneforbruk i kjøremiljøet. Dette førte på sin tur til et behov for å kunne sende kartdata fra web-basert kartklient til SWING-klient, som ble løst ved å la kartklienten gjøre et HTTP-kall til SWING-klienten via en skjult IFRAME. Dermed var det heller ikke lenger nødvendig å bruke WFS-T- protokollen for å kjøre transaksjoner med geodataene direkte mellom klient og server, slik at vi kunne begrense løsningen til WMS. Det er mulig at det senere vil dukke opp krav som gjør det likevel nødvendig å utvide løsningen med støtte for WFS-T, men dette vil ikke være et stort problem siden også WFS-T støttes av GeoServer. Til slutt noen ord om plasseringen av GeoServer i vår arkitektur. I og med at den står ved siden av integrasjonsplattformen og er koblet direkte mot databasen bryter den med alle SOA-prinsipper, men alternativene viste seg å ikke fungere. En mulighet hadde vært å sette GeoServer foran integrasjonsplattformen, men dette hadde ført til økt risiko og mye merarbeid i prosjektet siden GeoServer er bygget opp slik at den forventer direkte tilgang til databasen. Å inkludere GeoServer i integrasjonsplattformen var heller ikke en god løsning da dette hadde ført til ekstra arbeid for å kunne deploye GeoServer i plattformen.
* Kort innledning 5 minutter * Behovene og bruksområdene for kart i MATS-prosjektet * Hva er OpenLayers, GeoServer og WMS? * Utfordringer og erfaringer i MATS rundt kartklienten * En liten demo Required Experience * Basiskunnskap om Java, webprogrammering og SWING. * Basiskunnskap om arkitektur Expected Audience * Utviklere og arkitekter som ønsker å implementere en kartløsning med web-basert kartklient integrert mot en eksisterende webklient og/eller java-applikasjon

Many view Apache Maven in the context of other build tools such as Apache Ant and Apache Ivy, yet Maven’s functionalities extend far beyond the efficient, enterprise-class project build. When coupled with supporting tools like Nexus and m2eclipse, Maven starts to accelerate development by reducing the level of work required to support build management and cross-department collaboration.
In this talk, Jason van Zyl, founder of Sonatype and creator of Maven’s Central Repository, will present a constellation of open-source software which can be used to extend Maven’s capabilities, from next-generation Eclipse support provided by m2eclipse to the Nexus Maven Repository Manager and Hudson which offer Maven support. Jason will also introduce some of the more unexpected uses of Maven to support development with Flex and to support the publishing industry

Modularity, versioning and dynamics make OSGi an ideal candidate for deploying and running Java applications, whether small or large. However, nothing comes for free and, like in any other environment, there are "do"s and "don't"s. In this session, we'll start by looking at OSGi (plus HK2 and JAM while we're at it) and then focus on some of the challenges that one might encounter when developing an enterprise application (containing web and data tier) in OSGi and how they can be addressed, using the lessons learned in Spring Dynamic Modules project and SpringSource Application Platform.
* OSGi overview * Part 1: OSGi class and resource loading * Persistence * Part 2: Working with OSGi services * Summary * Q&A Required experience: * Basic OSGi, persistence and web knowledge * Good Spring knowledge * Good Java Class/Class Loading knowledge Expected audience: Anybody interested in using OSGi for enterprise applications

Over the past years, successful practitioners have applied Agile methods like Scrum and eXtreme Programming (XP) on individual projects to cut development lead times, improve product quality and reduce engineering cost. For instance, time-to-market reductions in the range of 30-50% have been reported by leading companies. Now, as these practitioners seek to expand on their initial successes, they face many complex obstacles posed by the realities of today's business environment: multiple organizational silos, distributed teams, interfacing with 'non-agile' vendors and customer organizations, continued cost cutting, complex product suites, and the pressing need for innovation. How can agile practitioners apply the fundamental tenets of Agile - integrated small teams, small releases, sufficient-to-purpose, etc - to provide the next round of significant returns from their Agile investment? Sanjiv Augustine of LitheSpeed will lead a discussion on adopting a philosophy of smallness within bigness to allow the scaling of Agile practices beyond individual projects to deliver process improvements in complex environments with multiple projects.
* Small Teams ** Integrated Agile Team ** Scaling Agile Teams ** Stable Teams * Small Releases ** Realigning the Portfolio ** Incremental Funding ** Managing the Flow * Small Governance ** Self Management ** Team Productivity ** Portfolio Coordination ** Organizational Process QA

Kansellert pga sykdom Datamaskinprogrammer regnes som litterære verk og vernes etter åndsverkloven. Det betyr i utgangspunktet at de reguleres av de samme bestemmelsene som f eks norsk lyrikk. Hvordan har det seg egentlig at dette ble resultatet – og er det lurt?
I et program er funksjoner viktig, mens formen kan være sentral i poesi – og opphavsretten verner bare uttrykket. Opphavsmannen får en enerett til å utnytte verket – både poesi og program. Men til gjengjeld skal hvem som helst kunne lese lyrikken, skjønne den, bli klokere og dikte videre selv. Et program i objektkode lar seg i praksis ikke lese – er dette en slags bristende forutsetning for å gi det vern? Noen av disse spørsmålene besvares, samtidig som det gis en kort innføring i det opphavsrettslige vernet av datamaskinprogrammer, overgang av rettigheter i arbeids- og oppdragsforhold, og forholdet til patentering av programmer. Det forutsettes ingen forkunnskaper, så foredraget innledes med en presentasjon av opphavsmann, åndsverk og enerettene til å råde over programmet.

Etter mange tiår med programvareutvikling skulle man tro at de fleste applikasjoner håndterer feil på en god måte. I realiteten blir exceptions slukt, kastet på nytt, innpakket, ignorert og tilfeldig logget - om de i det hele tatt er tenkt på. Denne sesjonen viser tilnærminger som fungerer og noen tommelfingerregler for feilhåndtering, samt fallgruver og grusomme eksempler. Vi diskuterer også checked exceptions - et eksperiment i Java - og forklarer hvorfor de bør unngås.
* Feilhåndtering generelt og i Java spesielt * Overordnede tilnærminger ** Distribuert - Lettvekts exception-hierarki ** Sentralisert - Få felles exception-typer ** Exception-typer - Applikasjonsfeil og systemfeil * Feilhåndtering er viktigere enn feilretting * Checked exceptions er skadelig og bør unngås * "Sånn, ikke sånn" ** Bruk eksisterende exceptions ** Ikke sluk exceptions ** Fallgruver med try-catch-finally ** Deklarasjon av exceptions i metodesignaturen ** Russisk kone-exceptions ** Håndtering av stacktrace ** Unngå både logging og kasting ** Logging for overvåkning, drift og forvaltning ** Exception kontekst, feilkoder og instans-ID ** Navngiving, moduler og pakking ** Testing av exceptions Required experience Only Java programming knowledge is required. Expected audience This will be a techy session targeting developers and architects.

Begrepet "smidig" har blitt så hypet de siste årene at de faktiske verdiene i begrepet er i ferd med å bli utvannet. "Smidig" er tatt i bruk mange steder, men mange har opplevd å ikke få den ønskede effekten. I dette foredraget vil vi ikke ha noen grunnleggende gjennomgang av smidig prosjektledelse, men heller dykke dypere ned i utvalgte aspekter hvor vi ofte har sett eller begått feil, eller har sett stort forbedringspotensiale. Foredraget vil i stor grad ta utgangspunkt i eksempler fra forskjellige prosjekter vi har vært involvert i de siste årene, og belyse praktiske aspekter som vi har sett folk sliter med. I tillegg vil vi se på en grunn til å kjøre smidig som ofte ikke er godt nok belyst: *Den økonomiske*. Trond har bakgrunn som siviløkonom. Christian har bakgrunn som utvikler. Begge har endt opp som prosjektledere med sterkt fokus på smidig prosjektmetodikk og ledelsesfilosofi. Til sammen har de ca 20 års erfaring fra bransjen, men de gjør fortsatt feil, lærer fortsatt nye ting og ser stadig forbedringspotensialer.
* Intro - Bakgrunn * Problemområder og forbedringspotensialer ** Cargo cult ** Synlighet ** Hindringer fungerer som strikk - tilbake til gamle synder ** Smidige team: Felles mål - hver vår båt? ** Skape felles forståelse ** "Hvordan kommunisere med teknologer" * Prosjektøkonomi ** Hvorfor smidig lønner seg ** Økonomisjefens case for smidig ** Hva koster egentlig en forsinkelse * Oppsummering * Q & A Required experience Grunnleggende kunnskap om smidig prosjektmetodikk er en forutsetning. Praktisk erfaring er en fordel. Expected audience Prosjektledere og utviklere vil få en dypere forståelse, inspirasjon og konkrete tips til å forbedre prosessene de er en del av. Kunder og prosjektinteressenter vil få større forståelse av hvorfor de bør kjøre smidig, og konkrete innspill til hva de bør fokusere på.

Quercus is Caucho Technology's 100% Java implementation of PHP. This technology is taking off not only because of the trend toward scripting in the Java community, but also because of the performance and reliability that Java adds to PHP. In this talk, we will present the compelling reasons to use PHP on Java including availability of applications, ease of view development, and performance improvements of upto 89% over PHP with APC. We will show specific use cases of Quercus such as using popular PHP applications like MediaWiki, WordPress, and Drupal directly, bridging existing Java and PHP applications, and using PHP as a view technology for Java. We will also show the unique capabilities of the Quercus implementation such as transparent clustered sessions and use of Java objects natively from PHP. Finally, we will look at case studies of real Quercus deployments such as LiveProcess, the leader in emergency preparedness' planning for the healthcare industry, and others to see how these applications take advantage of PHP on Java.

Uten læring av egen og andres erfaring er det vanskelig å bli særlig god i programmering, prosjektledelse, estimering, kommunikasjon med kunde og andre viktige gjøremål. Gjennom flere empiriske studier har vi funnet vi at både "on-the-job" læring og tradisjonelle prosjektgjennomganger (post-mortem reviews, retrospectives, erfaringsrapportering m.m.) i mange sammenhenger har store svakheter og ofte gir feillæring og overreaksjoner i stedet for økt innsikt og bedre prestasjoner. Ønske om å lære noe fra en smertefull erfaring er for eksempel ofte større enn mulighetene og evnene, og det er derfor også viktig å vite når man ikke bør prøve å lære av erfaring! I denne presentasjonen går vi gjennom en del feilkilder og hvordan disse kan unngås for å forbedre evnen til læring av erfaring i systemutviklings. Avslutningsvis avholdes det 3. norgesmesterskapet i estimering (Tidligere vinnere er: Sindre Mehus og Tore Engvig). Som tidligere vil finalistene i estimerings-NM kunne glede seg over gavekort fra en av byens bedre restauranter.
* En interaktiv oppgave som illustrerer hvor lett man feillærer i en systemutviklingskontekst. * Evidensbaserte anbefalinger for å bli bedre til å lære av erfaring. Presentasjonen vil bygge på flere av våre egne studier om læring og på kjente læringsskjevheter (som å se mønster der ingen finnes, å vektlegge direkte men overse "systemtiske" årsaker, forskjell i type årsaksanalyse som gjøres i når man lykkes ("vi lykkes"), og mislykkes ("utenforstående hendelser gjorde slike at vi ..."), m.m. * Norgesmesterskap i estimerings Required experience: Ingen spesiell. Expected audience: Alle med interesse i bedre læring av erfaring

I brukerinteraksjon må tilstand håndteres for å styre funksjonaliteten til applikasjonen. Tilstand i deler av applikasjoner visualiseres og uttrykkes enkelt med tilstandsmaskiner. Det vises en meldingsbasert arkitektur der tilstandsmaskiner håndterer tilstanden til en applikasjon og der kommunikasjonen består av asynkrone meldinger. Scala og Java benyttes i eksempelapplikasjoner.
Interaksjon mellom en bruker og en datamaskin utføres i applikasjoner som kjører på ulike mange ulike platformer, som for eksempel en PC eller en mobiltelefon. Men brukerinteraksjon finner også sted i tjenester som svarer på SMS-meldinger, der meldingene kan sees på som kommandoer. Applikasjoner med brukerinteraksjon endrer oppførsel når brukeren utfører handlinger i applikasjonen. Hvis en bruker for eksempel navigerer eller utfører en annen handling endres tilstanden applikasjonen er i, og den nye tilstanden kan tilby annen funksjonalitet enn den opprinnelige. Tilstand er ofte vanskelig å håndtere på en god og helhetlig måte i applikasjoner. Det er dessuten vanskelig å at sikre at kun den lovlige funksjonaliteten er tilgjengelig i hver tilstand. Det er også en utfordring å håndtere handlinger som er tidkrevende og kan låse applikasjonen. Handlinger som utføres i Event Dispatch Thread, som brukes til å tegne GUI, gjør at applikasjonen ikke kan håndtere brukerforespørsler før handlingen er avsluttet. Tilstand i deler av en applikasjon kan enkelt uttrykkes ved hjelp av tilstandsmaskiner. De er lar seg lett illustrere visuelt, og kan enkelt realiseres i kode. I presentasjonen beskrives det hvordan brukerinteraksjon kan ses på som hierarkiske strukturer av tilstandsmaskiner som utveksler meldinger. I en Proof of Concept demonstreres hvordan en slik arkitektur kan implementeres der tilstandsmaskiner styrer oppførselen, og asynkrone meldinger brukes til kommunikasjon. Actor-modellen brukes både til å håndtere den asynkrone meldingsutvekslingen, og for kommunikasjonen mellom tilstandsmaskinene som styrer oppførselen i applikasjonen. Dette løser problemet med låsing av applikasjonen som kan oppstå når for mye skal utføres av Event Dispatch Thread. Modellen gir også en klar separasjon mellom brukergrensesnittet og implementasjon av hendelsene som trigges fra brukergrensesnittet. Eksempel på implementasjon og bruk vises i Java og Scala. Det vises hvordan Scalas Actor-modell forenkler trådhåndtering, og hvordan den gir en god abstraksjon over trådhåndtering i Java, som ofte er kompleks å jobbe med.

En introduksjon til entitets versjonering med Hibernate Envers
Hvis endringer på entiteter er en problemstilling i din domenemodell kan Hibernate Envers biblioteket være en mulig løsning. Envers er et bibliotek som forenkler lagring og gjenfinning av historiske data. Med kun én enkelt annotering - "@Audited" - er det mulig å logge endringer i entiteter (egenskaper og/eller relasjonIer). Presentasjonen forklarer hvordan Envers virker, viser hvordan Envers introduseres i en eksisterende domenemodell, og hvordan spørringer mot historiske versjoner av entiteter kan gjøres.

I Know IT Objectnet har vi jobbet lenge med intern prosessforbedring og kunnskapsdeling. I dette foredraget ønsker vi å dele våre erfaringer fra dette arbeidet.
Know IT Objectnet legger til rette for faglig utvikling for de ansatte via deltagelse i fagprosjekter på tvers av de daglige kundeprosjektene. Fagprosjektene kommer i stand på de ansattes initiativ og tar for seg ulike teknologier eller områder man interesserer seg spesielt for. De har varighet fra noen uker opp til et halvt år, og skal resultere i leveranser i form av foredrag, kurs eller workshops for kolleger. De siste årene har man hatt flere ulike prosjekter innenfor smidige utviklingsprosesser. I tillegg til interne fagprosjekter, engasjerer Know IT Objectnet seg også i forskningsprosjekter innenfor området. Foredraget tar for seg disse interne og eksterne prosjektene, og vil redegjøre for hvordan vi holder oversikt over prosjektene våre ved hjelp av løpende prosjekt-"barometre", erfaringsutveksling og kontinuerlig vedlikehold av retningslinjer / best practices.

Vi vil snakke om og vise eksempler på løsninger av konkrete problemstillinger knyttet til å kjøre applikasjoner på en sky.
"Cloud computing" er en av de varmeste potetene i IT-verdenen i dag. Man har flere typer skyer, flere leverandører og mange forskjellige måter å sette sammen sine systemer. For å kunne kjøre systemer i en sky så vil man ofte trenge en del endringer i applikasjonene som skal kjøres. Sammensettingen av applikasjonene som utgjør et system endrer seg også ofte. I dette foredraget vil vi gi en oppsummering av de relevante utfordingene og vise hvordan disse typisk kan løses. Foredraget vil dekke et system som kjøres på en sky, og med eksempler vil vi vise hvordan vi har håndtert utfordringer som skalerbarhet, deployment, oppgradering og tilgjengelighet. Emner som dekkes: * Oppsummering av dagens virtualiseringsteknologier * REST * Monitorering og overvåkning av applikasjoner * Hva er en sky i forhold til et klassisk cluster? Foredraget vil være praktisk orientert og inneholde mange spennende demoer!

Our application runs over 10,000 sustained transactions per second with a rich model. The key? Modeling state transitions explicitly.
Our application runs over 10,000 sustained transactions per second with a rich model. The key? Modeling state transitions explicitly. In today's world many systems have non-functional requirements that prevent them from being single database centric. This presentation looks at how Domain Driven Design can fit into such environments including extremely large scale web sites, batch processing, and even using highly scalable backing stores such as CouchDb or HyperTable. Event streams, a different way of storing the current state of an object, open many doors in this session not only in how we scale and store our domain but also in how we rationalize about it.

Er det vanskelig å få ting gjort? Har kompeksiteten i programutvikling blitt for stor? Gjør det vondt? Prøv Pomodoro-teknikken og øk produktiviteten din!
Vi utviklere har mye kompleksitet vi må håndtere, og alle verktøy som gjør oss mer fokuserte og effektive er et verktøy som bør prøves. Pomodoro-teknikken hjelper oss med å håndtere samtidige oppgaver og sørger for å holde hjernen vår fokusert gjennom hele dagen og bruke tiden vår effektivt!

A unique view of the world of high finance, with a technical slant. Connecting to stock exchanges with Java FIX engines, automated and algorithmic trading, back testing with over peta-byte of price ticks stored in a cloud and running it all from your mobile phone.
A year ago it was difficult to believe that there would be anything left in the financial services industry, banks were disappearing faster than glaciers and everything looked uncertain. A year on and banks are making profits again, Europe is slowly emerging form the recession and it's almost business as usual. One thing that hasn't changed over the last few years though is the onslaught of technology and our reliance on it to create and drive business. John will talk about the foreign-exchange, derivatives, equity and commodity exchanges, from the New York Stock exchange and InterContinental Exchange to the Deutsche Börse and Saudi Exchange. How FIX engines, written in C, Java and .NET work and how they relay the prices, thousands per second to the traders and algorithmic trading engines. Order Management Systems and Order Execution Engines then send the buy and sell order back to the exchange completing the loop. This talk will be on the technologies used, the problems faced and solutions to some of the problems, sticking mainly to the Java side of the stack but explaining why and where the other technologies fit in. John will also go into some of the leading edge technologies which include storing historic data in the cloud, around a peta-byte and then processing the data for algorithmic back-testing. Finally a look into how the mobile phone technologies are making a big hit in this area, applications being so valuable that the phone can be thrown in with the software. This will be a technical talk from an architects point of view, some code will be shown to demonstrate FIX connectivity and iPhone workings but talk with my more on the technologies and the architecture than the details of the code.

How to use DDD principles to make better strategic design decisions
As software development leaders, we need to think more strategically. Some design decisions affect the trajectory of the whole project or even the organization. These decisions arise in early chartering and throughout development, and they are about much more than architecture. This talk will examine these issues through the lens of the Strategic Design principles of domain-driven design, which systematize a few critical practices some successful teams do intuitively. It is common for skilled teams to deliver software they are not proud of, due to compromises with legacy designs. Others toil for years, producing a platform that is never used to good advantage. These are strategic failures. On the other hand, there are projects with a direct explanation of how the software contributes to business goals. There are projects where designers work with a realistic view of the context of their development within the larger system, allowing them to maintain design clarity and integrity. These are strategic successes. Winning strategy starts with the domain. Two domain-driven design principles, "Context Mapping" and "Distilling the Core Domain", help you see your strategic situation more clearly and approach strategic design decisions more systematically. These techniques require extensive interaction with domain experts as well as the leaders of the organization, in discussions broader than functional requirements. They sometimes lead to priorities quite different from our most comfortable notions.

A relevant example of a BPM-driven Web-shop application that makes use of ”Second Life” (Massive Online Virtual World) to demonstrate the handling of human tasks.
Almost everyone has heard mention of the term Business Process Management (BPM), but so few know what it's all about - and even less make use of BPM systems in their projects. As a paradox, a vast amount of Java-based projects actually implement BPM-functionality into their systems without even considering using ready-made BPM products, or simply because the architects are ignorant of the purpose of such systems. A part of the problem is that BPM vendors tend to over-simplify their white-paper examples, which lead to potential users finding it difficult to relate the provided examples to their specific problems. In this presentation a Web-shop application will be designed using a BPM-system (jBPM in this case) as a fundamental part of the overall architecture. Unreliable human-tasks will be demonstrated using ”Second Life”, which is a Massive Online Virtual World. Changing business rules, scheduling and user assignments will all be provided by the BPM-system and not implemented as part of the application (which, sadly, is the common way to do it). This presentation will provide the audience with a clean example of using BPM in their application that is more relevant than examples provided by vendors. In addition, the ”Second Life”-driven human-tasks will demonstrate how a BPM-based system will work in a (near) real-life situation.

GlassFish v3 modular and service architecture using OSGi and HK2. Developer features, both from Java EE 6 and product perspective. Demos.
This is certainly interesting times for application servers in general and for GlassFish in particular. This session will discuss GlassFish v3 and Java EE 6 which will both be weeks if not days away from being declared final at the time of the JavaZone conference. It will cover what's new with the technology and product but also with the community work. GlassFish is not only a modular application server platform with its core built on top of OSGi (it ships with Felix but also runs on multiple OSGi implementations), it also has a unique non-intrusive and extensible architecture. In essence, GlassFish is all about choice: Felix or Equinox, NetBeans or Eclipse (there are now GlassFish bundles with both Eclipse and NetBeans), and your choice of modules, all dynamically loaded. The resulting product ranges from extremely lightweight to extremely powerful. Choice doesn't stop at the Java EE frontier. The update center feature in the product also offers a powerful way to manage existing modules and access new ones from multiple repositories. It enables developers and companies to deal effectively with multiple frameworks, libraries and applications available from a simple graphical and command-line interface. Java EE 6 has many things going for it: new features (JAX-RS and JSR 299), important enhancements to existing well accepted technologies such as Servlet 3.0, JPA 2.0, EJB 3.1, and JSF 2.0, but also a web profile. With changing landscapes in a company or more broadly in the industry, the value of betting on a standard is higher than ever. Java EE 6 is improving the platform while taking into account what enterprise developers ask for: low barrier to access, maintainable applications, and yet infinite architectural solutions.

guardian.co.uk is the three times winner of the Webby for best newspaper on the web (http://www.guardian.co.uk/media/2009/may/05/guardian-wins-three-webby-awards) and the UK's most popular newspaper website, with over 220 million page impressions a month. Over the past three years the platform driving the site has been almost completely rebuilt, by a team that at its peak numbered 104, with the principles of DDD at the heart of the design.
This presentation reviews how key evolutions of our model were driven by domain experts and how DDD encouraged them to have greater investment in the development process. It also discusses some low-tech practices and tools which helped the design and implementation of the model and some of the remaining challenges we face in maintaining a deep, malleable domain model, whilst still meeting deadlines and addressing the operational needs of the business.

Attendees will see how to use of uncertainty as a driver in development, both in terms of schedule and in terms of how to partition their code.
In software development a lack of certainty about something can be part of the solution rather than part of the problem. This point of view can, however, seem a little counterintuitive and more than a little disturbing. There is a strong tendency for humans to feel unsure about uncertainty, in two minds over ambiguity and a little wobbly with instability. Whether over technology choice, implementation options, requirements or schedule, uncertainty is normally seen as something you must either suppress or avoid. Of this many people appear, well, certain. That you should embrace it and use it to help determine schedule and design is not immediately obvious. This session looks at how uncertainty can be employed in planning and used constructively to help determine object encapsulation, class hierarchy design and package partitioning.

Å ta over forvaltningen av gamle applikasjoner kan være et mareritt. Hvordan skal man innføre kvalitet og være i stand til å feilrette og videreutvikle disse gamle lappeteppene?
Ingen applikasjoner er "bruk og kast". De fleste lever over flere år, og i løpet av levetiden blir de lappet på av ulike mennesker. Det som var "hot og trendy" da applikasjonene ble laget er sannsynligvis heller ikke det som ansees som "good practice" i dag. Så hva i all verden gjør man når man skal ta over forvaltningen av slike applikasjoner? Hvordan skal man restaurere og innføre kvalitet i gamle applikasjoner?

Lurer du på hvorfor det er så mye hype rundt alternativer til relasjonsdatabaser. Hva er egentlig problemet med dem sier du? Her er en introduksjon til noen av utfordringene med relasjonsdatabase.
Lurer du på hvorfor det er så mye hype rundt alternativer til relasjonsdatabaser. Hva er egentlig problemet med dem sier du? Her er en introduksjon til noen av utfordringene med relasjonsdatabase, kjenner du deg ikke igjen i dem er kanskje din bruk av relasjonsdatabasen grei likevel. Det er mange meninger om relasjonsdatabasen, jeg vil gi en ryddig oversikt over ting som CAP, ACID, 2PC etc slik at man enklere kan argumentere for og i mot forskjellige løsninger til forskjellige problemer. Dette er ikke et korstog mot relasjonsdatabaser, men enkelte ganger er det greit å vite om begrensningene, hvorfor de er der, og hvilke alternativer man har.

Maven 3.0 will be the version Maven for the people. The Maven team has gone to the ends of the earth to ensure backward compatibility, improve usability, increase performance, allow safe embedding, and pave the way for implement many highly demanded features. This talk will briefly cover the process and tooling changes that have occured in the Maven project in order to accomplish what we have done with Maven 3.0, as well as discuss the architectural and feature changes.
Maven 3.0 will be the version Maven for the people. The Maven team has gone to the ends of the earth to ensure backward compatibility, improve usability, increase performance, allow safe embedding, and pave the way for implement many highly demanded features. This talk will briefly cover the process and tooling changes that have occured in the Maven project in order to accomplish what we have done with Maven 3.0, as well as discuss the architectural and feature changes. Some of the process changes include setting up a multi-platform Hudson grid, building out a framework of over 440 integration tests, creating integration tests for all core Maven plugins, and systematically seeking out Maven 2.x OSS projects to validate Maven 3.x's compatibility. We also built out a framework that measures disk I/O, network I/O, memory consumption, and CPU utilization to ensure that performance doesn't degrade. The architectural changes that will be discussed will center around how POMs are constructed, how the lifecycle is executed, how the plugin manager executes, and how artifacts are resolved. Some features derived from these architectural changes include any-source POMs, versionless parent elements, a compositional form of Maven POM configuration we call mixins, lifecycle extension points, plugin extension points, and our new Jetty Client-based, single point of entry artifact resolution mechanism we call the repository system

[Til komiteen: Takk for tilbakemelding! Har tatt med mer om JCR, og utvidet eksempelet. Siden OSGi fort vil bli relevant når man utvikler for Sling, vil jeg nødig fjerne den delen helt, men har i stedet fokusert på hvordan man bruker OSGi og Sling sammen.] Apache Sling er et innovativt, REST-basert webrammeverk, og utgjør et HTTP-grensesnitt til et Java Content Repository. Sling-applikasjoner støtter scripts for enkle funksjoner, samtidig støttes avanserte komponenter med OSGi. For mange webutviklingsprosjekter vil Sling være plattformen som gir deg kortest utviklingstid. Sling er også et godt Java-basert alternativ til f.eks. Ruby on Rails.
Tags: Web as a Platform, Java Frameworks JSR-170/283 er standarden for «Java Content Repositories» (JCR). Et JCR er et hierarkisk datalager. I motsetning til relasjonsdatabaser tillater JCR svært fleksible datastrukturer, slik at applikasjonen din lett kan endres etterhvert som du ser behovene. JCR kan også lagre filer og strukturerte data side om side, og er dermed et slags filsystem på steroider. I tillegg får man verdifulle funksjoner som observasjon (eventlisteners), tilgangskontroll, kryssreferanser, fulltekst-søk, versjonering, XPath- og SQL-spørringer, rike attributter og mye annet. Presentasjonen vil vi gi en innføring i JCR-implementasjonen Apache Jackrabbit. Det finnes mange kommersielle content management-systemer som bruker et JCR som datalager, men så langt har det vært få muligheter for rask JCR-applikasjonsutvikling med fritt tilgjengelige rammeverk. Formålet med Sling er å gjøre det enklere å utvikle webapplikasjoner som drar nytte av JCR. Sling-applikasjoner bruker script og servlet'er, som velges ut fra en enkel navnekonvensjon, til å behandle HTTP-requester etter REST-prinsippene. Av scriptspråk støttes bl.a. Ruby, EcmaScript, Groovy, Velocity, eller Cocoon pipelines. Man kan også plugge inn sin egen skriptmotor. Samtidig støttes enterprise-behov via OSGi, noe som gjør plattformen svært utvidbar. Med OSGi-komponenter («bundles») kan man utvikle pakker for egen funksjonalitet. Bundler kan også inneholde servlets, servlet-filtre, og JCR-innhold. Presentasjonen viser hvordan man bruker OSGi-komponenter med Sling. Sling og JCR er et bra valg om man utvikler et system hvor *innhold* er i fokus. Siden REST-prinsippet er sentralt i Sling, får man automatisk pene URLer til innholdet, og det er lett å lage CRUD-applikasjoner (create/read/update/delete) bare ved hjelp av vanlige HTML-skjemaer. Som en del av presentasjonen skal vi utvikle en blogg-applikasjon med bare noen få linjer kode, og dra nytte av Slings innebygde JSON-støtte.

Learn how to implement Enterprise Integration patterns with Spring.
The Spring Integration project provides a natural extension to the Spring programming model to support many of the Enterprise Integration Patterns described in the book of the same name. The components are configured with either annotations or XML and are managed within any Spring Application Context. Therefore, Spring Integration is very easy to adopt incrementally within an existing Spring-based application, and there are no additional deployment requirements. In this demo-driven session, we will begin with a sample application that includes a preexisting service layer. We will proceed to enhance the application while maintaining a clean separation of concerns between the integration responsibilities and the business logic within that service layer. The integration components will include Polling Consumers, Content-Based Routers, Splitters, Transformers, Service Activators, and more. We will also explore Channel Adapters and Messaging Gateways to connect to different systems using Spring Integration's support for JMS, Mail, and File-based transports.

Budgets are tight, quality expectations are rising, your software is in production, and clients are demanding that debugging turnaround time must improve. What tools are you going to use to troubleshoot: a file writing issue? port use collisions? production issues in absence of a debugger? memory leaks? long GC cycles? or even thread contention? Open Source offers excellent solutions to all these scenarios. Learn which tool to whip out for each debugging task.
Expensive commercial utilities ruled the debugging market for years, but learn how a loose confederation of 10 powerful Open Source debugging tools has adeptly fulfilled many of those same needs, and in many cases, taken debugging to the next level. In this 60 minute bootcamp, get exposed to tcpdump, netstat, jps, jstatd, VisualVM, jhat and it's OQL, Omniscient Debugger, TOD, Eclipse Memory Analyzer Tool, jtracert, btrace, lsof and fs_usage. Hear real-world scenarios of when to pull each out of your toolbelt, see each tool in action on a unified Java Web Application exhibiting a plethora of issues, and leverage each tool to discover and solve the problem.

Mange av de beslutningene som tas i løpet av et systemutviklingsprosjekt kan få store konsekvenser. I denne presentasjonen går vi gjennom noen gode og noen mindre gode fremgangsmåter for å fremskaffe et beslutningsgrunnlag.
Hvordan ta bedre beslutninger i systemuviklingsprosjekter? - en praktisk tilnærming. Valg av utviklingsmetode, arkitektur og teknologi er eksempel på viktige beslutninger som tas i de fleste systemutviklingsprosjekter. Gode valg medfører at utviklingstiden reduseres, kvaliteten forbedres og at både utviklere, kunder og brukere blir fornøyde. På den annen side, så kan et enkelt dårlig valg føre til at hele prosjektet blir en fiasko. Det er derfor bekymringsfullt at slike viktige beslutninger ofte tas på sviktende grunnlag. Viktige beslutninger baseres ofte på hype, salgspresentasjoner, evangelisering fra "guruer", eller egne erfaringer som ikke er representative for problemet man står ovenfor. Det er følgelig et stort behov for teknikker som hjelper oss til å ta bedre beslutninger. Forskere har foreslått flere teknikker som adresserer problemet, feks basert på systematiske litteraturgjennomganger og oppbygging av erfaringsdatabaser. Desverre opplever mange at det kan være svært vanskelig å bruke disse teknikkene i praksis. I denne presentasjonen skal vi se på gode og dårlige fremgangsmåter for å fremskaffe og evaluere informasjon slik at man kan fremskaffe et så godt beslutningsgrunnlag som mulig.

The history of computer programming has been bridging the gap between what the user says and what the programming language requires you to say. Building Domain Specific Languages (DSLs) allow you to express the solution in the language of the domain user instead of the language of the programmer.
"Simplicity is the ultimate sophistication." (Leonardo da Vinci) The history of computer programming has been bridging the gap between what the user says ("We need to add sales tax to each item in the order") and what the programming language requires you to say ("for Iterator i = orderList.iterator();"). Building Domain Specific Languages (DSLs) allow you to express the solution in the language of the domain user instead of the language of the programmer. DSLs can be written in any programming language, but the more flexible the programming language used, the closer to plain English the DSL can be. Groovy is a dynamic language for the Java platform that is ideally suited for creating DSLs. Come see how Groovy can leverage the power of Java in a way that your users might actually be able to read and understand.

How do you get more done with less? By Automating with Hudson! This talk discusses this popular open-source CI system.
This talk will introduce Hudson, an open-source continuous integration (CI) system, which improves the productivity of a development team by automating various things. CI is getting adopted more and more, as computers get cheaper and more capable. For people new to Hudson, we'll walk through the main features, discuss why CI matters, and how Hudson can use a large number of computers effectively. For those who already know Hudson, we'll talk about the current state of the project and the community, as well as what the future directions are.

Applikasjonsforvaltning er ofte vanskelig og tidkrevende, Aslak ser i denne lyntalen på noen av grunnene til hvorfor og forklarer forklarer samtidig hvordan man kan utvikle for lykkelig forvaltning. Slik kan forvaltningsprosjekter opprettholder momentum og verdiskapning som i utviklingsfasen.
I denne lyntalen vil Aslak forklare hvorfor det koster 8000kr (8 timer) å implementere en avkrysningsboks ("check box"), som normalt burde koste 1000kr (1 time). Dette er en helt unødvendig ekstrakostnad dersom vi hadde vært mer bevisst på årsaken til hvorfor denne oppstår. Om man aldri har jobbet med applikasjonsforvaltning er det ikke så lett å se dette. Han vil forklare hvilke krav som BEKK forvaltning stiller til utviklingsprosjekter som gjør systemene forvaltbare - altså reduserer kostnaden i forvaltningsfasen. Dette gjør han gjennom se på hva som gjør at ting tar tid i forvaltning og hvorfor man ikke ser disse problemene i rene utviklingsprosjekter.

Google Android er neste generasjons mobilplattform, og flere nye Android-telefoner ventes i år. Se hvordan vi utvikler en applikasjon for Android som bruker sanntidsdata fra Trafikanten. Plukk også opp tips om hvordan din gamle telefon kan oppgraderes med Android!
Google Android er neste generasjons mobilplattform, og flere nye telefoner ventes i år. Android kan bli en viktig plattform for utviklere av mobile applikasjoner. Vi tar for oss Android sin arkitektur med fokus på applikasjonslaget. Applikasjoner for Android skrives i en variant av Java, og kjøres i en virtuell maskin som heter Dalvik. Android har et rikt API som tilgjengeliggjør alt av telefonens funksjonalitet og har ingen "skjulte" API-er. Vi skal se hvordan vi lager en applikasjon som benytter Trafikantens sanntidsdata, og vil gi en liten innføring i hvordan applikasjoner i Android er bygget opp. Kjernen til Android er basert på Linux 2.6 og hele Android er lisensiert under frie lisenser. Android har også blitt "portet" til flere telefoner, og vi skal se hvordan man kan oppgradere en HTC TyTN II med Android.

Skihopp omtales ofte som verdens vanskeligste idrett, fordi suksess i denne idretten avhenger av svært mange faktorer. Et vellykket IT-prosjekt avhenger av faktorer som økonomi, psykologi, informasjonsflyt, intern politikk, menneskelig motstand, tekniske løsninger, prosjektledelse og prosjektdeltagernes evne til samarbeid. IT-prosjekter kan neppe omtales som idrett, men vi hevder at suksess i et IT-prosjekt avhenger av minst like mange faktorer som et godt skihopp. Således kan kanskje IT-prosjekter betegnes som verdens vanskeligste arbeidsplass?
Vinnerne, både i næringslivet og i hoppsporten, vet at bak et godt svev ligger langvarig trening og nitidige forberedelser. Tør du å satse som en skihopper i ditt neste prosjekt? Våger du å bruke tid på å konsentrere deg skikkelig før start, trykke til på hoppkanten og legge deg i flytestilling? Hvis du gjør det kan DU bli en Wirkola som det blir veldig vanskelig å hoppe etter!

Få en rask innføring i iPhoneutvikling.
Dette foredraget vil gi en rask innføring i programmering på iPhone. Foredraget bruker en enkel applikasjon som eksempel og viser hvordan man kan bruke iPhone-ens innebygde GPS sammen med alment tilgjengelige tjenester til å lage kul liten iPhone app. Foredraget går gjennom Xcode, utviklingsmiljøet som Apple tilbyr for utvikling på iPhone, og gir en rask introduksjon til Objective C, vanlige API-er og programeringsmodeller man kommer i kontakt med som fersk iPhoneutvikler.

Smidig handler om å levere forretningsverdi – i teorien. I praksis leverer vi funksjonalitet, og har ikke filla peiling på hvor mye verdi vi har levert og skal levere. Vil du høre om et team og en kunde som går fra mainstream smidig til å levere målbar forretningsverdi? Kom.
- Vi har levert 28 poeng denne sprinten! - Flott, det kaller jeg valuta for pengene! Vi sier at smidig handler om å levere høy forretningsverdi tidlig og hyppig. Og vi sier gjerne at vi leverer det som gir mest verdi først. Men det er teorien. I praksis - for eksempel i Scrum - gjør vi ikke annet enn å levere funksjonalitet, og vi aner ikke hvor mye verdi funksjonaliteten innebærer – bare hvor mange abstrakte poeng den er estimert til. Vi overlater til kunden / produkteieren å prioritere rekkefølgen på funksjonaliteten og håper at det da gir høyest mulig verdi først. Det stemmer kanskje, eller kanskje ikke. Hvem vet? Det er mulig å bryte ut av mainstream smidig til å levere målbar forretningsverdi. Kom og hør historien om en kunde og et team som tar ”verdi” alvorlig og sammen lærer å definere, planlegge, levere og måle verdi. Det er en annerledes presentasjon - en levende, underholdende og inspirerende historie. Underveis får du også ulike innfallsvinkler og verktøy som kan hjelpe deg til å foreta det samme spranget.

This session shows the 4 principles of developer productivity: acceleration, automation, focus, and canonicality, with examples of each.
In The Productive Programmer, I identify 4 principles of productivity: acceleration, focus, automation, and canonicality. This session defines the principles and describes their use, but the primary focus of this talk is on real-world examples of how you can use these principles to make yourself a more productive programmer. Acceleration covers ways to speed up development by taking command of your computer. This includes keyboard shortcuts (including ways to learn them and make better use of them) in both IntelliJ and Eclipse. Focus describes how you can utilize your environment (both physical and computer) to greatly enhance your productivity. Canonicality (the DRY principle from The Pragmatic Programmer) discourages repeating artifacts in projects. This talk shows effective ways to avoid this repetition. I show examples of creating DRY documentation, O/R mapping, database schemas, and development environments.Automation refers to making the computer do more work for you. This talk includes tons of examples, all culled from real-world projects

Come see why people rave about Ruby (including JRuby). This talk highlights the incredible power of meta-programming in JRuby.
This session shows one of the reasons that JRuby is the most powerful mainstream language today: meta-programming. It shows tons of meta-programming techniques in Ruby, including open classes, the shadow meta-class, defining methods on the fly, why Spring doesn't exist in Ruby, building annotations in JRuby, replicating Java features in JRuby, and tons more. And each of these comes with an example that actually makes sense!

Why stop when the fun is just getting started? A presentation on how healthy agile principles and techniques should prevail through the entire life cycle of an application; development, production and application management. By keeping your eye on the ball - the business overall strategy and visions, the application management phase can become an arena for realizing values and driving the business.
Why stop when the fun is just getting started? A typical phenomenon in IT-projects is how all projects seem to lose focus and momentum as soon as the system reaches production. The team is dispersed. New and often inexperienced personnel take over. Why does this happen? Would you stop nurturing and developing your newborn child? Application Management is often synonym to bug fixing and maintenance - and boring. It’s like in a hospital where it's all about keeping the patient alive, not helping them. While it of course is important to keep the patient alive, the point is that we should be focusing on improving the system. The system has finally reached a phase where you can get real feedback and adjust to reach your business goals. We will look into how healthy agile principles and techniques should prevail through development, into production and thus Application Management. Keep up the good iterative momentum! The goals of the application are still valid and shouldn't disappear. Instead one should embrace the fact that the application now is in a phase where it can collect real feedback. Understand the business' overall strategy and visions, and make sure to measure how you're doing according to these. Make the application management phase an arena for realizing values and driving the business forward. Dare to aim for the stars! It's time to create real value in the real world...

A very common problem when the shit hit’s the application fan and the debugging starts is that the logs are not in the correct format, the logging is too coarse-grained, and that the logs are hard to get runtime access to. This presentation will address this by first give you an overview of Log4j, show you how can control Log4j remotely using JMX, customizing the log output, and do remote logging.
When developing real-world applications, debugging can be quite cumbersome; the logging is at a level that doesn’t give you a clue of what’s going on, the log file is hard to retrieve and monitor, and you are not able filter out what is important for you. Typically an application restart is needed to change the logging level. And guess what, the buggy state of your application has disappeared as free beer at PartyZone, and your logs are flooded with unrelated information We have met these challenges several times when we at TANDBERG develop Java based products, and especially when we are designing clustered applications. Then it can be rally hard to determine which instance of the cluster that serves the incoming request. Collecting the logs from the instances in a centralized Syslog server, and apply filtering to get relevant information dynamically is very helpful for us when debugging these kind of applications. This presentation will provide the tools that make you able to dynamically change the log level remotely, redirect you logs to a centralized Syslog server, and filter log messages. In addition you will be shown working code examples of how to customize Log4j and instrument your application using JMX. All this will be achieved by using a killer combo of Log4j, Spring, and JMX presented to you as live and kicking code. The presentation will also give you an overview of the relevant mechanics in Log4j, Spring and JMX that makes the foundation of the example code in the session. The presented material is based on personal experiences from real-world Java products development.

So your server is having issues? memory? connections? limited response? Is the first solution to bounce the server? Today's Java™ 6 provides superior runtime monitoring and management capabilities. Learn the skills and tools necessary to debugging production JVM issues.
So your server is having issues? Memory? Connections? Limited response? Is the first solution to bounce the server? Perhaps change some VM flags or add some logging? In today's Java™ 6 technology world, with its superior run-time monitoring and management capabilities, the reasons to bounce the server have been greatly reduced. With proper Java Management Extensions instrumentation, the need to bounce the server may be eliminated for all but the rarest of cases. This session, for all Java technology developers and administrators, looks at the Java 6 platform's monitoring and management capabilities, which include the ability to make VM argument changes on the fly. In addition to what is provided in the JDK™ software, it demonstrates several management tools that are available at no cost. The session dives deeply into * jconsole - for memory monitoring, heap dumping, and thread analysis * JVM tools - jmap, jhat, jinfo, jstack * BTrace - the open-source option for on-the-fly monitoring of the JVM machine

Er du ferdig? Tør du sette systemet i produksjon, eller er det bare et sammensurium av kode du er usikker på om er klar til å brukes? Det er på tide å heve standarden og lage programvare som gir verdi for bedriften på både kort og lang sikt.
Den beste måten å måle fremgang på er programvare som er i bruk og skaper verdier. Kode som er klar for produksjon, men som bare ligger og venter på å bli produksjonssatt, er noe som ikke genererer verdi. Eller som man i Lean ville kalt det: Waste. Hvorfor kan vi ikke få programvaren i produksjon idet en funksjonalitet er implementert? Dette foredraget hjelper deg på veien mot å kunne endre dette. "Push button deployment" er noe Jeff Sutherland snakker om som en forutsetning for smidige prosesser hos Patient Keeper. Patient Keeper er selskapet han jobber for, og hvor han drar ut mange av sine erfaringer rundt Scrum. Andre bedrifter som har gjort det bra med hyppig produksjonssetting og sin evne til å tilpasse seg marked og kunder er eBay, Flicker og Amazon. For å kunne gjøre disse hyppige endringene og tilpasningene kan ikke produksjonssetting være en stor og farlig operasjon som skal gjøres så sjelden som mulig. Det må rett og slett være en enkel, sikker og rask operasjon. Det må være smidig utrulling. Dette foredraget tar for seg hvilke verktøy og metoder man kan ta i bruk i Java for å komme nærmere smidig utrulling og oppsett av nye miljø. Verktøyene og metodene er basert på konkrete erfaringer, og håndterer ting som pakking, oppgradering av database og testing. Gjennom kodeeksempler viser jeg hvordan man kan bruke verktøy som Maven, Hudson, DBDeploy, Jetty og litt scripting for å få til effektiv, fleksibel og enkel deploy av en standard Java EE webapplikasjon. Det vil ikke være mulig for alle bedrifter eller systemer å ha hyppig produksjonssetting, men i det minste bør man kunne rulle ut ofte og kjapt til test-, beta- og preprodukjons-miljøer. Bare å få dette til i testmiljøene vil gjøre deg bedre i stand til å få hyppige tilbakemeldinger fra brukere, og dermed kunne korrigere kursen oftere. Dette foredraget er holdt for javaBin i komprimert form. Denne utvidede utgaven vil bygge på tilbakemeldingene fra tidligere, og spesielt gi mer detaljer og eksempler i forhold til hva som skal til av kode og oppsett for å få det til i Java. Topic: Agile and Software Engineering, Tools and Techniques, Experience Reports

Cloud computing og Web 2.0 driver en ny tilnærming til lagring med fokus på fortløpende endringer, lave kostnader samt ekstrem skalerbarhet. Samtidig betyr dette begrensede muligheter sammenliknet med en tradisjonell RDBMS. Er det på tide å kaste ut relasjonsdatabasen?
I mange år har relasjonsdatabasen vært et udiskutabelt valg for de fleste applikasjoner. Imidlertid ser vi nå flere alternative databasetilnærminger, drevet av høye krav til skalerbarhet i nettskyen og Web 2.0. Denne sesjonen tar for seg bakgrunnen for denne endringen og ser på de mest interessante lagringsmekanismene som Google BigTable, Amazon SimpleDB og Yahoo PNUTS samt dokumentdatabasen CouchDB. Fokus for disse tilnærmingene er primært mulighet for fortløpende endringer, lave kostnader samt ekstrem skalerbarhet. Samtidig betyr dette begrensede muligheter sammenliknet med en RDBMS. Er det på tide å kaste ut relasjonsdatabasen?

Med Java EE 6 er JSR 318 -- Enterprise JavaBeans 3.1 ferdigstilt. I denne sesjonen ser vi på dei viktigaste nyheitene i den siste EJB-spesifikasjonen og diskuterer korleis desse endringane kan vidare forenkle og forbedre EJB-arkitekturen.
Med lanseringa av Java Enterprise Edition 6 er Enterprise JavaBeans 3.1-arkitekturen klar for massene. I EJB 3.1-spesifikasjonen har forenklingane som vart introdusert i EJB 3.0 blitt vidareutvikla, og i tillegg har ny funksjonalitet blitt lagt til. Denne sesjonen gir eit oversyn over både endringane og den nye funksjonaliteten i EJB 3.1-spesifikasjonen. Emner: * Valgfrie local business interfaces * Portable globale JNDI-navn for session beans * Embedded Enterprise JavaBeans i webapplikasjonar * Singleton-beans og singleton concurrency management * Asynkron metodeinvokasjon på session beans * Applikasjonsvide livssyklusnotifikasjonar * Forenkla orkestrering med EJB TimerService EJB 3.0 tok eit stort steg i retning av ein forenkla EJB-arkitektur og reduserte drastisk på utviklingsinnsatsen som krevdes for å implementere Enterprise JavaBeans. EJB 3.1-spesifikasjonen vidarefører denne forenklingsprosessen ved å gjere local business interfaces valgfrie, globale JNDI-navn blir endelig standardiserte og EJBar kan no instansierast direkte i webapplikasjonar utan behov for ein separat ejb-jar. Fokuset i overgangen fr† EJB 2.1 til 3.0 var å forenkle spesifikasjonen, heller enn å skulle introdusere ny funksjonalitet. Med EJB 3.1 er denne funksjonalitetsfrysen over og mykje ny funksjonalitet har blitt introdusert. Singleton beans og applikasjonsvide livssyklusnotifikasjonar for session beans er heilt nye konsept, men også eksisterande API har fått ei ansiktsløfting med ny funksjonalitet som cron-aktig spesifisering av tidsuttrykk til EJB TimerService og asynkron metodeinvokasjon på session beans.

A pragmatic and practical session on how to use Scala in the real world.
Scala is a one of the most interesting new languages for the JVM. A unique and elegant blend of the Object-Oriented (OO) and Functional Programming (FP) paradigms yet pragmatic and practical with seamless interoperability with Java. Scala stands for 'SCAlable LAnguage' and is designed to scale with the needs and requirements of its users. It is statically typed but with good type erasure and style which gives it a dynamic feel similar to Ruby or Python, but with the performance and safety only a statically typed language can provide. This makes it great for a wide range of use-cases, from internal DSLs to large-scale enterprise applications or container code. In this talk we will give you an introduction to Scala from a Java/JEE and real-world perspective. We will discuss a wide range of areas such as: * How to make effective use of Scala's richer OO abstractions and type system, such as mixin composition, to create more flexible and reusable components and systems. * How to take advantage of Scala's FP nature, such as closures, high-order functions, immutability, for more clean, safe, conceptually coherent and deterministic code. * How to make concurrent programming and event-driven systems a walk in the park using Scala's Actors library. * How to bring it all together and make Scala work in the real world; with problems like Web development, O/R Mapping, Dependency Injection (DI), AOP, Testing, High-Availability, Scale-Out etc.

Med smidig metodikk har automatisert test fått vind i seilene som aldri før. Fra å være noe som aldri ble gjort skal plutselig alt testes automatisert. Uheldigvis kan dette være å gå fra en grøftekant til en annen. Dette foredraget er for deg som ønsker å lære om effektiv testing, og hvilken effekt ulike verktøy og teknikker gir.
TDD blir trukket fram som noe av det viktigste innen smidig utviklingsmetodikk, men noe har gått galt i den smidige verden. Plutselig skal enhver if-then-else-setning testes med FitNesse og ethvert scenario i brukergrensesnittet skal verifiseres med Watir, Selenium, FunFx, etc. BDoc er en motvekt til denne trenden, et verktøy for å dokumentere spesifikasjoner og funksjonelle tester skrevet i JUnit. Foredragsholderen er hovedutvikler av BDoc og vil gjennom dette foredraget presentere eksempler på effektiv og mindre effektiv testing innenfor ulike områder av automatisert test. BDoc vil bli demonstrert som et lettvektsverktøy for automatisk akseptansetest og dokumentasjon, hvor applikasjonen som testes skal beregne alderspensjon fra folketrygden.

The theories of Frederick Taylor and those that followed today still sets the norm for how organizations are managed. What we see as normal and common ways to organize work is in fact making agile adoption difficult, hindering empirical processes and self organizing teams.
* Why do we separate Java and .Net developers? * Why do system architects choose frameworks and write UML diagrams but do not write any code? * Why do we measure how many lines of code a developer writes? * Why is agile adoption in traditional organizations hard? The theories of Frederick Taylor and those that followed today still sets the norm for how organizations are managed. What we see as normal and common ways to organize work is in fact making agile adoption difficult, hindering empirical processes and self organizing teams. The talk points these patterns and their effects and shows how to avoid the to not miss the benefits of an agile development process.

Cloud computing have received a lot of attention the last couple years for being the next generation IT infrastructure. We'll look at what are the characteristics for a cloud-enabled application, how data grids work and then dig into why these two technologies are such a great match.
Cloud computing have become the new buzz word and must have for all CTO's, but there's rarely consensus about what it really is and how it can be made accessible by most organizations out there. Usually this term is used in conjunction with names like Salesforce.com, Google or Amazon EC2 and each of these companies deliver this kind of services, but in very different ways. This presentation will start off looking at typical characteristics of a cloud environment and what business value organizations try to get by moving in that direction, either through cloud-providers or by building their own private clouds. We'll then dive into typical characteristics of a cloud environment to see what's different and the see what characteristics a cloud enabled application get in a that kind of environment. It's not always straight forward to take a Java EE application and get it running in a cloud-enabled environment. We'll therefore be going through some challenges that you may face when deploying in a cloud environment and look at different ways to get around that. Finally we'll go back to some of the business requirements mentioned earlier and see to what degree a cloud environment is needed for that?

Dette foredraget vil sette fingeren på to hovedelementer som kan være med på å skape mye mer verdi i softwareprosjekter.
Softwarebransjen har i den senere tid vært fokusert på å øke produktiviteten. Vi tar stadig ibruk ny teknologi og moderne systemutviklingsmetoder for å optimalisere produktiviteten i gjennomføringen av softwareutvikling. Likevel så stanger vi hodet i veggen dersom vi betrakter mange softwareprosjekter fra et "verdiskapning over livsløpet" perspektiv. Dette foredraget vil sette fingeren på to hovedelementer som kan være med på å endre dette bildet. Del 1. Valg. Tar vi de riktige valgene? Vi begynner med å se på prosessene og resultatene rundt nøkkelbeslutninger for implementasjon, hvor vi eksemplifiserer hvor tilfeldig viktige valg faktisk blir tatt. Vi vil også se på hvordan et fokus på teknologi-egenskaper kan gi oss et rammeverk for å ta valg som kan gi betydelig større verdi i softwareprosjekter. Del 2. Arkitektur. Arkitektur er en brannfakkel om dagen, og det ikke uten grunn. Det skrives opp og i mente om arkitektur og anti-arkitektur. Vi vil i denne delen av presentasjonen undersøke og sette spørsmålstegnet på om vi kanskje i 2009 begynner å se konturene av gode mulige arkitekturelle byggesteiner som faktisk er forutsetningen for å investere i arkitekturen i et system og hvordan disse kombinert med å ta bedre valg kan være en måte å skape mye mere verdi enn dagens norm i softwareprosjekter.

Erfaringer fra utvikling av en solid og konfigurerbar plattform for meldingsbehandling og integrasjon. Systemet knytter sammen tusenvis av kunder, behandler ti-tusenvis av utvekslinger hver dag og støtter viktige formater og protokoller.
Etter en runde med produktevalueringinger valgte vi å utvikle vår egen plattform for integrasjon og meldingsbehandling basert på Java og J2EE. Lyntalen tar for seg valgene vi gjorde, hvilke teknologier som benyttes, hva som fungerte i praksis, litt rundt ytelse og hva vi ville gjort annerledes. Stikkord er JEE, MDB, XML, EDI, WS, SMS, SMTP/POP, FTP/SFTP.

In this presentation, we provide a glimpse on the advances that have been booked by the software engineering research community for analyzing code smells and discuss some empirical results from studies on refactoring strategies. Our aim is to give developers and architects useful insights for prioritizing refactoring tasks and suggest different ways of combining source code analysis and human evaluation for supporting software evolution in their daily work.
Who hasn’t been confronted with the famous “spaghetti code” characteristic that occurs so often in projects that have undergone years of development? Such types of code are typically hard to understand and maintain, and could scale-up to the system level, leading to a phenomenon we call “software entropy” or “code decay”. Most of the work done by software developers is concerned with extending and enhancing existing systems rather than producing new systems (see [1,2,3]). Software entropy seriously hinders these activities, which can substantially increase the total project costs, thus it has become an important area of concern for many software architects and managers. To address this issue, companies have increased their focus on evaluating and improving maintainability of the code base. For example, Microsoft’s Office division assigned 20% of its development effort to re-develop/modify the code basis of their products [4]. A typical way to evaluate maintainability is to use code metrics to measure characteristics of the system. However, the problem with metrics is that they are hard to interpret and they do not provide clear guidance for improving the quality (What does a Cyclomatic Complexity of 342 mean? What can I do to improve this number?). With the increasing adoption of agile development methods, practices like refactoring [5] and the use of code smells [6] for source code analysis have become popular in pursuit of the holy grail of producing “beautiful code”. In general, these practices support software evolution and improve maintainability. However, not all refactorings pay-off in all situations and not all code smells are as “smelly” as one may think. Architects and developers still face the challenge of making redesign and refactoring decisions based on questions like: Which are the worst code-smells we need to get rid of? Which are the less risky refactorings? How can we do more “smart” and cost-effective refactoring? Are these notions built over code smells just a myth in order to achieve the beautiful code or do they really have practical consequences? In this presentation, we provide a glimpse on the advances that have been booked by the software engineering research community for analyzing code smells and discuss some empirical results from studies on refactoring strategies. Our aim is to give developers and architects useful insights for prioritizing refactoring tasks and suggest different ways of combining source code analysis and human evaluation for supporting software evolution in their daily work. [1] C. Jones. Estimating Software Costs. McGraw-Hill, 1998. [2] K. H. Bennett. An introduction to software maintenance. Information and Software Technology, 12(4):257–264, 1990 [3] T. M. Pigoski. Practical Software Maintenance – Best Practices for Managing Your Software Investment. Wiley, 1997 [4] M.A. Cusumano and R.W. Selby, Microsoft Secrets USA: The Free Press, 1995 [5] Opdyke, W.F., Refactoring Object-oriented Frameworks. 1992, University of Illinois. [6] Fowler, M. and Beck, K., "Bad Smells in Code," Refactoring: Improving the Design of Existing Code Addison-Wesley, 2000, pp. 75-88.

The "lizard brain" is the oldest part of the human brain -- the part responsible for autonomic functions like breathing, heart rate, and navigating websites. OK, maybe not that last part, but your website should be easy to use. Stupid easy. Lizard brain easy.
"There’s an old story about the person who wished his computer were as easy to use as his telephone. That wish has come true, since I no longer know how to use my telephone." (Bjarne Stroustrup) The "lizard brain" is the oldest part of the human brain -- the part responsible for autonomic functions like breathing, heart rate, and navigating websites. OK, maybe not that last part, but your website should be easy to use. Stupid easy. Lizard brain easy. Any time your user spends figuring out how to do something -- even for a split second -- is wasted time due to poor design. Inspired by Steve Krug's book "Don't Make Me Think", this talk answers the question, "Why is that website so hard to use?" In this talk, we look at what make a "good" website "good". Simple changes in the layout or sort order can yield drastic improvements. We'll get inside the heads of typical users and see how their view of our website is drastically different than what we painstakingly planned out. You'll learn how to cater to "Browsers" and "Searchers" -- the human kind, not the software kind. "Lizard Brain Web Design" answers these questions and more in a funny and informative way.

How would you build and manage a Twitter-like clone if you were tasked with that job? Come join this session as the presenter discusses various strategies and software technologies.
What would you do if you were tasked with building a Twitter clone which was highly scalable? How would you test it? How would you manage the deployments? Join this intrepid presenter, who being all too ingrained with the concepts of RDMBSs, dips his feet in the world of non-relational databases, explores the ins and outs of key/value stores, BigTable, and other approaches, figures out how to manage deployments and investigates how to test the application so it won't ever go down.

Performance testing is important, so we want to do it as often as possible. Over the lifetime of an application the performance of it will change and it's important to be aware of these changes. In this talk, we will demonstrate what kind of benefits continuous performance testing will give your project using Grinder, Hudson and Amazon Web Services.
Performance is always an important aspect to consider when developing Java applications. In many cases the performance testing is done late in the project when the programming is finished, something that might be a problem if performance issues are discovered. It is a better approach to monitor performance from the beginning of the project and continuously compare performance numbers between each build of the application, thus ensuring that the application has the wanted throughput right from the beginning. Using Hudson (http://hudson.dev.java.net/) and The Grinder (http://grinder.sf.net/) we have written a small plugin to run performance tests regularly and compare the results in graphs and tables. This talk will demonstrate how it is possible to continuously monitor the performance of any Java application, not just web applications, with a few simple steps. We will also demonstrate how to use Cloud Computing (Amazon Elastic Compute Cloud - EC2) to distribute the performance tests. Using Cloud Computing is a relatively cheap and quick way to dynamically allocate a number of test-nodes in order to create as realistic test scenarios as possible.

Har du skrevet ditt eget ORM-rammeverk? Eller brukt integrasjonsplattformen din som dokumentdatabase? Har du kjørt alle metodekall over webservices? Det har vi! Dette erfaringsforedraget tar for seg et knippe arkitekturtabber og beskriver hvordan og hvorfor vi havnet i gjørma... og hvordan det føltes.
Etter mange år i bransjen har foredragsholderne samlet på grove arkitekturtabber fra sine prosjekter. Har du skrevet ditt eget ORM-rammeverk? Eller brukt integrasjonsplattformen din som dokumentdatabase? Har du kjørt alle metodekall over webservices? Det har vi! Dette erfaringsforedraget tar for seg et knippe arkitekturtabber og beskriver hvordan og hvorfor vi havnet i gjørma... og hvordan det føltes.

Foredraget vil ta for seg praktisk bruk av Compass mot JPA og eksempler på hvordan sammspillet mellom disse er løst.
I et av Mesans prosjekter - Arkivportalen.no, har kunden et stort behov for å kunne gjennomføre fritekstsøk mot Java objekter som er persistert i en database ved hjelp av JPA. Vi har dermed implementert en løsning der du kan utføre fritekstsøk mot disse Java objektene. Løsningen benytter Open Source rammeverket Compass som bygger på Apache Lucene. Compass har gjort oss i stand til å levere fritekstsøk sammen med og inkludert i en standard JPA applikasjon kjørende på Suns Glassfish applikasjonsserver. Foredraget vil ta for seg praktisk bruk av Compass over Lucene mot JPA og eksempler på hvordan samspillet mellom disse er løst, gjennom erfaringer fra prosjektet arkivportalen.no. Bakgrunnen for løsningen vil være introduksjon til presentasjonen. I hoveddelen vil det fokuseres på krav til løsningen og hvorfor man ønsket å bruke fritekst søk mot databasen og hvilke krav som ble stilt til løsningen i forhold til søkemuligheter. Videre tar vi for oss bruken av Compass og Lucene sammen med JPA og hvordan dette har blitt løst og konfigurert, for å oppnå best mulig resultat. Arkivportalen.no er delvis et nyutviklingsprosjekt samt en web utvidelse av en eksisterende løsning. Vi kommer derfor også til å vise hvordan man kan innføre bruk av Compass og Lucene mot eksisterende løsninger. Avslutningsvis vil vi ta for oss våre erfaringer så langt, og belyse både positive og utfordrende egenskaper med bruk av Compass og Lucene som fritekst søkeverktøy i en JEE applikasjon.

Har du sett: "person.getAdresse().getGateAdresse().getHusnummer()" før? Har du skrevet den? Hvorfor?
Java er et objektorientert språk. Hva vil dette egentlig si? "Objekter, abstraksjon, innkapsling, SOLID prinsipper". Når vi har all denne kunnskapen, hvorfor ender vi opp med domenemodeller uten logikk og enkapsulering - og person.getAdresse().getGateAdresse().getHusnummer(); Er domain driven design noe mer enn en måte å belyse disse prinsippene for oss enda en gang? Denne sesjonen vil gjennomgå hva domain driven design gir deg ut over de objektorienterte prinsippene, og vise hvordan konsepter som et felles domenespråk kan hjelpe oss med å håndtere kompleksitet i applikasjonene våre.

We will cover the new features in Spring 3: expression language support, REST, fully generic API, and more!
With the Spring Framework 3.0 release, we are introducing further annotation-based configuration options, unified expression language support and comprehensive REST support. This talk discusses Spring as a modern Java 5 oriented application framework: covering the core component model, annotation-driven web MVC as well as platform integration. This would be more interesting to existing Spring users.

In this session we'll take a tour of the Java class loading mechanism, both from JVM and developer point of view. We'll see how different delegation systems are built, how synchronization works, what is the difference between finding classes and resources, what wrong assumptions has been made and are now supported.
Class loaders are at the core of the Java language. Java EE containers, OSGi, NetBeans modules, Tapestry 5, Grails and many others use class loaders heavily. Yet when something would go wrong, would you know how to solve it? In this session we'll take a tour of the Java class loading mechanism, both from JVM and developer point of view. We'll see how different delegation systems are built, how synchronization works, what is the difference between finding classes and resources, what wrong assumptions has been made and are now supported. Next we will look at typical problems that you get with class loading and how to solve them. ClassNotFoundException, ClassNoDefError, LinkageError and many others are symptoms of specific things going wrong that you can usually find and fix. We'll review ways to fight with JAR hell and JAR locking and caching. Finally we'll take a look at things in the class loader world that are broken beyond repair and how to recognize and work around them.

Most web applications need integration capabilities but don't need the complexity of an ESB solution. Typically, web apps need a simple solution for performing common integration tasks such as receiving and sending messages over Email, JMS, FTP, calling a Web Service or REST services such as Facebook or Twitter. This talk will introduce Mule iBeans, a new integration framework specifically for Web Application integration. Mule iBeans focuses on task-based integration without introducing new complexities or architecture considerations.
The ESB is not well suited for simple Web Application integration. The Web application model has evolved to the point where the presentation/logic/data tier model is a bit limited since applications need to be connected to other applications and services. There are lots of ESB-type solutions out there for dealing with this shift but they often introduce new complexities or concepts that create a barrier to entry. This talk will provide working knowledge of how to hook in external services to your Web Application without the complexity. This session will introduce a new framework, Mule iBeans that focuses on task-based integration for web applications. The audience will learn how to integrate their web applications with other applications and services on the web and the enterprise in a way that doesn't add complexity to the code or architecture of the application. Using a couple of simple constructs developers will be able to integrate with services such as Flickr, JMS, Twitter, Google Maps and Email in minutes.

Mange sier de har en ekte Scrum, men egentlig har de fått en ScrumBut i huset. Få ett grunnkurs i ScrumButtens anatomi; lær å gjenkjenne, håndtere og akseptere Scrum sin ofte misforståtte artsfrende.
En ScrumBut er en mindre kjent, men ganske utbredt art av familien Scrum. Arten ble først kjent på begynnelsen av det 21 århundre, og har nylig blitt lagt til i det smidige artsregisteret. Kjennetegn inkluderer burndowns som aldri når null, ufokuserte standupmøter og sprinter med liten betydning. Nyere forskning viser at mange tidligere rapporterte observasjoner av Scrums, egentlig har vært observasjoner av ScrumButs. Denne lyntalen vil illustrere de mest synlige kjennetegnene til en ScrumBut. Deretter forklares hvorfor ScrumButten kan være ett nyttig innslag i den lokale fauna, og hvordan man kan gå frem om man finner en i hagen. Det er vanskelig å kjøre Scrum etter boka; mange sliter med å gjøre det "riktig". Husk at boka og guruen bare er brostein på veien til lykke. Adopter en ScrumBut idag!

Rules engines are getting a huge footprint in the market, and for certain areas they are a good match. Should you let a rules engine rule your application?
Rules engines are a hot topic in many large and small projects. When faced with the decision to choose either a rules engine, or to choose a rules engine at all there are many considerations to make. This talk will draw a line between what's real and what's perceived benefits of rules engines. When faced with the decision it will help you choose between rolling your own domain logic, or a rules engine. We will outline what impacts the choice of using a rules engine has on your project, and what implications it has to areas such as development, testing and architecture. Further on we will draw the line between domain logic and rules, and give criteria for when to choose one over the other. Topics that will be discussed: * Do we need a rules engine just because we have rules? * What are the drawbacks and benefits of using a rules engine? * Are the benefits real or perceived? This talk will bring together experiences from several large and small projects using rules engines. Some of them are amongst the largest projects in Norway that are currently implementing a rules engine based solution.

Companies that don´t innovate die, and most innovations fail. How can the theories behind Open Innovation help us make the most out of existing inventions and combine them with appropriate business models to create profitable businesses?
Many great companies fail to understand technological change and how it might affect them. Their current customers and existing business models that have served them so well in the past can turn into a curse in the light of disruptive innovation. Moving from closed to open innovation will help companies to get the most out of both their own inventions and the inventions of others as well. Can companies remain innovative over time?

In this session you will learn how to develop applications for the Google App Engine ecosystem. It will include an overview of the App Engine environment for Java and Python, then shift focus to Java-specific development and the differences, advantages, and features.
Google App Engine for Java is the most recent contestant in the war for the low-cost, high-availability cloud computing environments. This presentation introduces the technology and its operational model, how it’s alike and how it differs from running Java apps in traditional app server environments, and what kinds of things developers and app designers will need to plan, build, deploy, and maintain Java applications that will run on Google’s App Engine infrastructure.

Learn how Qi4j radically improves persistence for domain-rich applications.
Qi4j, the radical approach to domain-rich applications with Java, is turning most so called wisdom of our industry on its head. Instead of building on top of low level abstractions, Qi4j starts at the business value, business modeling and solves the technology stack from top to bottom. No rock is left unturned, and exciting new modeling discoveries have been made along the journey. In this presentation we will cover the Persistence approach, how Qi4j is capable of decoupling the domain model from the underlying persistence system, able to swap persistence without change of code, able to express queries in Java without depending on the underlying query language, and how long-running "Unit Of Work" is superior to database transactions when it comes to domain modeling.

Vi vil oppsummere hva "cloud computing" er, fortelle om utfordringer med å bruke klassisk java-arkitektur på systemer som skal kjøres i en sky, og vise hvordan problemene kan løses.
"Cloud computing" er en av de varmeste potetene i IT-verdenen i dag. Man har flere typer skyer, flere leverandører og mange forskjellige måter å sette sammen sine systemer. En forutsetning for å vurdere utvikling av en cloud-basert løsning er at man har et problem som går utover en maskin. Dette kan være problemer knyttet til skalering, tilgjengelighet, replikering, backup, mm. Man har behov for å skalere horisontalt. Slike krav kan i stor grad påvirke systemets arkitektur og valg av teknologier. I dette foredraget vil vi systematisere problemstillinger til arkitekturer for systemer som kjører i en sky, og komme med konkrete forslag til arkitekturer og løsninger. Noen av emnene vi vil dekke er: * Feature-orienterte applikasjoner * Utviklingsprosessen * Tilstand * REST * Versjonering * Rullende oppgradering * Skalering * Tilgjengelighet * Dokumentdrevne databaser * Replikering * Økonomi Dette er en oppbygning til foredraget "En Praktisk guide til Høytsvevende Arkitekturer".

Smidig metodikk er som skapt for god interaksjonsdesign! Jeg forteller hvorfør og hvordan man får det til!
Hvordan kan og bør interaksjonsdesigner jobbe i smidige prosjekter for å oppnå best mulig resultat og samarbeid sammen med teamet og kunden. Jeg tar utgangspunkt i egen erfaring som interaksjonsdesigner i smidige prosjekter og forteller om hvilke metoder og prosjektkonstellasjoner som jeg syns har fungert best.

This session will explore how to use Java, JavaFX and the remote control from a Nintendo Wii to drive some strange and unusual user interfaces.
The Nintendo Wii has changed the way many people perceive computer games, shifting from the traditional console to a more natural, physically interactive experience. To achieve this, the Wii includes an innovative remote control (or Wiimote). To provide control of an on-screen cursor, the Wiimote has a special camera that can track up to four points of infrared light and report their positions in real time. This session explores how the Wiimote can be used in ways not originally intended by the Wii designers. Example applications keep the Wiimote stationary and use it to track moving infrared LEDs, which can be mounted on a pen, a screen, or even an umbrella. Data about the position of the infrared lights can be used to control the position of images so they are always projected on a screen or to provide a virtual whiteboard environment. The demonstrations use JSR 82 (Java™ APIs for Bluetooth), the WiiremoteJ open-source API, a Java platform library, and JavaFX™ code to drive the user interface. The session shows how JavaFX technology really is, "for all the screens of your life", including ones you've never thought of.

Many developers approach the task of creating a user interface in much the same way five year olds play soccer. Everyone runs around chasing the ball without a plan or sense of the tactics involved in soccer. This talk is a helping hand for those of you who wants to learn the secrets of how to become a good user interface developer.
With the financial crisis is sweeping the globe and once again there will be a call for developers world wide to become more versatile. This means more programmers having to do user interface work along with their regular tasks. Most developers approach the task of creating a user interface in much the same way a team of five year olds play soccer, everyone runs around chasing the ball without a plan or sense of the tactics involved in soccer. This talk is a helping hand for those of you who wants to learn the secrets of how to become a good user interface developer. Working with user interface development is nothing different from regular programming. This talk will introduce you to the essence of programming UI. You will be given tools and methods which will help you enter a state where you and your user interface become one.

Solr is a star in the enterprise search world, powering very popular ecommerce systems, content management systems, and many other internal and externally facing search systems throughout the world. This presentation will show you the power and ease of use of Solr in a fast paced "zero to search" live demonstrations of the Lucene powered Apache Solr technology.
In this session Erik will launch Solr and index various types of content including database, file system rich documents (PDF, Word, HTML, etc), XML, CSV, Atom feeds, and perhaps others. Various ways to interact with and build upon Solr's capabilities will be demonstrated, including several user interface starting points and pragmatic real world operations such as scheduling indexing operations and scaling for load and corpus size. We'll see within the live demonstrations Solr's popular features: * full-text search * faceting * highlighting * more-like-this * spell checking / did-you-mean * API from Java, Ruby, command-line

Is your code perfectly decoupled, reusable and generic? Maybe it shouldn't be. In this example-driven talk, we strike a blow for simplicity. We take to task current notions of high-quality software architecture and show how even modern approaches are needlessly complex.
Reuse, genericity and decoupling have recently been treated as the very goals of software development. But they are not. You probably feel you should reuse as much code as possible, be it your own, that of you organization or third party open source or commercial software. But just because the code is already written doesn't mean you won't have to understand, debug and maybe even change it. You probably feel you should write your code in a generic fashion so it can be reused. But generic code can be harder to understand. And making a piece of code flexible to certain kinds of changes will make it less flexible to other changes. Moving decisions to configuration can make your code more generic, but often, it will increase the cost of change. You have probably learned that you must reduce the extent to which parts of your code is coupled to each other if you are to create maintainable code. So all your objects reference each other through interfaces and are wired together in huge XML files. But this makes the code harder to navigate and refactor. In the quest for better software reuse, genericity and decoupling has become ends in themselves. In this talk, we will show how examples of how contemporary notions of good design have led us and others to solutions that are overly complex. "A good design" is not a goal in itself. The goal is a system that requires as little effort as possible to develop and change. Proper use of reuse, decoupling and genericity can help with this goal. Improper use almost always hurts. So how do you measure something like simplicity? We would like to revive an often reviled metric: Lines of code. More specifically, how many executable statements do you have to deal with to maintain the code? Software developers have to be smart. But if you sometimes get the feeling we're too smart for our own good, this talk is for you.

Learn how to persist large and rich domain models in a performant and scalable way
The tenets of Domain-Driven Design are well documented, and its mindshare has expanded massively in recent years, due to the brilliant work of Eric Evans and others. However, knowledge on persisting large and rich domain models, especially in a performant and scalable way, is basically non existing. Lessons learned by architects of high-scale DDD/OO-based systems in production settings are largely absent from the professional literature. And yet such knowledge should be of significant value to current practitioners responsible for the development or operation of such systems with performance and scalability concerns. Therefore this seminar talk will focus on the persistence of domain models, the typical problems that arise around performance, scalability, and transaction isolation in domain model persistence, some observed solutions to those problems, and the consequences of those solutions for application architecture. Drawing on the presenter's two decades of experience practicing DDD in multiple production systems, with different programming languages and various object persistence technologies, the talk will briefly survey the evolution of object persistence approaches, noting their performance, scalability, and isolation characteristics, culminating with exciting new possibilities offered by data grid technologies. However the bulk of the emphasis in the talk will be placed on patterns of domain model persistence with current Java ORM technologies.

En erfaringspresentasjon fra et Ruby on Rails prosjekt.
Ruby on Rails applikasjoner går for å være mer effektive å utvikle enn tilsvarende applikasjoner i Java. Dette fikk vi også erfare da vi utviklet en funksjonsrik Ruby on Rails applikasjon klar for produksjon på 3 måneder. Applikasjonen erstattet en eksisterende Oracle Forms applikasjon med over 200 skjermbilder med CRUD funksjonalitet. JRuby ble valgt for å støtte integrasjon mot eksisterende Java kode, samt krav om deployment på JBoss.

Prosjektet FriKomPort har vært gjennom flere faser med forskjellige finansieringsmodeller. Foredraget er en oppsummering av disse og en presentasjon av dagens modell og hvorfor vi har valgt nettopp denne.
FriKomPort er en løsning for å administrere kurs/arrangement og påmeldinger til disse. Finansieringmodellene vi har benyttet oss av er Stafettfinansiering og Dugnadfinansiering. Løsninga var i første omgang betalt av kunden Kongsbergregionen, som er et kommunalt samarbeidsorgan for 8 kommuner i Buskerud og Telermark. I etterkant har andre kunder betalt for egen funksjonalitet som har komt alle brukerene til gode. Etterhvert har brukergruppen blitt så stor at vi har innført et utviklingsabonnement som gir brukerene tilgang til å være med å påvirke i hvilken retning prosjektet skal bevege seg med hensyn til funksjonalitet og videreutvikling. Tanken er at jo flere som har interesse av at løsningen lever, desto flere vil være med på finansieringen og dermed dele på kostnaden ved utviklingen.

Learn how to have as much fun with legacy code as you have on "greenfield" projects.
Everybody loves to start with a clean slate and build software from scratch. Unfortunately, such "greenfield" projects are hard to come by and most of us work with less glamorous "brownfield" software. A "brownfield" application can be a monolith you've inherited from others, a new project that needs to use existing legacy components or third party solutions. In this talk Anders Norås shares his real-world experiences on how to approach "brownfield" applications with the state-of-the-art concepts, patterns, and tools you've learned to apply to new projects. You'll learn what patterns you can apply to shield yourself from legacy cruft, how to find good refactoring opportunities and when choosing suboptimal designs for parts of your solution can help the solution as a whole. Whether your maintaining an existing application, building new software atop of legacy components or simply cleaning up the mess others left behind, you're sure to pick up some tricks to combat the designs that otherwise would ruin your day.

Data er viktigere enn kildekode på grunn av normalt lengre levetid. Åpne data er fritt å bruke og utvide, og skaper merverdi for både opphavsmenn og brukere. Åpne data har gitt stor verdi til de som har våget å gripe muligheten, og du selv kan gjøre det i dag!
Data er viktige, og i stor grad mye viktigere enn kildekoden til programmene som skaper dataene. Dette er fordi data og ikke minst dataformater ofte har mye lengre levetid enn den koden de opprinnelig stammer fra. Bruk av åpne data kan derfor gi mange fordeler, både på mange områder innenfor egen virksomhet og for fellesskapet utenfor. Selskapet GoldCorp gjorde i 2001 sine familiejuveler, nemlig geologiske data for den gamle gullgruven Red Lake, tilgjengelig for alle på Internett. Deretter utlyste de pengepremier for å finne nye gullårer i datasettet, noe som tiltrakk seg hundrevis av forslag fra hele verden hvor også svært mange førte til nye gullfunn. Både slik crowdsourcing og annen bruk av åpne data viser hvordan man kan sikre god organisering, håndtering, tilgjengelighet og optimal utnyttelse av viktige data, langt inn i framtiden! Gjennom denne introduksjonen til åpne data vil dette foredraget gi tilhørerne et utgangspunkt for å lære mer og ta i bruk åpne data på egen hånd.

One web.
The web is the biggest information revolution since the advent of printing. Simple languages like HTML and CSS has made it easy to publish information that can reach a billion browsers. HTML5 and CSS3 are emerging specifications that will will make web pages richer, more compact, and more standards-complient. This presentation will demonstrate new features, and discuss how long they will last.

Datamaskinprogrammer egnes som litterære verk og vernes etter åndsverkloven. Det betyr i utgangspunktet at de reguleres av de samme bestemmelsene som f eks norsk lyrikk. Hvordan har det seg egentlig at dette ble resultatet – og er det lurt? I et program er funksjoner viktig, mens formen kan være sentral i poesi – og opphavsretten verner bare uttrykket. Opphavsmannen får en enerett til å utnytte verket – både poesi og program. Men til gjengjeld skal hvem som helst kunne lese lyrikken, skjønne den, bli klokere og dikte videre selv. Et program i objektkode lar seg i praksis ikke lese – er dette en slags bristende forutsetning for å gi det vern?
Datamaskinprogrammer egnes som litterære verk og vernes etter åndsverkloven. Det betyr i utgangspunktet at de reguleres av de samme bestemmelsene som f eks norsk lyrikk. Hvordan har det seg egentlig at dette ble resultatet – og er det lurt? I et program er funksjoner viktig, mens formen kan være sentral i poesi – og opphavsretten verner bare uttrykket. Opphavsmannen får en enerett til å utnytte verket – både poesi og program. Men til gjengjeld skal hvem som helst kunne lese lyrikken, skjønne den, bli klokere og dikte videre selv. Et program i objektkode lar seg i praksis ikke lese – er dette en slags bristende forutsetning for å gi det vern? Noen av disse spørsmålene besvares, samtidig som det gis en kort innføring i det opphavsrettslige vernet av datamaskinprogrammer, overgang av rettigheter i arbeids- og oppdragsforhold, og forholdet til patentering av programmer. Det forutsettes ingen forkunnskaper, så foredraget innledes med en presentasjon av opphavsmann, åndsverk og enerettene til å råde over programmet.

Redis is a new kind of key-value database. It is a scalable high-performing distributed in-memory database that supports atomic and non-blocking operations. This presentation will give an introduction to this new open source project.
Redis is a key-value database that stands out from the crowd. It is not just another key-value database as it provides atomic and non-blocking operations on its keys and values. In Redis the values can be either primitives, sets or lists. Most other key-value databases allow only simple values like strings or bytes. There are commands to perform complex operations on these data structures, most in constant time. It is therefore not unreasonable to think of Redis as a data structures server. The dataset can be replicated using a master-slave setup and also be distributed across a set of servers using consistent hashing. The server provides blazing performance as most operations are non-blocking and the entire dataset is kept in-memory. Performance tests have shown results of 10000 SETs/second, 81000 GETs/second on an entry level Linux box. Redis is open source, and the database server and clients are being hosted on Google Code. The project is aiming for a final 1.0 release mid June 2009. In the presentation we'll take a look at the characteristics of the database server and the operations that it provides including demos of how it works in practice. The Java client will also be reviewed.

En innføring i utvikling av et eksternt domenespesifikt språk i Scala. Med fokus på det praktiske, vil veien fra tekst til et fungerende språk presenteres
I blant har man behov for et lite domenespesifikt språk, for eksempel for konfigurasjon. Der en intern dsl av forskjellige grunner ikke strekker til, velger man gjerne enten svake property filer, eller verbos og vanskelig xml. En bedre løsning kan være å skrive et eget språk, spesialisert for oppgaven. Combinatory parsing, kjent fra funksjonell programmering baserer seg på å kombinere små enkle parsere for å bygge en komplett og mer kompleks parser. Scala, et moderne og kraftig språk for java plattformen, kommer med parser combinator bibliotek som en del av standard distribusjonen. Foredraget vil presentere hvordan man kan implementere et lite programmeringsspråk i Scala. Fokuset vil være på det praktiske mer enn det teoretiske, der det blir gitt en innføring i alle stegene nødvendig for å skrive et eget lite programmeringsspråk som kan benyttes fra Java.

If all you need is a Bicycle, having a Space Shuttle instead isn't a good thing. Processing high volumes of data in batches using message oriented architecture and a relational database is something you should avoid (unless you are a real rocket scientist!). Instead you can try an easier approach using standard Java SE. This talk is about handling high volumes of data from legacy systems using Java.
You may think this is a stupid presentation. Who would ever get millions of transactions in files from a legacy system? Transactions will be placed from Web and properly load balanced as they get in. But the fact of the matter is, don't be so sure. There is a lot of legacy systems out there. In 1997 the Gartner Group estimated that there were 240 billion lines of Cobol code in active apps. Something like 90 percent of financial transactions are processed by Cobol code, and 75 percent of all business data processing is Cobol. Most of that code is still there after being fixed for 2000 bug. So why is all this Cobol stuff relevant to me? I develop using Java, not Cobol (Thank God!). It's relevant because Java is ready for the heavy lifting of replacing all this code. But since all systems can't be replaced in one go, you must interface with the existing solutions. Doing that using typical Java stack in the typical Java way, can give you an over-engineered and badly designed solution. The speaker spent the last 3,5 years as a software architect and developer replacing large mainframe applications using best practice Java architecture (Message oriented, Spring, Hibernate etc). Doing so he realized that new techniques have their place, but processing large batch files using Domain Driven Design and Hibernate probably wasn't the easiest way of dealing with legacy code and integration.

Scala is a modern programming language on the Java VM, combining the best of OO and functional programming. Wicket is a popular stateful component-based web framework. In this talk we present these two technologies and some of the observed strengths and weaknesses of combining them.
Tired of XML in your web applications? Looking for a better language which lets you do more with less? Scala is a modern programming language on the Java VM, combining the best of OO and functional programming. Wicket is a popular stateful component-based web framework. We have developed SubmitIT, a web application to collect presentation proposals for the JavaZone programme committee. In this presentation we start by giving some background on JavaZone, the review process and the pains of a growing conference. Then we introduce SubmitIT and give an overview of the core technologies used, Scala and Wicket. We present some of the challenges we had to overcome when combining a Java-based web framework with Scala, as well as the available tool support. Finally we conclude with some remarks on productivity and code quality.

Cucumber (http://cukes.info/) is a novel tool for Behaviour Driven Development. While most existing TDD/BDD tools are geared towards programmers, classes and objects, Cucumber nicely fills the communication gap between customers, programmers and testers.
Cucumber’s plain text language for describing an application’s behaviour has become a popular tool for many Ruby and Rails teams. With the recent Java support this great tool can be used on Java projects without a single line of Ruby. In this session you will see how Cucumber and BDD can be used on a real Java project. You will learn how to use Cucumber's simple and extensible domain-specific language that lets you marry functional requirements and automated functional tests into one. I will also show how to install and run Cucumber and give you some useful tips about how to get the most out of the tool and the process it is based on. The presentation will be in the form of a small, fast paced project, alternating between customer-team conversations and real-time programming with Cucumber and Java. This session will change how you approach requirements and testing of Java applications.ed project, alternating between customer-team conversations and real-time programming with Cucumber and Java.

Overviews the issues surrounding scaling agile techniques for distributed development teams, regulatory compliance, governance, large teams, complex environments, and leveraging legacy assets.
The majority of organizations have gotten their feet wet with Agile software development techniques and are now hoping to take it to the next stage. However, they’re discovering that the simple methodologies they initially adopted aren’t sophisticated enough to address the complex situations they find themselves in. This presentation overviews agile software development, shares data from recent industry surveys as to the adoption rate and success rate of agile techniques, and explores scaling issues such as distributed development teams, regulatory compliance, governance, large teams, complex environments, and leveraging legacy assets. Practices from the Rational Unified Process (RUP), Agile Modeling (AM), and Lean Development Governance which help to address scaling factors will be described in detail, as will tooling strategies. Once you go beyond the Agile rhetoric you will find that you can in fact scale it to meet the complexities of the real-world situations you find yourself in.

An introduction to the Ioke language.
Ioke is a new language, an experiment to see how expressive a language can be. It's a language for the JVM influenced by Io, Self, Smalltalk, Lisp and Ruby. It supports a prototype based object oriented system, is homoiconic, supports high level methods and macros and makes it easy to build DSLs and new abstractions from scratch. The presentation will first talk about the motivation for a new language, then talk about some of the more interesting features of Ioke, including the object system, the macro system and java integration features. It will also talk about how Ioke can be used in conjunction with other languages in a polyglot programming style.

Let the Grails Web Application Framework turbo-charge your JavaEE development.
Many enterprises have made heavy investments in the JavaEE platform. While powerful for complex problems, the productivity of the JavaEE platform has recently been challenged by dynamic web application platforms like Ruby on Rails, Django and Lift. But how can you benefit from the extreme productivity of these dynamic platforms, while still protecting your current investment in the JavaEE platform? Enter Groovy and Grails! Groovy is a dynamic language for the Java Virtual Machine, which integrates seamlessly with any existing Java technology. The Grails Web Application Framework is an advanced and innovative Web-application framework based on Groovy, which delivers excellent productivity regardless of whether you build your application from scratch, provides a Web GUI on top of your JPA entity model, or a Rest based Web Service adapter to your existing Spring or EJB3 based service layer. In this talk, Björn Beskow shows how Groovy and Grails can be efficiently added to your existing JavaEE environment and dramatically boost your developer's productivity.

Have you ever wondered whether you should use a weak reference or a phantom reference? If you answered "yes" or "phantom who?" this is the session for you
Have you ever wondered whether you should use a weak reference or a phantom reference? If you answered "yes" or "phantom who?" this is the session for you. It covers * The java.lang.ref API * Its gotchas and pitfalls * New APIs that address those gotchas and pitfalls * Reference handling patterns and best practices * ReferenceMap: a new concurrent map with support for strong, soft, or weak keys and values * How references relate to collections, caching, concurrency, and class loaders * And more Walk in with a working knowledge of the language, and walk out an expert in references, referents, reclamation, and other garbage collection necromancy.

This DDD panel debate will be led by Kevlin Henney.

Since applications were put on the web, developers have accepted loss of functionality and control of their product's user experience. We now have the tools to easily retake the web, and give users the functionality they crave.
h1. Problem scenario You are to replace a mainframe system, where the user interface consists of a black console with screens of green text, with a web application. Even though the screens are unintuitive, skilled users can navigate and manipulate the data efficiently. The expensive, high-tech, replacement web application has all kinds of nifty features to please the user visually. But a simple request, such as utilizing function keys and mouse-less navigation can be hard to cater for, because the IT department has standardized browsers on IE6. h1. The proposal Create your own thick client frontend which wraps a web browser widget. Such widgets are maturing and easy to customize. They render advanced pages, tackle JavaScript and Flash just as good as standard browsers. You now have a new layer where you can take control of the user experience where needed. The web page will behave as normally, but you can specifically tailor functionality for the whole application, or the context of a specific page. h1. if( FAIL ) ? If the frontend fails, it was hopefully a cheap investment to throw away. The web application can still be used with a normal browser.

Fordi de fleste applikasjoner har forretningsregler mener enkelte at man trenger en regelmotor. Imidlertid medfører regelmotoren ofte høy kompleksitet og kostnader, i tillegg til at salgsargumentene er en illusjon. De fleste applikasjoner er tjent med håndtering av regler i kode eller en DSL.
Fordi de fleste applikasjoner har forretningsregler mener enkelte at man trenger en regelmotor. De besnærende argumentene er enkel regelutvikling og -forvaltning utført av forretningssiden og fortløpende endringer helt ut i det kjørende systemet. Når man starter utviklingen oppdager man at regelmotoren medfører høye kostnader innenfor utvikling, integrasjon og utrulling, dårlig støtte for automatisert testing samt spesielle krav til kompetanse og lisensbehov. Illusjonen om at forretningssiden skal skrive og vedlikeholde reglene blir etterhvert smertelig tydelig, og reglene må inngå i test- og utviklingsregimet som all annen applikasjonslogikk. Langt de fleste applikasjoner er tjent med å håndtere reglene i vanlig kode, alternativt med et enkelt DSL.

Utivkling av parallelle systemer blir stadig viktigere. Hvor mange utviklere behersker egentlig dette? Vi går igjennom noen enkle caser for å belyse problemstillingen.
Høyere ytelse oppnås ikke lenger ved å øke klokkehastigheten, men ved å kaste flere prosessorkjerner på problemet. Allerede i dag er det vanlig med 4 kjerner på skrivebordet, og denne trenden vil bare fortsette fremover. Hvis en ikke makter å utnytte parallelliteten, vil man om ikke lenge utnytte kun få prosent av ytelsen i systemet. For å kunne utnytte systemet fullt ut, må man få et bevisst forhold til parallellitet. Hvor mange utviklere behersker egentlig dette? Vi vil belyse denne problemstillingen gjennom noen enkle caser basert på bruk av tråd-mekanismer som finnes i Java i dag.

In this talk I will show how a mashup of Confluence and the Enterprise Architect UML tool can be used as pragmatic and agile tools for creating good and maintainable architecture documentation.
h1. The problem Creating good architecture documentation is often a problem in many large projects and organizations. Common issues are: * Out of date documentation in various MS Office formats * Architecture documentation is spread around the filesystem and mailsystem making it difficult to find the most current version of the documentation * Cumbersome and costly (enterprise) architecture tools * Using tools that are not well suited for multi-user updates * Developers are unwilling to document * Non-standard modelling conventions * Duplicated and inconsistent information * The list goes on... h1. The solution A pragmatic and agile solution to most of these issues is to create a mashup of the Confluence wiki tool together with a UML tool like Sparx Enterprise Architect. A wiki such as Confluence is very well suited for agile "grassroots" knowledge management and documentation. It keeps documentation in a single place, makes it easy for a group of people to work on the documentation together, it has a good search function, and it has proven to be a tool that most developers like to use. A mashup integration of Confluence with the Enterprise Architect UML tool creates a powerful combination of two good tools. UML models are integrated in wiki pages, and the UML models will be updated automatically when the UML model is updated in the UML tool. Other topics covered in the presentation: * using the Java API of Enterprise Architect to publish UML diagrams to Confluence * creating a 4+1 view model of architecture in a wiki * using labels to ** organise the information and create views ** express relationships between various parts of the architecture model * how to version control wiki documentation in Confluence

This summer, over 1100 developers reported that they waste an average of one month per year waiting for builds and redeploys. In 10 minutes, we'll show you how to get that time back, without the need to re-engineer your applications or change the way your team works.
It's quick, it's easy, it integrates with Maven, Eclipse, IntelliJ IDEA and Netbeans, supports all servlet and EJB containers, Spring framework, Struts, Stripes and Google Web Toolkit, and it pays for itself in two weeks -- meet JavaRebel 2.0.

Java reflection has some interesting abilities, not widely known, such as setting of final fields, discovering where in the call chain we are and the ability to make objects without calling a constructor. Based on topics from the Java Specialists Newsletter, it will make your ears ring and head explode.
In this presentation, we will look at some advanced uses of reflection to delegate method calls automatically, to determine where we are being called from and to create new enum values dynamically for unit test purposes, including modifying the switch statements on-the-fly. We will look at how we can use the stack information to determine the class type in a static context. We will demonstrate how Externalizable allows the private state of an object to be read and then modified. Lastly we will demonstrate how we can construct new objects without calling any of the available constructors. This talk will be aimed at the advanced Java specialist who does not shy away from reflection code. Topics from the Java Specialists Newsletter and related research.

By large the majority of us have been creating applications for the Web since the early 90's and we have "just" accepted the stateless nature of the Web and the fact that HTTP is limiting us to a request repsonse communication profile. With new emerging standards such as W3C's HTML 5 WebSockets we can change all of this!
By large the majority of us have been creating applications for the Web since the early 90's and we have "just" accepted the stateless nature of the Web and the fact that HTTP is limiting us to a request repsonse communication profile. Sixteen years later we have an opportunity to let Web communication take a gigantic step forward - if we let it - and forever change the way in which we build applications for the Web. Web applications have traditionally been seen as second tier citizens in our network infrastructure, not capable of fully participate in the backend message infrastructure due to its stateless architecture. One innovation - W3C's HTML 5 WebSockets - in particular will enable full-duplex communication, and finally bring an end to the tired request response paradigm traditionally associated with the Web, and allow browsers to become first class citizens in our network. With this new emerging standard and the potential it brings, it is now possible to simplify complex architectures and build statefull asynchronous systems and communicate with native protocols directly from the browser to any backend service. In this session, the speakers will offer their vision of the future of the Web, Web technologies, address the importance of browser support of the W3C WebSocket and Server-Sent Events standards, and offer insight into the key role developers' play in W3C standards proliferation and the impact they might have on the end users. During the session real-life demos and examples of the use of WebSockets and other communication standards such as Server-Sent Events and Cross-document messaging will be shown. The techniques and technologies covered in this session will include, but are not limited to, JavaScript, Flash, Silverlight, and communication protocols such as AMQP, XMPP, and Stomp.

The session will compare a number of Http clients and see how HTTPCache4j supersedes them all.
Have you ever tried to write a HTTP or RESTful client using the libraries out there? Using java.net.URLConnection or Commons HttpClient? How do you cache your results? Do you use a proxy? Is server side caching enough? NO! Enter HTTPCache4j. You may use the library as a standard HTTP client, using just the resolver modules. Or you may use it as a full blown HTTP cache on the client. Your choice.

An overview of alternative concurrency paradigms for the JVM (Actors, STM and Dataflow).
Writing concurrent programs in Java is hard and writing correct concurrent programs is even harder. What should be noted is that the main problem is not concurrency itself but the use of mutable shared state. Reasoning about concurrent updates to, and guarding of, mutable shared state is extremely difficult. It imposes problems like dealing with race conditions, deadlocks, live locks, thread starvation etc. It might come as a surprise to some people but there are alternatives to the so-called 'Shared-State Concurrency' (that has been adopted by C, C++, Java and become the default industry standard way of dealing with concurrency problems). In this talk we will discuss the importance of immutability and explore alternative paradigms such as Dataflow Concurrency, Message-Passing Concurrency and Software Transactional Memory (STM). We will have a pragmatic discussion on the drawbacks and benefits with each paradigm and through hands-on examples show you how each one, in its own way, can raise the abstraction level and give you a model that is much easier to reason about and use. We will show you how, by choosing the right abstractions and technologies, you can make hard concurrency problems close to trivial. All discussions are driven by examples using state-of-the-art implementations available for the JVM.

Although object-orientation has been the mainstream programming language paradigm a long time, and domain driven design has been one of the hot topics in application development for some time, many real world projects end up with an anemic domain model. This manifests a problem because we are unable to leverage language features to achieve an easily maintainable application.
Object-orientation has been the mainstream programming language paradigm for the last 20 years. One of the central techniques in object-oriented programming is encapsulation using objects that both contain data and behavior. Nevertheless, in real applications we tend to end up with anemic domain models as opposed to "proper" domain models, where we have objects that only have data and no behavior, or vice versa. In many cases this results in a procedural style of programming, rather than an object-oriented style, not leveraging the language's features. Encapsulation suffers, possibly resulting in tight coupling in the application. In this talk I will try to give some reason why this happens, which problems this causes, and possible ways to avoid it.

I mange år har SOA vært ”det neste store” og mange har prøvd å innføre dette i små og store prosjekter. Foredraget omhandler erfaringene fra innføringen av SOA i et av Norges mest komplekse IT-prosjekter og forsøker å gi svar på hvordan SOA virker i stor skala og om det faktisk gir de gevinster man ønsket.
I mange år har SOA vært ”det neste store” og mange har prøvd å innføre dette i små og store prosjekter. Mange har feilet og dermed har begrepet SOA mistet mye av sin glans. Foredraget omhandler erfaringene fra et prosjekt som innførte SOA i en av Norges mest komplekse IT-prosjekter og som har oppnådd gode resultater. I prosjektet har man fått etablert en SOA plattform som eksponerer tjenester fra mange forskjellige baksystemer og lagd automatiserte prosesser som benytter disse tjenestene. Å benytte gjenbrukbare tjenester fra forskjellige systemer direkte i en fleksibel forretningsprosess har vært selve drømmen som SOA skal innfri. Gevinsten skal være mulighet for raskere endringer og billigere forvaltning. Foredraget prøver å svare på om SOA kan innfri dette og hvor svakhetene og styrkene i en tjenesteorientert arkitektur ligger.

You've probably heard of JRuby. You may even have tried it. But a lot has changed in the past year, and JRuby is better than ever before!
This talk will demonstrate how JRuby has truly become a first-class JVM language. JRuby can integrate with all those pesky Java libraries that needed Java classes. JRuby's performance is substantially better than it was a year ago. JRuby has started to utilize the new invokedynamic bytecode for fast dynamic calls. JRuby supports libraries like Hibernate, JAX-RS, and JUnit4. JRuby can stand shoulder-to-shoulder with any language on the JVM and integrate just as well. At the same time, JRuby brings innovative Ruby libraries to the JVM like Rake, RSpec and Cucumber. Come hear the latest news about JRuby, from Java integration to performance to Ruby and Rails updates. We'll demonstrate several key Java libraries working with plain old Ruby code. And we'll show you why JRuby should be your dynamic language of choice for building applications on the JVM.

Software Transactional Memory (STM) i Java the language
Nå som gratis vertikal skalering er ute av bildet og antallet kjerner øker, er samtidighetsproblematikk stadig mer aktuelt. Java støtter kun pessimistisk låsing, som mange mener ikke skalerer - verken kjøremessig eller kodevedlikeholdsmessig. Software Transactional Memory (STM) handler om optimistisk låsing som vi kjenner fra RDBMSene våre. Forskjellen er at STM håndteres internt i JVMen, uten å basere seg på en RDBMS.

Get some fresh and inspirational ideas on how you can be an eco-friendly developer by writing better code.
Green computing is always about energy efficient servers, hardware without hazardous materials and other things that appeal to hardware buffs. Cloud computing is fun, but what else can us programmers do to help the environment? In this talk, Anders shows us how to be eco-friendly through writing better code and smarter business logic.

Hva må man tenke på før man begynner med webtesting, og hvordan unngår man en skjør test-suite som er vanskelig å vedlikeholde?
Webtesting er en testmetode hvor man tester applikasjonen gjennom brukergrensesnittet. Ved å gjøre dette simulerer testene faktisk bruk av systemet. Webtesting kan virke som en åpenlys og enkel strategi for å teste webapplikasjoner, men som mange har erfart er det ikke så enkelt. Å starte med webtesting uten en gjennomtenkt strategi fører i de fleste tilfeller til en test-suite som er skjør, treg og vanskelig å vedlikeholde. Slike test-suiter mister ofte verdien fordi de ignoreres av prosjektdeltagerene. Basert på erfaring med webtesting på flere prosjekter vil jeg gi tips og råd for hvordan man kan oppnå en webtest-suite som gir verdi for prosjektet og dets deltagere over tid.

Value objects are as overlooked as they are valuable. They express fine-grained, informational concepts in the problem domain and are associated with a number of practices in the technical domain. This session looks at a number of concepts and patterns, focusing primarily on Java but also mentioning value implementations in other languages.
Objects do not live in a free society: they exist for a purpose; they are not created with equal rights; they should not aspire to equality. What this means in practice is that objects live in a class-ridden society where each class serves a different role in the program as a whole. One category of object in need of attention and liberation is for representing domain values. Values are fine-grained and informational. They are inherent in the problem domain, but are often flattened into little more than plain integers and strings in the implementation, weakening the correspondence of the code to the situation it addresses. When it comes to identifying and implementing the Value Object pattern, there is a great deal more to be taken into consideration than can reasonably fitted into a single pattern. This talk looks at the practices and concepts that surround values both in Java and in other languages.

JSR-330+Guice leverages recently added language features to enable the best of both words: abstraction without the boilerplate!
Before Guice, the Java programming language subjected developers to a false dichotomy: 1. Use "new" to write concise but tightly coupled code. If you need more abstraction later, you'll have to update all of the N callers. or 2. Write a factory, so you can easily change the implementation later. You might end up doing unnecessary work, not to mention make your code harder to read. Guice leverages recently added language features to enable the best of both words: abstraction without the boilerplate! JSR-330's @Inject is the new new. Start off with coupled and straightforward code, and if you need more flexibility down the road, you can change your code in one place without having to update N callers. This speakers will compare factories and service locators with dependency injection, with and without Guice. Then he'll show you how to use Guice to make your code more modular, readable, and testable than ever before. All you need is a working knowledge of the language.

JSON (JavaScript Object Notation) is the friendliest format for cross server sharing of data. This live coding session starts with an empty HTML page, and ends up with a searchable flickr integration using JSON. Time permitting, we will mash it up with Twitter.
XML used to be the format of choice for transferring data or content from one system to another. JSON has more or less replaced XML for this task. Among the reasons is the low amount of overhead surrounding the actual data. Another thing is JSONs readiness when it enters your program: It is a programatic object, immediately after transfer, ready to reveal its data. This session will demonstrate how little code is actually necessary to do "near" real life integration between two sites using JavaScript and JSON. It could be done as a 10 minute lightning talk with focus on the client side technologies only. As a 60 minute talk the intro could be longer, and more examples and integrations with other sites like twitter could be shown. Also server side handling of JSON could be demonstrated.

Learn about the pros and cons of Groovy and while an statically typed yet expressive language such as Scala is an interesting alternative.
There is a good reason why dynamic languages such as Groovy and Ruby are getting a lot of attention. They are powerful, expressive languages that enable developers to easily write concise programs. However, not all of their benefits derive from being dynamic. Many important benefits are simply due to modern language design such as the support for closures. Moreover, dynamic languages have some inherent drawbacks. The extremely limited compile-time checking requires developers to write significantly more tests and severely limits how much help an IDE can provide to a developer.

Har du laget mange web services de siste 5 årene? Hvor mange av dem er blitt gjenbrukt? Har de vært lette å endre? Vi ser på hva vi har erfart, sant og usant i oppfattninger om integrasjon.
Integrasjon mellom systemer blir en stadig større del av budsjettene til IT-prosjekter. Over tid har en virksomhet gjerne mange systemer bygget på ulike teknologier. Derfor er det ofte kvaliteten på integrasjonen som avgjør om migrasjon til et nytt system lønner seg på sikt. Denne presentasjonen peker på noen vanlige fallgruver innen integrasjon, og dekker hva vi har hatt gode erfaringer med av retningslinjer når integrasjoner skal designes og bygges.

There are many ways to schedule a job to run at a later time in an enterprise Java application. Learn about some of them, and why it's trickier than it sounds.
Enterprise applications often need to schedule tasks to run at a later time, either once or periodically. There's several ways to go about this: EJB 2.1 introduced a timer service (which will get some sorely needed extensions in JEE 6), there's the popular Quartz system from OpenSymphony, and Oracle and IBM promote the Timer and Work Manager API (CommonJ, JSR-236), to mention a few. And then there's always cron. This lightning talk explains why you might need a job scheduler, compares common solutions and frameworks, and describes some gotchas you should avoid.

Put your build system on a solid state drive, and reduce the development round trip with 50%.
Solid state drives have recently become easily available. Their performence may provide a way of reducing the time spent on on the development cycle: compiling, packeting and deploying applications. This paper shows promising results by locating the code base and local maven repository on a solid state drive. Initial experiments shows that time spent on waiting for your code to compile may be reduced by 50%.

By combining the power of compiled and interpreted languages in the same application, can we get the best of both worlds? This presentation gives an introduction to the Java scripting engine API (JSR 223) and how it can be used in combination with various scripting langauges in real-world applications.
By combining the power of compiled and interpreted languages in the same application, can we get the best of both worlds? Can embedding scripting capabilities in our applications help us develop software that is more flexible and more usable? Can we reduce development time by making volatile and highly fluctuating application logic customizable, dynamic and scriptable? Can we make life easier for ourselves as developers by choosing the right language for the right task at any given time? This presentation gives an introduction to the concept of scripting engines and how they can be used to add scripting capabilities to real-world applications. We take a closer look at the Java scripting engine API (JSR 223) and popular implementations of the standard. The session includes practical examples and actual code.

"Brent barn skyr ilden" sies det. Skyr du kodebasen din?
Hvordan kan man snu uleselig kode, lite tester og frustrasjon til noe positivt? Lær av det og aldri gjør det igjen!

Endring i bruk av systemutviklingsmetoder har mange likhetspunkter med endring av klesmoter. I denne presentasjonen viser jeg hvordan motesyklusene for systemutviklingsmetoder blir stadig kortere og hvilke mekanismer (retorikk) som fører til dette. Prinsippene for å lykkes med en ny utviklingsmetode anvendes på min egen, revolusjonerende metode ELASTIC.
De fleste utviklere vil i dag være "smidige" (agile), mens de tidligere kanskje ville være ”unified” (RUP) eller ”rapid” (RAD). For lenge siden var det til og med noen som ønsket å være strukturerte eller fossefalls. Er man ikke med på det siste sies det at man følger ”tradisjonelle” utviklingsmetoder, noe som neppe er positivt ment. I denne presentasjonen ser jeg på hva det er som styrer utviklingen av systemutviklingsmetoder. Særlig interessant er det å se på hvilken retorikk som brukes når nye utviklingsmetoder lykkes med å få store deler av systemutviklingsverden til å se lyset og mene at tidligere (tradisjonelle) utviklere og prosjektledere har vært mer eller mindre uopplyste og ineffektive. Jeg vil også presentere resultater fra en empirisk studie om utviklingsmetoder som demonstrere riktigheten av utsagnet ”jeg ser det, når jeg tror det”. Med andre ord at vi tolker observasjoner som mye mer positive dersom vi allerede tror på en positiv sammenheng. Erfaringer med smidige metoder blir altså mer positive fordi vi tror det er positive sammenhenger. Gjennomgangen av retorikken brukt i innføring og markedsføring av nye utviklingsmetoder oppsummeres i ti prinsipper for å lykkes med å lage en bestselger av en utviklingsmetode. Disse prinsippene demonstreres ved å beskrive hvordan jeg ville ha innført min egen, revolusjonerende (fiktive) systemutviklingsmetode ELASTIC (”Elastic development”). Denne metoden baseres på at dagens utviklingsmetoder tar alt for lite hensyn til variasjonene (elastisiteten) i kundens modenhet og usikkerheten i utviklingsarbeidet. Vi at denne elastisiteten gjør ELASTIC mye mer effektiv enn tradisjonelle utviklingsmetoder (agile, lean, RUP, RAD og fossefalls).

Spring Framework er et svært viktig verktøy for mange av oss, og de fleste har en grunnleggende kjennskap til rammeverket. Imidlertid er Spring et omfattende rammeverk, og det kan være en utfordring å holde oversikt over alt det kan gjøre. I denne lyntalen vil jeg presentere tre ting jeg mener det kan være fordelaktig å gjøre med Spring, men som mange kanskje ikke kjenner til.
Spring Framework er et svært viktig verktøy for mange av oss, og de fleste har en grunnleggende kjennskap til rammeverket. Imidlertid er Spring et omfattende rammeverk, og det kan være en utfordring å holde oversikt over alt det kan gjøre. I denne lyntalen vil jeg presentere tre ting jeg mener det kan være fordelaktig å gjøre med Spring, men som mange kanskje ikke kjenner til.

We know how to create maintainable, flexible and solid Java code using Test Driven Development. With growing client side complexity, we need to write JavaScript in the same professional way. This hands-on demonstration will provide you with all the necessary pieces to do true Test Driven Development in JavaScript.
We create maintainable, flexible and solid Java code with the use of techniques such as Test Driven Development and Continuous Integration. When it comes to client side Web development with JavaScript, the story is quite different. JavaScript has for a long time been perceived as a toy programming language for making flashy buttons and simple form validation. But now as the client side grows larger and more complex, we should take the lessons learned from TDD in Java and apply them to our JavaScript development. There are many myths surrounding TDD and JavaScript, and we will in this session bust some of these: * There are no proper frameworks for test driven JavaScript development. * There is no IDE support. * It isn't possible to integrate it with my build or CI system. Our hands-on demonstration will show you a JavaScript application capable of controlling TANDBERG video systems and provide you with all the necessary pieces to do true Test Driven Development in JavaScript yourself. This includes: * Our minimal test framework for JavaScript testing * Running tests from Eclipse with the push of a button * Using mocks and stubs to test code in isolation * Testing of JavaScript integrated with your build and continuous integration systems

Phidgets tilbyr en rekke sensorer og kontrollere som du kan styre fra PC-en din gjennom enkle API-er. Hardwaren er rimelig og API-ene er gode. Phidgets er perfekte for små hobbyprosjekter der du har lyst til å gjøre noe litt utover det vanlige.
Phidgets tilbyr en rekke sensorer og kontrollere som du kan styre fra PC-en din gjennom enkle API-er. Hardwaren er rimelig og API-ene er gode. Phidgets er perfekte for små hobbyprosjekter der du har lyst til å gjøre noe litt utover det vanlige. I dette foredraget presenterer vi hvilke sensorer og kontrollere som er tilgjengelig og dykker ned i kode for å se hvor enkelt det er å programmere mot phidgets API-ene. Vi gir en kort demonstrasjon av en applikasjon som benytter en RFID-leser til å løse utfordringer rundt tidtagning for mosjonsløp. Etter foredraget vil du ha fått ny inspirasjon og er klar for å ta fatt på nye spennende hobbyprosjekter.

Foredraget vil ta for seg erfaringer knyttet til Java arkitekturen som ble etablert for NAV Pensjonsprosjektet, et av de største Java prosjektene i Norge. Fokus vil ikke være på presentasjon av selve arkitekturen, men heller et utvalg av subjektive erfaringer som er gjort før, under og etter at arkitekturen ble tatt i bruk.
Pensjonsprosjektet i NAV har sannsynligvis vært det største Javaprosjektet som har foregått i Norge i de senere år. Flere hundre personer har vært involvert, bl.a. Javautviklere fra flere store konsulenthus. Foredraget vil ta for seg erfaringer knyttet til Java arkitekturen som ble etablert for dette prosjektet. I et prosjekt av denne størrelsen møter man på mengder av utfordringer og forventninger til arkitekturrollen fra ulike hold. Hvordan går man fram for å etablere en Java arkitektur, hva skjer typisk når arkitekturen tas i bruk, og hvilke erfaringer står man igjen med etter at prosjektet er levert. Fokus vil være på et utvalg av subjektive erfaringer sett fra innsiden fra en arkitekts perspektiv. Av temaer som omhandles kan nevnes tyvstarting, bygging av jernbaner og skip, UML - Unknown Modelling Language, De fordømte sjekklistene, White Tower arkitekter, Nei-generaler, Zen og kunsten å vedlikeholde en arkitektur, Lucky Luke og Don Quijote.

Erfaringsrapport fra hvordan teknikker fra Scrum kan fungere i ikke-utviklingsprosjekter.
Scrum er primært rettet mot programvareutviklingsprosjekter. Men metodikken er egentlig en samling av generelle teknikker for samarbeid i team. Mange av teknikkene fungerer derfor godt i ikke-utviklingsprosjekter, f.eks utredninger, kravspesifisering og andre aktiviteter. Det viser seg at bruk av tavle med ”user stories” og aktivitetslapper fungerer bra for å måle progresjon og holde fokus på oppgavene man ønsker å gjøre i neste periode. Derimot kan det være problematisk å vite hvordan man definerer ”user stories” som ferdige da de ofter løper over flere iterasjoner, og mange oppgaver avhenger av arbeid som skal gjøres av andre. I presentasjonen vil jeg drøfte disse problemstillingene og gi flere eksempler på hva som fungerer og ikke fungerer, fra et prosjekt hvor vi gjør IT-arkitekturbistand og SOA-governance utvikling.

This presentation will provide a retrospective of the trade-offs compared to C++ illustrated by Java, C# and other VM-based programming languages with Garbage-Collection, why scripting languages simultaneously thrived, and what this teaches us about the applicability of technology to emerging challenges and environments.
Java’s appearance at the dawn of the Internet Age helped to propel it to near-instant prominence, and lodged cross-platform virtual machines and garbage-collection firmly into our mainstream consciousness. In Java’s wake, .NET introduced the concept of the “cross-language” virtual machine, and helped to foster a new discussion on the benefits of functional programming. Did Java and C# have an evolutionary advantage over C++, or were they simply “Cool” (the original code name for C# / .NET)? In retrospect, what were the actual efficiency advantages provided by each language? And despite the grip that these languages exerted on “enterprise” applications, how did scripting languages such as PHP, Python and Perl manage to thrive and multiply? Looking forward, what do these lessons teach us about the applicability of technology to emerging challenges and environments such as Cloud Computing, and what languages are rising to the top as a result?

Find out what will be in the next release of the JDK, coming in early 2010.
The next release of the Java Standard Edition is scheduled for the beginning of 2010. In this session we'll review the latest feature list of what's in and what's out of the next version of the JDK. The big areas being covered are: * Modularisation of the JDK: Project Jigsaw * Small language changes: Project Coin * Dynamic language support on the JVM: The Da Vinci Machine Project

Har du høye krav til ytelse? Dette foredraget viser deg hvordan du kan gjøre koden din raskere.
De fleste Javautviklere er i sin daglige jobb ikke spesielt opptatt av ytelse. Vi flytter stor sett data fra en database til en annen og er fornøyd hvis tallene stemmer. Men større datamengder og høyere krav til responstid har de siste årene gjort ytelse til et stadig viktigere tema. Dette foredraget viser konkrete eksempler på ytelsesforbedringer i en Java-applikasjon som tilbyr søk og analyse i store datamengder. Applikasjonen skal gjennom et webgrensesnitt levere beregninger i sanntid og dette stiller høye krav til ytelse. Gjennom stegvise optimaliseringer viser vi hvordan utregninger som først tok minutter endte opp med å ta millisekunder. For å få til dette måtte vi bruke ekstremt effektive datastrukturer, forstå hvordan Java allokerer minne, hvordan moderne CPU-arkitekturer fungerer, og ikke minst bruke noen lure triks der det trengs. Foredraget viser også ytelseforebedringer i HTML, CSS og Javascript, et område som blir stadig viktigere i ytelsessammenheng.

In this lightning talk I will present OAuth, an open protocol to allow secure API authorization in a simple and standard method from desktop and web applications.
After this lightning talk the listener will have a basic understanding of what OAuth is and how it can be used to secure mashed up data.

Domain driven design, the importance of good API's in a service oriented architecture.
StatoilHydro has practiciezed Domain Driven Design since 2004, and over these years we have experienced that some things are more difficult than others, some things more demanding than others and some things more valuable than others. There are two things that stands out in this context, the value of the ubiquitous language, and the hardship of API design. The importance of good API design are not though in school, and not much is written. On the other hand, good API's is the foundation of good software, and with SOA it become even more important. In this talk we will share our experience from designing and integrating some of our largest software systems where Domain Driven Design has been successfully applied. Examples of successful and not so successful APIs will be provided.

* The most powerful way to prevent bugs in code delivered to testing, is to both detect them earlier and prevent them being injected * Software Inspections are proven capable of doing these things effectively, but the traditional costs are inhibiting * Agile Specification QC solves this problem by focussing on defect measurement by sampling, and strict numeric process exit.
Traditional Software Inspection is often uneconomic and ties up valuable staff resources. Shifting the emphasis from cleanup (that is, from identifying defects and then removing them), to merely sampling the defect level of specifications, produces significant benefits. It enables the quality level of specifications to be determined more rapidly. Consequently, the QC can be carried out more frequently. Systems and software engineers rapidly learn, through SQC feedback, to take standards seriously, which in turn reduces defect injection. Further, by analyzing where/how the defects occur continuous process improvement can be supported.

This talk explains the top ten tips seen through the eyes of companies doing a SOA implementation the hard way. Learn the best tips for a SOA rollout and see real world examples for where these tips work and what happens when they aren't adhered to.
You have been handed the keys and a blank slate to build a new services-based architecture. Are you up for the task? Do you have the knowledge, judgment, and combination of hard and soft skills needed to plan, design, and execute a significant SOA project? Implementing a strong and flexible SOA can be a difficult challenge for an experienced architect, let alone someone with less experience. Many complex architecture projects end in failure, or are scaled back so that something can be achieved in a reasonable amount of time. In this session Jeff explores the key characteristics of successful SOA projects. He covers some of the patterns, and anti-patterns, tool sets, and strategies that he himself learned the hard way – through his own trial and error experiences as an architect. Last, he provides a strategy and blueprint for achieving a high likelihood of success in your SOA project. Key session topics include: * How to apply SOA patterns to different classes of problems; * The common failures of a SOA project and how to prevent them; * Architectural strategies that offer the best chance of achieving project success; * And more.

Hvordan lage java applikasjoner på embedded plattform med Java SE for Embedded på Single Board Computer. * Gjennomgang av Java SE for Embedded. * Introduksjon til JNI. * Oversikt over Single Board Computer. * Demo på EmbeddedArm TS-7800 med web-applikasjon med tilgang til analog og digital IO.
Å skrive applikasjoner for embedded plattform har lenge vært forbeholdt C og C++ utviklere. I dette foredraget vil jeg gi en oversikt over Java SE for Embedded og hvordan en med dette sammen med standard bibliotek kan lage web-applikasjoner på Single Board Computers (SBC). Foredraget vil gi en oversikt over Java SE for Embedded, hvordan dette skiller seg fra J2SE og J2ME samt distribusjon og lisensiering. Jeg vil videre gi en kort introduksjon til Java Native Interface for tilgang til maskinvare og drivere. Det vil også bli gitt en demo på EmbeddedArm TS-7800 SBC. Demoen vil vil gi innblikk i hvordan en fra webapplikasjon på en SBC kan få tilgang til analog og digital IO og demonstrere hvilken ytelse en kan forvente fra en slik applikasjon.

En dyp titt på hvordan håndtere kompliserte konfigurasjonsutfordringer i større Java applikasjoner ved hjelp av Constretto.
I dette foredraget vil jeg sette fokus noen av de mer komplekse utfordringene vi kan møte når det gjelder konfigurasjon av større Java applikasjoner. Hvordan skal vi kunne forberede våre applikasjoner for utrulling på et stort antall servere, på et mangfold av operativsystemer, i forskjellige stadier av utviklingsprosjektet. Dette på samme tid som vi ikke ønsker kompliserte installerings- og konfigurasjonsrutiner. For å hjelpe oss med å håndtere disse utfordringene har jeg utviklet Constretto, et rammeverk for avansert konfigurasjonsstyring. Jeg vil ta en dyp titt på hvordan Constretto kan tas i bruk, samt hvilke muligheter som finnes for tilpassing av rammeverket Til slutt vil jeg gå gjennom erfaringene vi fikk med bruk av Constretto i en forsikringsportal for Nemi forsikring. Hvordan vi der fikk et etterhvert meget godt forhold til drifterene.

Any scalable web application uses object caching, both to reduce database load and to improve response time. But choosing the right cache management product is critical for performance. We have benchmarked several cache setups and give our results here.
“You have twenty server instances running. Available bandwidth is measured in gigabits, and your application’s user interface has been carefully designed to satisfy the high customer expectations. But there is one ugly flaw in this pretty picture: How can the monolithic, centralized database handle the load?” In practice, any scalable web application uses object caching, both to reduce database load and to improve response time. But creating efficient mechanisms for cache management is hard, especially in distributed environments such as clusters or clouds. Important challenges are data freshness, data consistency and fault tolerance. Several products promise to reduce the burden by providing automatic object cache management among distributed servers. Notable examples are Ehcache, memcached and Oracle Coherence. At BEKK, we have studied several such products. Our results indicate that finding the right solution with a proper setup is critical for performance. This talk presents an overview of our experience, including benchmarks.

Git er et distribuert versjonskontroll system. Github er gratis git repository med mye snacks!
Bruker du SVN enda? Lei av at ingenting funker når repositoriet ditt går ned? Lei av at det er tungt å branche? Lei av ikke å kunne gjøre lokale endringer? Sjekk ut git. Det løser disse problemene for deg. Bruk github for å komme enkelt igang.

This presentation will outline how Escenic went from an RPC based approach to a RESTful webservice. The presentation will cover the design of both the web service and the client. We will list lessons learned through the project and how these lessons have affected the end result.
This presentation will outline how Escenic went from an RPC based approach to a RESTful webservice. The presentation will cover the design of both the web service and the client. We will list lessons learned through the project and how these lessons have affected the end result. You will not NOT learn anything about the jungle of RESTful frameworks, as they are only tools to get the job done. You will learn the principles of REST and how it affects client side programmers. The focus will be on how to build the server and client correctly according to the principles behind REST, and not misuse the term as Flickr, SocialSite and Amazon do. RESTful HTTP is more than just using HTTP: it is identifying resources using URIs, exposing relationships between resources, and manipulating resources using the semantics of HTTP verbs. It also means designing resources to fit the constraints, based on nouns (and sometimes verbs) of the domain

Automatisering gjort riktig, intet mindre. Eller hvordan fullføre det siste skrittet som ivaretar (ikke bare) utviklernes krav, drifternes, testernes og prosjektledelsens. Foredraget er basert på praktisk erfaring i prosjekter.
Smidig utvikling er noe som de aller fleste organisasjoner holder på med, men det begrenser seg typisk til planlegging, rapportering og utvikling. Vi som er utviklere ønsker å bruke minst mulig tid på oppgaver som tar bort fokuset fra utvikling. Testerne ønsker å kunne få en ny versjon av applikasjonen vår så fort som mulig og ikke minst akkurat når de ønsker det selv. Drifterne ønsker at de binære artefaktene som rulles ut i produksjon er identiske med dem vi har benyttet i utviklernære miljøer og i systemtest. Alle har fått til automatisert bygging og kanskje testing. Flere og flere har fått til periodisk deployment av applikasjoner. Hvorfor stoppe her? Det vi trenger er et komplett regime for automatisert deployment og utrulling, der de samme binære pakkene brukes i alle miljøer, også produksjon. Vi vil spille på lag med operativsystemets egne pakker og versjonsstyring og vi ønsker full fleksibilitet for å rulle opp og ned mellom ulike versjoner. For at en prosjektgruppe skal kunne fungere og for at produksjonssettingen skal være knirkefri, er vi avhengig av at alle ledd fungerer sammen. Dette foredraget er en praktisk innføring til hvordan vi tar det siste steget - og ikke minst hvordan vi plasserer oss selv øverst på skrytelisten til testerne og samtidig blir drifternes gullunger. Testerne vil elske oss fordi vi kan levere så raskt, mens drifterne vil sette stor pris på enkle rutiner uten unødvendige manuelle steg. Dessuten får de ikke testerne på nakken fordi alt bare fungerer! Foredraget er basert på praktisk erfaring i utviklingsprosjekter.

Buildr is a modern build system for Java-based applications including support for Scala, Groovy and a growing number of JVM languages and tools. This session will introduce Buildr and demonstrate practical solutions to common build problems.
Buildr is a modern build system for Java-based applications including support for Scala, Groovy and a growing number of JVM languages and tools. Buildr combines the expressiveness of the Ruby scripting language with a familiar dependency-based task execution model and project-level structure similar to Apache Maven. This session will introduce Buildr and demonstrate practical solutions to common build problems. Examples will be taken from actual build systems including large-scale Apache projects and frequently-asked questions from the mailing list. In particular, we will demonstrate integration with Apache Ant tasks, handling of multi-lingual projects, and customizations for various source-generation and packaging requirements.

That's a stupid question, isn't it? Memory is just where you keep things. Nevertheless the majority of of performance problems I have seen were in the end connected to memory issues. In modern computers memory is a complex multi-layered thing affected by the hardware, operating system and the JVM. And considering that it's shared among multiple CPUs we get a lot of classical distributed problems without an actual network anywhere in sight.
You should attend this talk if any of the following questions give you pause: - How slow is memory? - How pagefaults happen and what do they mean? - Why swapfile and Java don't get along? - What does "synchronized" do besides locking? - What does volatile really do? - What do you need CompareAndSwap for? - Why GC doesn't scale well and what is being done about it? - What hardware developments can change the JVM game? To answer those questions I'll build a simple CPU model in Java to illustrate the concepts in a comprehensible way.

Part of Spring 3, JavaConfig provides a flexible, non-invasive option for configuring applications inside the Spring IoC container using JVM-based languages such as Java or Groovy. This lightning talk will explore the features offered by JavaConfig and what makes it stand out from other annotation-based configurations.
Part of Spring 3, JavaConfig provides a flexible, non-invasive option for configuring applications inside the Spring IoC container using JVM-based languages such as Java or Groovy. This lightning talk will explore the features offered by JavaConfig and what makes it stand out from other annotation-based configurations.

Mobile and Cloud Computing are two emerging technologies that on their own are increasingly important. Together they pose a powerful and elegant solution to many existing and likely business cases. This talk introduces the audience to some of the more likely scenarios where mobile and Cloud Computing will be seen working together and augmenting each others strengths.
h1. How the Cloud is and will be an invisible presence in many mobile applications. As two technologies that are increasing rapidly in importance and spread both PaaS/SaaS and mobile devices (“phones”) are highly important technologies on their own. Closer to 750 million people are now using cellphones world wide. And PaaS is in the beginning of every hype curve. Together these two technologies pose an emerging opportunity and solution to many existing and likely business cases. The needs that drive these business cases are on one hand the need for a mobile application with an optimal usage of the mobile device when it comes to screen size, GUI lock and feel, processing and bandwidth. And on the other side the need for at least one or more of the following: * High processing capabilities, high volumes of data and high bandwidth. * Collaboration, Data sharing, Multitasking and Scheduling The type off distributed application that emerges from these needs and wants are applications where the client is a cellphone with a thin or semi-thick client software with a backend running on a PaaS solution. The high and growing number of cellphones with increasing capabilities means that the potential market is far larger than for a personal computer software solution. There are a number of reasons why the PaaS approach is preferable and possibly the only solution compared to a thick client software solution on the cellphone. These can be the limited storage space, processing power and bandwidth. Also the need realtime and data with a short shelf life dictates a solution where the data is aggregated and stored centrally. Sharing data and collaboration are others. The client ideally uses the native lock and feel of the client platform. The bandwidth needed between the cellphone client and PaaS side should be optimized by using lean protocols and possible compression of data. The PasS side should be able to scale dynamically based on changing client numbers.

Det har vært en til tider opphetet offentlig debatt om DLD en god stund nå. Siden dette er et tema som opptar mange i Java fagmiljøet så ønsker vi å la JavaZone publikumet ta del i debatten også. Hvis du lurer på hva DLD egentlig går ut på og hva du skal mene om det så bør du få med deg denne debatten!
Det har vært en til tider opphetet offentlig debatt om DLD en god stund nå. Siden dette er et tema som opptar mange i Java fagmiljøet så ønsker vi å la JavaZone publikumet ta del i debatten også. Hvis du lurer på hva DLD egentlig går ut på og hva du skal mene om det så bør du få med deg denne debatten! Paneldebatten avholdes 8 september, 10:15 til 11:15, i sal 1. Fra for-DLD-siden stiller: Reidar Brusgaard og Rune Utne Reitan (begge fra Kripos). Fra mot-DLD-siden stiller: Martin Bekkelund (Friprogsenteret) og Torgeir Waterhouse (IKT-Norge). Debattleder er Christer Gundersen fra Friprogsenteret Det vil være 2 innledende presentasjoner, og deretter blir det debatt. Publikum vil ha mulighet til å stille spørsmål. Vi håper at dette vil være med på å øke faktanivået i debatten og gi Java fagmiljøet en mulighet til å komme med sine synspunkter på DLD.

An overview of functional programming and its benefits, with a focus on the possibilities offered by various languages on the JVM. Examples used are written in Scala, Clojure and Java.
Funksjonell programmering er et programmerings-paradigme eldre enn objektorientering, som har fått en økende popularitet de siste årene. Denne presentasjonen ser på hvilke fordeler man har med funksjonell programmering, og hvilke muligheter man har på JVM. Illustrert med eksempler skrevet i Scala, Clojure og Java.

This session will look at a number of security concerns and how the ESAPI library provides a unified solution for security. This includes authorization, authentication of services, encoding, encrypting, and validation. This session will discuss a number of issues that can be solved through standardizing on the open source Enterprise Security API.
When it comes to cross cutting software concerns, we expect to have or build a common framework or utility to solve this problem. This concept is represented well in the Java world with the log4j framework, which abstracts the concern of logging, where it logs and the management of logging. The one cross cutting software concern that seems for most applications to be piecemeal is that of security. Security concerns include certification generation, SSL, protection from SQL Injection, protection from XSS, user authorization and authentication. Each of these separate concerns tend to have there own standards and libraries and leaves it as an exercise for the development team to cobble together a solution which includes multiple needs.... until now... Enterprise Security API toolkit from OWASP. This session will look at a number of security concerns and how the ESAPI library provides a unified solution for security. This includes authorization, authentication of services, encoding, encrypting, and validation. This session will discuss a number of issues that can be solved through standardizing on the open source Enterprise Security API.

If you live on JVM and want to understand the principals of actors, agents, fork/join, map/reduce, STM and others to write safe concurrent code in Java, Groovy, Scala or Clojure, this session is for you.
Does your processor laugh at your code? Does it dawdle, travel over other processes, does it feel bored all the time, instead of taking full engagement and focus properly on the work at hands? It's your old-styled code that's failing here, code, which has been written for the processor's single-core grandpa. We all live in a new era now, single-thread has been out of fashion for a while and certainly doesn't appeal to the young processors. I'd like to show you how to write in modern fresh multi-threaded style, so popular with these processor youngsters, a style, which doesn't let them sleep. Write about brave Actors, lay Fork/Join, mention Parallel Arrays, call in Agents and ensure smooth Dataflow. The processors will adore you for that and will work tirelessly to read your code start to end as fast as possible while making your applications lightning-fast again. If you want to harness all the of the cores in modern multicore processors, this session is for you.

Come see a more intelligent way to build Java based projects using a build DSL and convention or configuration… This session will cover intro to advance features showing off how easy it is to get started and how power the tool is if you need it… come… Enter the Gradle
In the Java build space, first there was ANT, which provided a reliable way to build without an IDE. Then there was Maven, which provided standardization in build life cycles and dependency management. Now... Enter the Gradle, which provides convention over configuration approach to the build process and an approach at building that isn't based XML. This session assumes no familiarly with Gradle as it introduces this new approach at building projects. It is very helpful to be able to read and understand groovy to get the most from the session. This session will look at multi-language or polyglot projects, as well as integration to ANT and Maven. It will conclude with building custom plugins for the Gradle build process.

Since JUnit 4.0 was released over 4 years ago several advanced features have been added to the framework. This presentation covers some of those features including assumptions, theories and rules.
Det er over 4 år siden JUnit 4 ble introdusert. JUnit 4.0 hadde allerede støtte for grunnleggende enhetstesting, så hva har skjedd i de neste versjonene? Jo, mer avansert og til dels eksperimentell funksjonalitet har blitt lagt til. Presentasjonen tar for seg noe av det som gjør at JUnit 4 er blitt et avansert og utvidbart testrammeverk: * assertThat * Assumptions * Theories * Rules

Embrace change! While Agile is something everyone is talking about, many struggle with handling change. I'll walk you through some common pitfalls so you can avoid them.
At the core of Agile lies the ability to adapt and change as you learn more about the system and problem domain. And even though many are doing the ceremonies of Agile, they often fail to acknowledge what it really means to be ready for change. In several projects I have seen things that is constantly blocking our efforts to become agile. Doing the ceremony might make you feel good, but it doesn't mean you are reaping the full benefits of Agile. In this lightning talk I will take you through some of the common mistakes I have seen, and hopefully prevent you from doing them too.

TRONbot is a robot, the software written in Scala, and its brains is based on a neural network implementation, why Scala, and was it the right choice ?
TRONbot is a wheeled robot with a simple neural network implementation at its core. Neural networks are electrical simulations of the neurons that exists in our own brains, either in hardware or in software, and are mostly used for signal interpretation or as in this case simulated behavior and AI. The talk will focus on the experiences made using Scala for controlling a robot, and how neural networks can solve relatively hard problems you face making an autonomous robot. I will go into brief detail about the low-level aspects of the implementation, but the corpus of the talk will be on how I implemented a neural network in Scala for autonomous behavior of the robot. I will also mention other applications of neural networks and how to get started building your very own robot.

The Java Virtual Machine has become the most frequent target for the implementation of new programming languages. Both scripting and compiled languages find a home in the JVM that gives them unprecedented portability. These languages can be used in the development of enterprise applications by augmenting or leveraging the Java platform’s functionality, or by eliminating the need of using the Java language altogether. Learn how to go about building third-party language functionality from Python, Ruby, or others into your enterprise Java applications, what to look for, what to avoid, and when and why it’s a good idea.
The Java Virtual Machine has become the most frequent target for the implementation of new programming languages. Both scripting and compiled languages find a home in the JVM that gives them unprecedented portability. These languages can be used in the development of enterprise applications by augmenting or leveraging the Java platform’s functionality, or by eliminating the need of using the Java language altogether. Learn how to go about building third-party language functionality from Python, Ruby, or others into your enterprise Java applications, what to look for, what to avoid, and when and why it’s a good idea.

Many web applications have some part of it that users want to use also when not connected to the internet. We will show how we enabled a part of our web-based system for offline usage by leveraging Google Gears and new APIs in HTML 5.
Har du noen gang tenkt at "Ja, dette vil jeg lage som en webapp" bare for å komme på at "jamen, systemet må også kunne brukes uten netttilgang"? I utviklingen av nytt system for vurdering av søknader om forskningsmidler for Norges Forskningsråd dukket dette behovet opp. Med dagens teknologi er det ikke lengre behov for å bruke tradisjonelle offline-formater og produkter som PDF, Word og Excel for å tilby funksjonalitet også når man er offline. Google Gears brøytet veien for offline web mens nye standarder i HTML 5 asfalterer veien videre. I dette foredraget går vi gjennom hvordan vi har løst utfordringen med offline tilgang ved å bruke Google Gears og veien videre med HTML 5. Vi vil vise hvordan arkitekturen settes opp, hvordan man tilgjengeliggjør websider og data offline, hvordan man sender disse tilbake til server og sørger for konsistens. Alt med kodeeksempler og live demo.

Your brain is your most powerful asset - have you thought about how to put yourself in a position to maximize yours? This talk is a fast paced look at what modern research has to teach us about our very personal computer.
The single most important tool in any developers toolbox isn't a fancy IDE or some spiffy new language - it's our brain. Despite ever faster processors with multiple cores and expanding amounts of RAM, we haven't yet created a computer to rival the ultra lightweight one we carry around in our skulls - in this session we'll learn how to make the most of it. We'll talk about why multitasking is a myth, the difference between the left and the right side of your brain, the importance of flow and why exercise is good for more than just your waist line.

How we get more mileage out of our test hardware by letting system tests specify what they need to run.
In embedded systems testing, hardware and time are the scarcest resources. At TANDBERG, we have more software configurations we wish to test than we have hardware for. To make matters worse, some of the test configurations requires specific hardware options. To solve this, we've developed an extension to TestNG where each test specifies what resources it requires to run. In this session we describe how we've implemented a resource pool which allocates test resources as specified by the tests. Each test can specify a number of systems based on properties like system type, hardware options or software version, and those systems will not be allocated to any other for as long as the test is running. Before the systems are entered into the pool they can be automatically configured, and they are reset between between test runs to ensure that the ordering of tests doesn't influence the result. The resource pool itself are written to be as general as possible, so that it should be easy to change storage backends or even to use it for projects outside of TANDBERG's development department.

Learn what websockets are and how easy it is get started using them on top of GlassFish and Grizzly.
In this session, you will learn what websockets are and how to build applications using them on top of GlassFish and Grizzly. We will explore the basics of the protocol as well as several different examples showcasing different applications of this new technology.

What is SOA governance and why is it mandatory to succeed in larger SOA implementations. This lighting talk will give an example of a SOA governance reference model and explain SOA goals, principles and processes. It also gives examples on what part of SOA governance that can be automated with tools and what cannot.
Mange hevder at SOA governance er nødvendig for å lykkes med SOA, men hva er egenlig SOA governance? Denne lyntalen vil gi et innblikk i hva SOA governance er for noe, om det er nødvendig og når man trenger det. Det blir gitt et eksempel på en SOA governance referanse modell og forklaring på SOA governance- prosesser, målsetninger, prinsipper og organisering. Lyntalen kommer også inn på eksempler på områder innenfor SOA governance som kan automatiseres ved hjelp av verktøy.

A prescription dose of reality for those high on conference fever. Nine out of Ten business owners agree that this talk will help reduce the symptoms of conference fever sufferers.
A steaming pile of crap may be something that you pick up and throw away after your dog so generously leaves it behind for you, but for the dung beetle it is a home, food, and a place to rear children. Perspective is everything. This talk looks at software development from a business perspective, from someone who is both a developer and paying money out of their wallet to get software built.

Ever had to restart your application server because of high load and abysmal response times? Let's investigate! We'll look into how you'd detect live locks, memory leaks and sub optimal garbage collector configurations.
Når måtte du sist restarte applikasjonsserveren fordi responstiden var råtten og lasten på server var høy? Vet du hvordan du kan finne ut om en kræsj ble forårsaket av garbage collection eller live lock? Denne presentasjonen vil vise deg de mest vanlige luktene du skal være på vakt mot, og demonstrere noen verktøy for å analysere problemet. Vi går mer i dybden rundt hvordan disse problemene oppstår når vi utvikler, og se på noen anti-patterns som bør unngås. Eksemplene er hentet og isolert fra fra ekte netttjenester med høy trafikk! Etterpå vet du hvordan du kan anvende VisualVM, YourKit og et antall nyttige kommandolinjeverktøy til å sjekke helsetilstanden på søppelhaugen (heap) og trådene.

This is an experience report of how an adventure came to a grinding halt. The talk will tell our story and share some of the things we learned from our failure. Usually you get to hear about the successes and the amazing stories of how people in a garage with a single light bulb and a baud modem ended up with a google amount of cash. This story is different, but it might just be all the more insightful as it will show you how you can go wrong.
For every successful start-up, there are a bunch of others who did not make it. This is an experience report from one of those companies which did not make it. We set out to become the number one social music experience on the planet. Usually you only hear the amazing stories about how magic happened and a success was created. You seldom get a chance to hear how you can accomplish failure and maybe you learn enough that you end up holding a similar talk.

So now you have your builds and tests done on a CI server. What's next? This talk discusses problems & techniques to expand automation to handle processes that have been done manually, like integrating components.
In this talk, we'll discuss the techniques that go beyond simple build and test, by using Hudson, an open-source CI server. These techniques allow developers to get more out of their investment to CI. This talk targets those who have started using CI and are used to the idea of automated build. * One of the key themes of a larger automation is to control the flow of changes. This may be between developers in the same team or between different teams. This talk discusses these topics and techniques in details. * As CI produces and consumes a lot of binaries that are only slightly different, tracking them accurately is important. This talk discusses techniques and challenges. * Techniques to reduce the turn-around time of a long build/test.

We have always said that re-inventing the wheel is stupid. We have made fun of people suffering from NIHS (Not Invented Here Syndrome). But sometimes I wonder if we where the stupid ones...
Det er en etablert sannhet at vi ikke skal lage egne rammeverk - når det allerede finnes etablerte rammeverk der ute. Web verdenen er et godt eksempel på et område hvor dette kanskje er spesielt aktuelt. Det er nå flere Java web-rammeverk enn vi kan telle, og nye dukker fortsatt opp med jevne mellomrom. Tanken på å lage sitt eget web-rammeverk virker nok rimelig søkt for de aller fleste. Dette hindret derimot ikke oss... to ganger. I de to siste prosjektene vi har vært med på er det nettopp dette vi gjorde. Dette skjedde litt på grunn av tilfeldighetenes spill, litt fordi vi rett og slett hadde lyst, men mest fordi vi syntes de tilgjengelige rammeverkene var for dårlige. Vi tenkte, som så mange før oss, at det burde være mulig å gjøre dette bedre selv. Med et fundament basert på rammeverk som Spring, Jersey og jQuery satt vi oss fore å lage et rammeverk som kunne gi oss raskest mulig time to market, samtidig som det skulle være vedlikeholdbart over tid. På tross av etablerte sannheter og "sunn fornuft", mener vi dette var et riktig valg. I dette foredraget ønsker jeg oppsumere erfaringene fra disse to prosjektene. Hva ble konsekvensene av valgene våre? Hva fungerte? Hva tok vi med videre i prosjekt nr. 2. Hva var det som ikke fungerte? Er vi fortsatt like fornøyd nå over 1 1/2 år etter produksjonsstart av prosjekt 1? Og ikke minst - hva skal vi ta med til neste prosjekt? Jeg vil også kort introdusere en åpent tilgjengelig showcase applikasjon, hvor dere selv kan studere prinsippene disse to applikasjonene er bygget på.

Performance tuning isn't difficult - and we'll prove it, by tuning a real world application in realtime.
That performance tuning is still considered to be a dark art is attributable to the lack of understanding of performance tuning best practices. In this talk Dan, our typical developer, will go bumbling off in an attempt to tune a poorly performing application. During the process we will introduce a number of best practices that could have helped him reach his performance goals, without the need of magic.

JRuby and Rails, JRuby's newer Java integration features, JRuby as a good JVM and Java platform citizen.
JRuby has come a long way from being a simple Ruby implementation. Recent releases have steadily added more and better Java integration features, ranging from "real" Java class generation all the way to better support for annotations and Java's reflective APIs. JRuby adds Ant support to the populate and beautiful Rake build tool. JRuby provides integration of Maven and RubyGems. JRuby deploys to normal Java application servers and works great with standard Java APIs like Hibernate. JRuby is becoming a first-class JVM language. In this talk we'll explore a little bit about why JRuby and Rails are easy and fun ways to build applications. Then we'll dive into the real subject: how you can get JRuby and Rails integrated into your organization. Whether you build web applications or desktop apps, whether you use nosql database or JPA, whether you want a more expressive language or a richer ecosystem, JRuby has something to offer.

This talk will introduce the Erlang programming language, describing how to do more with less. We will be giving examples on the syntax and constructs which allow Erlang programs to generally be 4 – 10 times shorter than their counterparts in Java, C and C++ while achieving 99,999% availability. We will provide examples not only of the Ericsson success stories, but also from banking, finance, distributed databases, instant messaging and web2.0, describing how Erlang has found its role in these market segments.
Can anything at all be modeled without objects? Think concurrent! Hans Nilsson will tell you how with the programming language Erlang and its middleware OTP. He will describe why Erlang, originally invented to handle the next generation of Telecom products, has become successful in a much wider range of sectors including enbedded devices, messaging systems, banking and e-commerce. Discover why Erlang systems have proved achieving 99,999% availability with a fraction of the efforts compared to conventional technologies. In contrast to systems written in Java, C or C++, thanks to its no shared memory approach, Erlang programs usually do not need any porting effort to scale well on multicore architectures. The presentation will conclude by introducing the growing Erlang community, the open source success stories such as CouchDB, Riak, RabbitMQ and Disco, and describe what companies such as Amazon, E*Trade, Facebook and Yahoo! are doing with Erlang.

A characterization test is a means to describe (characterize) the actual behaviour of an existing piece of software, and therefore protect existing behaviour of legacy code against unintended changes via automated testing. In this talk you will learn how you can generate characterization tests automatically for existing code bases.
A characterization test is a means to describe (characterize) the actual behaviour of an existing piece of software, and therefore protect existing behaviour of legacy code against unintended changes via automated testing. In this talk I will share my experience from a project where we generated fast running characterization automatically from existing slow-running integration/end-to-end tests. The characterization tests helped us do a major redesign of a core calculation module in an insurance system without breaking existing functionality. The talk will cover both the concept of characterization tests, as well as demonstrate an open source (.NET) framework for generating characterization tests for your application.

Groovy lends extra strengths to the Java programming language, and is recognized as a developer tool for solving practical problems. This tool can easily be applied to maven plugins, and proves to make them less error prone, easier to read and easier to test.
Groovy lends extra strengths to the Java programming language. These strenghts can be actively used to enhance Maven plugins. These plugins may often be quick and dirty, written by developers to solve some very specific problem. If they get adopted by projects, it should be compulsory to ensure their quality by code review and 100% test coverage. Many of the dirty fragments of code can be rewritten with Groovy to become both easier to read and maintan, and easier to cover with unit tests. This presentation sums up the experiences of having groovy-ised 3 (proprietary) enterprise Maven plugins: cxjboss, cxbuildnumber and mtregelverk.

Learn a new role for the Product Backlog in order to create more customer value in your project.
The Product Backlog is considered a cornerstone of agile software development. However, the Product Backlog can impede and sometimes even prevent good problem understanding, creativity, agility and ultimately spoil our attempts at creating something valueable. In this lightning talk we'll view the reasons for this deficiency, and sketch out some alternatives.

Writing clean code affects security. Here is how.
Det er vanskelig å legge sikkerhet til et system. Årsaken er at sikkerhet ikke er en ting som kan "legges til". Klarhet i kode gjør antagelser, misforståelser, og dermed feil, mindre sannsynlig. Tradisjonelle kodekonsepter som abstraksjon, innkapsling, kontrakter og navngivning er derfor viktige tema også når det gjelder sikkerhet. I denne lyntalen vil jeg gi utviklere kunnskap om hvordan de kan produsere sikrere kode.

An experience report using Scala Actors in a event based system for video conferencing. During the presentation you will see why, where and how we use Scala Actors. Exemplified with design patterns from the code.
Telecom services are in general based on event driven archictectures. With the introduction of Scala and Actors on the JVM platform, everyone developing concurrent systems has a new tool. The Actor model where introduced in 1973 and made famous by Erlang and Ericssons Telecom systems, and now finally available on the JVM. The presentation is an experience report based on implementation of a conference solution for video conferencing. The project started out in april 2008, switched to Scala and Actors in December 2009 and launched in june 2010. During the talk the main drivers for the architecture, how Scala and Actors are used and our experiences so far will be presented.

This session shows how to identify and leverage design elements that already exist in your code.
This session describes the current thinking about emergent design, discovering design in code. The hazard of Big Design Up Front in software is that you don't yet know what you don't know, and design decisions made too early are just speculations without facts. Emergent design techniques allow you to wait until the last responsible moment to make design decisions. This talk covers four areas: emergent design enablers, battling things that make emergent design hard, finding idiomatic patterns, and how to leverage the patterns you find. It includes both proactive (test-driven development) and reactive (refactoring, metrics, visualizations, tests) approaches to discovering design, and discusses the use of custom attributes, DSLs, and other techniques for utilizing them. The goal of this talk is to provide nomenclature, strategies, and techniques for allowing design to emerge from projects as they proceed, keeping your code in sync with the problem domain.

Hadoop is the divide-and-conquer MapReduce framework from Apache based on concepts from Google, and currently used to solve terabyte data computations at Yahoo, Facebook and even the Large Hadron Collider at CERN.
Moore's law has finally hit the wall and CPU speeds have actually decreased in the last few years. The industry is reacting with hardware with an ever-growing number of cores and software that can leverage "grids" of distributed, often commodity, computing resources. But how is a traditional Java developer supposed to easily take advantage of this revolution? The answer is the Apache Hadoop family of projects. Hadoop is a suite of Open Source APIs at the forefront of this grid computing revolution and is considered the absolute gold standard for the divide-and-conquer model of distributed problem crunching. The well-travelled Apache Hadoop framework is curently being leveraged in production by prominent names such as Yahoo, IBM, Amazon, Adobe, AOL, Facebook and Hulu just to name a few. In this session, you'll start by learning the vocabulary unique to the distributed computing space. Next, we'll discover how to shape a problem and processing to fit the Hadoop MapReduce framework. We'll then examine the incredible auto-replicating, redundant and self-healing HDFS filesystem. Finally, we'll fire up several Hadoop nodes and watch our calculation process get devoured live by our Hadoop cluster. At this talk's conclusion, you'll understand the suite of Hadoop tools and where each one fits in the aim of conquering large data sets.

By utilizing dynamic subclasses, you can create APIs which taste as sweet as sugar, but that defies the understanding of most developers. This presentation will look at libraries which can make your code easier to grasp, but harder to grok.
Dynamiske subklasser gir deg kode søt som sukker og magisk som voodoo. Det siste årene har det kommet flere biblioteker til Java som utnytter generering av bytekode på kreative måter for å lage veldig elegante API'er. Resultatet er kode som uttrykker ting veldig godt og konsist, men som virker på måter som virker magisk for de fleste. Ved å forstå magien, kan du nyte det kraftige verktøyet uten å sove dårlig om natta. Dette foredraget viser noen eksempler på slike API'er og noen erfaringer fra å lage et slikt API.

Test-Driven Development is common nowadays at the unit level. We find it helps at system-scale too. Starting from high-level tests helps us focus on what to deliver and to produce with better structural designs. Early integration also helps to flush out project issues at the start--when we have time to do something about it.
We present our experience applying "system-test first" test-driven development (TDD) in the development of large systems and systems-of-systems. We try to address integration and system testing as early as possible. The sooner the system is in a deployable state, the easier it is to react to changing business needs because we can deliver new features to users as soon as is deemed necessary. We therefore start by writing tests that build and deploy the system and interact with it from the outside and, to make those tests pass, add code to the system in the classic "unit-test first" TDD style. Many teams applying TDD start writing unit-tests and leave integration and system testing until late in the project because they find it difficult to write tests that cope with the distributed architecture and concurrent behaviour of their system. We will describe how we address common pitfalls, including unreliable tests, tests that give false positives, slow-running tests and test code that becomes difficult to maintain as the system grows. We will also describe how writing system tests guides our architectural decisions. Writing unit tests first guides design of the code to be flexibile and maintainable. In a similar way, we have found that writing system tests first guides the architecture to be easier to monitor, manage and support.

Good old silo applications combined with EDA-style messaging is the way out of the "SOA mess".
SOA-evangelistene har i mange år fortalt oss at siloapplikasjoner er noe vi må kvitte oss med så fort som mulig og erstatte med sammensatte applikasjoner basert på et "univers" av distribuerte (web)tjenester. En SOA-implementasjon ihht til en slik oppskrift går rett i mange av fallgruvene som er listet opp i "The Eight Fallacies of Distributed Computing", og skaper store problemer både ifm (videre)utvikling og drifting av slike løsninger. Siloapplikasjoner kombinert med asynkron meldingsutveksling (EDA) mellom applikasjonene løser mange av disse problemene. Dette gir en enklere applikasjonsarkitektur med løsere koblinger mellom systemer slik at det blir lettere å videreutvikle applikasjonene uavhengig av hverandre, det gir økt oppetid, og det forenkler applikasjonsdriften.

The switch to multicore servers will soon cause most "call-stack" type systems to run into severe performance trouble. To avoid this dilemma we need to find another architectural metaphor without that weakness. Right now Event Driven Architectures seem like the most promising idea around.
You thought you would get away from your performace problems at the next data center upgrade. The upgrade arrived, and they announced proudly that performance is now 35 % better. But, when you measure, the system is actually running slower - each request response time has become longer. This nightmare scenario is a realistic risk for most multi-user systems as they are written and deployed today. What has happened is that the shift from "faster processors" to "more cores" changes the characteristics of performance (latency and response time vs capacity and throughput). What we risk is that our software architecture will not be able to take advantage of hardware upgrades. Thus the shift to multicore will push us out of the "call stack comfort zone" and force us to rethink how we model and architect our systems. When looking for a new mind-set that will help us out from this performance and scalability nightmare, Event Driven Architectures seems like one of the best ideas around.

HA-solution anno 2010. This lightning talk will highlight the problem areas and describe a set of practical cloud solutions.
Mange bedrifter betaler alt for mye for å være tilstede 24/7, og mange leverandører lever fett på å selge HA-løsninger kundene egentlig ikke trenger. Hva slags kriseløsning trenger man og hvilke krav stilles det til den? Hvordan løse dette i skyen trygt, raskt og billig? Denne lyntalen kategoriserer problemområdene og skisserer et sett med praktiske skyløsninger.

Are you constantly finding yourself running your app in the debugger, joggling breakpoints and drilling your way through datastructures, just to figure out what the heck is going on, despite you have the full sourcecode? Work smarter, not harder - and throw your debugger away today!
Many programmers rely heavily on source-level debuggers, so much that whenever they come across a problem or some soucecode they don't understand, their first course of action is to fire up the debugger and single-step through it with their eyes glued to the list of breakpoints and watched variables. There are good reasons to break this habit, and in the process you will gain a deeper understanding of the application, enabling you to fix more bugs, improve the quality of the code, and simply become a better programmer.

This talk presents several performance anti-patterns along with a static analysis tool to discover them. The identified anti-patterns relate to inefficient call and data flows in the context of web-programming, communication, and data manipulation. To automatically discover these issues, we use a semantic code query system (Yonita).
People often blame the programming language for the performance or scalability issues of a certain piece of software. However, the significant number of this kind of issues has the source in the code of an application, and not the language used to implement it. This talk presents several performance anti-patterns along with a static analysis tool to discover them. The identified anti-patterns relate to inefficient call and data flows in the context of web-programming, communication, and data manipulation. To automatically discover these issues, we use Yonita, a semantic code query system focused on capturing the behavior of a program.

On October 1st Maven 3.0 will be released. Many infrastructure level technologies and tools have been created to enable the release of Maven 3.0 and this talk will give an overview of what these technologies are how they will take shape in the future. Sisu is the IoC system Sonatype has built on top of Guice, and is the base platform upon which all our tools are now built, including Maven 3.0. Aether is the new Repository API that has been generalized and decoupled from Maven which can be used as a stand-alone library to give any Java application some Maven repository-fu. Maven Shell what we see becoming the de facto way to use Maven 3.0. A long lived process with Maven super powers. Polyglot Maven is evolving into a family of DSLs to provide novel ways to use the Maven 3.0 core. Proviso is the production runtime provisioning system Sonatype is using internally for continuous delivery and is based on the powerful Eclipse p2 provisioning platform. Benson is Sonatype's Maven-focused distribution of Hudson taking into account everything that we've learned about Maven 3.0 during its development and how Maven should operate optimally within a CI environment: there will be no better way to work with Maven and Hudson. Benson is Hudson's brother from another mother. If there is time maybe we'll talk a little bit about Maven 3.1.

This session will offer a rich tour of the dependency injection buffet available in Spring 3. We will focus on configuring the container using a variety of "ingredients" such as Java, Annotations, Groovy with just a pinch of XML to please even the most sophisticated tastes. We will discuss the benefits and downsides of each "recipe", why you would pick one "dish" over another and how you can be mix and match them. At the end of the presentation, attendees will be familiar with the new Spring 3 "DI menu" for an "a la carte" experience.
This session will offer a rich tour of the dependency injection buffet available in Spring 3. We will focus on configuring the container using a variety of "ingredients" such as Java, Annotations, Groovy with just a pinch of XML to please even the most sophisticated tastes. We will discuss the benefits and downsides of each "recipe", why you would pick one "dish" over another and how you can be mix and match them. At the end of the presentation, attendees will be familiar with the new Spring 3 "DI menu" for an "a la carte" experience.

When complex matters become easy to configure, making mistakes becomes even easier than it used to. Spring transaction allows anyone to configure transactions with ease, but what happens when everyone does, even those with limited understanding of this complex matter?
Når det blir enkelt å konfigurere forholdsvis kompliserte aspekter, blir det samtidig lett å gjøre feil. Med Spring og @Transactional annotation har konfigurasjon av transaksjoner blitt noe hvem som helst kan gjøre. Men hva skjer når hvem som helst gjør det, også de med begrenset kunnskap om og erfaring med transaksjoner? Denne presentasjonen vil starte med å forklare hvordan transaksjoner settes opp i Spring, betydningen av en del transaksjonsinnstillinger. Videre vil den vise eksempler på svært uheldig transaksjonskonfigurasjon. Samtlige eksempler er tatt fra virkelige prosjekter. Avslutningsvis vil det komme anbefalinger på hvordan transaksjonene burde konfigureres. Presentasjonen vil forsøke å sette seg i utviklerens posisjon. Hva foregår i hodet på utvikleren når transaksjonen konfigureres hakkende galt? Hva i alle dager får for eksempel noen til å bruke REQUIRES_NEW? Hvorfor føler noen at NEVER er en god ide?? Og hva skjer når neste junior forsøker å "fikse" NEVER ved å slenge NOT_SUPPORTED foran...

Have you ever made your own client to monitor and administer your application? I will most likely show an awesome alternative way of doing that with SSH.
Har du noengang lagd egne klienter for å overvåke applikasjonen din? Eller bygd dashboards med JMX? Da har du kanskje gjort ting mere komplisert for deg enn du trenger. Jeg vil vise hvordan man kan bruke SSH for å lage lette terminalbaserte applikasjoner for å overvåke og administrere enhver Java-applikasjon. Implementasjonen som vises vil være basert på mitt 'termos'-prosjekt som er en implementasjon av readline/editline med sukker på.

Explore and accomplish stuff with the interactive console! A discussion (with live demonstrations) of some uses and benefits of interactive ('REPL' - Read Eval Print Loop) programming. Livecoding demos in Java, JavaScript, Ruby and Clojure.
Noen ganger er det for tungvint å lagre kode! Iblandt ønsker du bare å leke og lære - ikke skrive produksjonskode. Eller kanskje du har noe seriøst å utrette... men oppgaven er så liten at det blir kostbart å lage og vedlikeholde ny funksjonalitet. Da bør du prøve litt "fri-programmering" i et interaktivt miljø! Dette foredraget tar for seg et vanlig verktøy i mange dynamiske språk: det interaktive konsollet, også kjent som 'REPL' - 'Read Eval Print Loop'. Slike verktøy og miljøer gir deg kortere feedback-løkker og økt produktivitet. Vi skal se nærmere på når, hvordan og hvorfor du bør benytte deg av dette. Foredraget består av praktiske demonstrasjoner, morsom programmering (JavaScript, Ruby og Clojure)... og minimal tørrprat. Vi starter med det nyttige og jordnære (webutvikling) og ender i mer eksotisk og gøyalt stoff (3d-grafikk og enkel spillutvikling). Ta med popcorn!

Why testing is our version of calculus
"Real" Engineers use sophisticated mathematics to help with predictability and cost savings. So where is the software "engineering" equivalent? This session highlights why testing gives us advantages over traditional engineering, and provides a whirlwind tour through the thinking about design for the last few decades.

The dreamapp project is a maven archetype to generate a selfcontained "application" server. The server can be run standalone as an executable war, inside your IDE, with maven jetty:run or deployed in an application server. The idea is that the "hard" parts are solved so you can start with the business code faster, and be able to show some real results after first iteration. I have hope that others fork my dreamapp and create their own, that way we can share ideas!
Min drømmeapplikasjon "dreamapp" er en maven archetype som genererer en bundled executable java jetty webapplication. Man kan kjøre applikasjonen på fire måter, med maven jetty:run, som en unit test i din IDE, som en executable war eller i en appserver som en normal war applikasjon. Uansett hvordan du velger å kjøre den skal den oppføre seg likt, og tilby et "komplett" miljø med konfigurasjonsmuligheter og database klart til å produksjonssettes. Jeg så nylig en tweet som sa: "@benrady: Starting a new project. Step #1: Deploy" Dreamapp gir deg en flying start. Dreamapp ligger på github som gir open source utvikling en ny dimensjon med "sosial" koding. Målet mitt med dreamapp er at det skal bli forket i mange "dreamapps". Jeg har allerede forket applikasjonen selv i dreamapp-batch som genererer et skjelett for en typisk batch applikasjon. Så kom igjen, vis meg din "drømmeapplikasjon"!

Deliberate practice, The Princess Bride.
Deliberate practice is not what most of us do when we think we're practising. Learn what deliberate practice really is, and why it lies at the heart of agile development. See examples of the three main aspects of deliberate practice drawn from numerous books and also from the classic geek-cult-film The Princess Bride!

Overview of the 97 Things Every Programmer Should Know project.
The 97 Things Every Programmer Should Know project gathered contributions from a range of practitioners, offering a crowd-sourced cross-section of practical advice and insight for programmers in all walks of code. This talk introduces and discusses the project, and acts as an introduction for the lightning talks that follow.

Learn pattern matching in Scala!
Are you sick of the huge amounts of if-statements, instanceof-checks and type-casts it can take to destructure and match on a datastructure in Java. Does it annoy you that you can't switch on whatever you want or that you can't catch two kinds of exceptions in one catch block ? Then this talk is for you. Scala is here and packs a huge amount of cool features, many unknown to Java developers. One of those features is 'Pattern matching'. This talk will guide you through Pattern matching and explain what it is, how it works and how you can use it to write incredibly declarative code.

HTML5 WebSocket is a standard with the potential to bring unprecedented change to an otherwise very stale Web. Take this new communication channel and combine it with some of the other new features coming with HTML5, such as Canvas and off-line storage and it is time to start thinking BIG, really BIG!
W3C’s HTML5 standard has rapidly gained momentum as 2010’s hottest technology with help from companies, such as Google, Apple, and Microsoft. Developers and businesses alike are all trying to catch and align themselves with this new standard. Out of all the ideas and features in this new set of specifications, the most intriguing, exciting, and controversial section is HTML5 WebSocket. At first glance, some misinterpret WebSocket as merely a better transport protocol and replacement of HTTP or XHR. However, upon additional understanding, one quickly learns WebSocket is NOT a replacement or improved version of HTTP or XHR, nor do we want it to be! HTML5 WebSocket is a standard with the potential to bring unprecedented change to an otherwise very stale Web. What makes this new communication fabric so important is its simplicity and extensibility. We all assumed the Web was just there, and that HTTP provided everything we needed for Web communication. HTML5 WebSocket is the evolution of the communication fabric TO, ACROSS and WITHIN the Web and Cloud, and now we need to open our minds and start looking at the possibilities of this new way to communicate over the Web! Take this communication channel and combine it with some of the other new features coming with HTML5 such as Canvas and off-line storage and it is time to start thinking BIG, really BIG! This session is targeted developers and architects that are looking for better ways of increasing user experience and communication over the Web to create, improve, or replace existing Web applications. The session is also targeted developers and architects that just want to stretch their minds and receive the necessary information on making an educated assessment of the business and technical opportunities, and challenges, made possible by this new HTML5 standard. Wickedly cool demos, code examples, and comparisons with existing technologies and architectures will be used to illustrate these possibilities and their use cases.

Scala is one of the fastest growing languages on the JVM and Lift is the premier Scala web framework. Lift has been described by developers at eBay as being "not just an improvement on the status-quo, but redefining state of the art".
Lift is an expressive, elegant framework for writing Web applications. It stresses the importance of security, scalability, and performance while enabling high levels of developer productivity. Lift applications, written in Scala and deployed as WAR files offer very high performance and are being deployed in organizations as diverse as web 2.0 start-ups, right up to companies such as SAP. In this session, project committer Timothy Perrett, gives an overview of Lift and demonstrates its advantages for building rich Internet applications.

Deportalization (d13n) is the process of porting from resource hungry portal framework to light weight frameworks and servers. This is an experience report on moving from WebLogic Portal to Spring MVC.
Avportalisering, eller deportalization (d13n), er prosessen med å frigjøre en applikasjon fra tunge portalrammeverk, og ta den over på lettvekts rammeverk og servere. Noen ganger blir en applikasjon spesifisert og utviklet med tyngre rammeverk enn det viser seg å være bruk for. Dette er en erfaringsrapport fra en vellykket slanking der vi har flyttet en applikasjon fra Oracle WebLogic Portal over til Spring MVC og Jetty uten synlige endringer for brukerne.

Most projects sacrifice operational requirements on the alter of functionality. Consequently, both operations and development teams have to run from one critical situation to the other after going live. This session gives examples and advice how to handle operational requirements and behavior, providing example techniques and tools.
De fleste utviklingsprosjekter drives av funksjonalitet. De gode prosjektene fokuserer på vedlikeholdbarhet. Alt for få leveres med god driftbarhet. Tilrettelegging for drift bør prioriteres høyere i utviklingsprosjekter. Dessverre overskygges driftbarhet ofte av ensidig fokus på funksjonalitet. Resultatet er en kaotisk og uoversiktlig driftssituasjon med brannslokking og påfølgende etterarbeid. Denne sesjonen gir eksempler på hvordan man kan oppnå god driftbarhet med relativt enkle grep. Basert på positive og negative erfaringer fra flere prosjekter ser vi på hvordan applikasjoner kan tilrettelegges for drift samt konkrete teknikker og verktøy som kan benyttes.

10 steps towards robust batch processing is 10 easy steps based on years experience with batch processing of money transactions in BBS (banking, clearing and settlement).
Basert på mine 5 siste års erfaringer i BBS har jeg satt opp disse 10 enkle stegene for å lage stabile, enkle og driftbare batchsystemer. Etter dette foredraget vil du ha teknikker til selv å lage dønn stabile batchsystemer. Eksemplene baserer seg på ideer implementert i BBS som har kjørt i produksjon i flere år og som har vist seg svært stabile og driftbare. Eksemplene er implementert med Apache Camel ved å bruke komponentene i Camel, men også noen egenlagde komponenter. Det meste av det som blir presentert har sin bakgrunn i enterprise integration patterns. All implementasjonskode vil tilgjengeliggjøres. En viktig forutsetning for disse teknikkene og ideene er at ytelse ofte er ofret til fordel for enkelhet og robusthet, fordi kravene til batchsystemer ofte ikke er like harde på tid. Når det er sagt så har vi også kjørt nokså store transaksjonsvolum gjennom lignende arkitektur og den har vist seg å ha både tilfredstillende ytelse og tilfredstillende skalerbarhet. De 10 stegene kommer til å være outline på foredraget.

Mule 3 is another leap forward for integrators. It's more flexible, it's easier to use, and improves on Mule's already powerful feature set. This talk will show you the highlights, from the simplified "message processor" architecture, to building composable flows, to hot deployment and improvements in REST support.
Mule 3 is another leap forward for integrators. It's more flexible, it's easier to use, and improves on Mule's already powerful feature set. This talk will show you the highlights, from the simplified "message processor" architecture, to building composable flows, to hot deployment and improvements in REST support.

A deeper look at architectural trade-offs through the lens of the arts.
Winston Churchill once said, "First we shape our buildings, and afterward our buildings shape us." The architecture of buildings yields valuable insights into how the way we design buildings determines the kinds of things we do inside of them. The other arts show a similar pattern: every individual artwork participates in an artistic form of some kind, which provides beneficial boundaries around the kind of expression that form can carry. This provides a useful metaphor for software development. Rather than comparing languages and platforms using benchmarks and feature lists, the savvy architect pays attention to the tool's form. What is the tool naturally good at? What kind of values and priorities are reflected in a technology choice? Are they consistent with values of the team or the organization? Learn to see beyond the details and to the deeper structure of the technologies we employ.

About this time last year we discovered a memory problem in our application. None of us knew the first thing about memory issues, so I got the case just because I was the one who discovered it. This is the story of my venture into the world of memory troubleshooting.
About this time last year we discovered that we had a memory problem in our application. None of us knew the first thing about memory issues, so I got the case just because I was the one who discovered it. This is the story of my venture into the world of memory troubleshooting. This is a basic and practical talk for those of you who haven't dealt with memory issues before. I will demonstrate tools that you can use to gather and analyze data. You will also learn some of the most important things to know about garbage collection and memory management. After this talk you should be able to go ahead and start troubleshooting your own memory problems. You could also use this as a primer if you want to go to more advanced talks on memory management.

Learn about NOSQL and how to use Neo4J, MongoDB and Cassandra with Java.
NOSQL is a movement promoting alternatives to relational databases. The majority of NOSQL databases are pioneered by companies that have special requirements for huge amounts of data, where a relational database doesn't scale. There is more to NOSQL databases than scaling. They are designed to work well in distributed environments like computing clouds, and this attracts smaller organisations and startups. Developing an application backed by a NOSQL database is quite different from the more traditional ORM model that many Java developers have become accustomed to. I will present 3 different kinds of NOSQL databases (Neo4J, MongoDB and Cassandra) and show you how to use them from Java.

It may never have occurred to you that a language with keywords like 'class' and 'private' would have any issues with OO programming, but a particular view of objects suggests that within the larger language that is Java, there is a smaller OO subset trying to get out.
OO means different things to different people, but they normally focus on defining terms such as encapsulation, polymorphism and inheritance, and talk about data abstraction, abstract data types and so on. In this talk we take a brief look at what one particular view of OO suggests and what it means for regular Java programmers and their practice.

Oslo has one of the strongest software development communities in the world. Is it possible to make it even better and make Oslo most important place in the world in regards to Software Development?
Oslo har et rikt fagmiljø. Til tross for at vi er kun 500 000, har vi har ett av de sterkeste Java-miljøene og den største Agile meetup-en i verden. I tillegg har vi ett tyvetalls mindre, men svært entusiastiske communities. Hvorfor har det blitt slik og er det mulig å gjøre Oslo til verdens IT hovedstad? I dette foredraget får du en oversikt over hvilke fagarrangementer som arrangerers jevnlig. Det blir rask diskutert hvorfor communities har så gode rammevilkår i Oslo. Avslutningsvis vil det blir diskutert hva som skal til for å ta ut hele potensialet og gjøre Oslo til verdens IT hovedstad.

Presentation of some of the not so obvious pitfalls when doing concurrent programming on Java
Det er et økende fokus på multitrådig i applikasjoner, og javaspråket tilbyr gode muligheter for å skrive multitrådete applikasjoner. Dessverre er ofte abstaksjonsnivået for lavt, og utviklernes kjennskap til minnemodell og JVM-optimaliseringer for dårlig. Dette kan føre til problemer og ytelsestap som ikke umiddelbart er lett å oppdage. Jeg ønsker å vise hvordan Java og JVM'en kan oppføre seg uintuitivt gitt visse problemer.

This talk will present the JMS reference implementation; OpenMQ and how to utilize and configure this free JMS server. It will discuss scaling and performance aspects in various topologies and QoS configurations.
This talk will feature an introduction to OpenMQ, the JMS reference implementation from Sun (Oracle). OpenMQ is the JMS implementation for the Java Enterprise Edition reference implementation server,- GlassFish. The talk will show how to utilize OpenMQ from mixed clients; Java, scripting languages etc. The presentation will discuss configuration of various Quality of Service aspects from JMS. It will show the resntly introduces STOMP implementation as well as the new Bridge service for broker bridging. This talk will also show how to scale and utilize JMS brokers as an important element in an integration topology. This talk will focus on OpenMQ as a freely available and highly performing JMS server.

Keyboard navigation in Web apps are often overlooked or dismissed entirely in favour of a mouse-only interface. But people who use it require keyboard navigation to be effective. Keys should be consistent and work in all browsers. This talk shows you how to do just that.
Keyboard navigation such as shortcuts, access keys, tab index and component controls are often overlooked or dismissed entirely in favour of a mouse-only interface. But people who use the apps we build require keyboard navigation to be effective and avoid physical injury. What was once standard practice in systems and applications development goes from bad to downright terrible when you realise your shiny new app is being made to run in a browser and all the standard keys are ”taken” by the browser. To add insult to injury, browsers do not use the same keys for the same shortcuts. The talk shows the why and how from a non-programming standpoint by using examples from applications that have successfully implemented keyboard navigation, those who have not, and by showing how we did it in when rebuilding the central application for the Norwegian Government pension fund in Flex.

h1. This session contains covers NIO.2 or JSR-203 and discusses: * Listening for file system changes. * Manipulating basic file system attributes. * Accessing platform specific file system attributes easily. * Accessing underlying file system objects like partitions and devices.. * What Asynchronous I/O is and how to use it.
h1. The session describes NIO.2 along with comparing it with the IO capabilities of the previous Java versions. * The session discusses what NIO.2 provides to have full control over the file system in different platforms. * In this session we will see what NIO.2 provides for accessing file system attributes, watching file system for changes and performing File System operations like copy, move, delete and so on safely. * Accessing permissions and security attributes of file systems is another topic in this session along with how we can access the underlying objects like partitions, devices and so on forms another part of the session. * The session discuses the new asynchronous I/O API included in NIO.2 and how it can be used to benefit from asynchronous I/O on both sockets and files. * Migration path between older version and NIO.2 and performance differences are other subject discussed in this session.

* Learn about Vaadin framework for building rich internet applications * Get introduced to server-side RIA frameworks * Learn pros and cons compared to client-side RIA and Google Web Toolkit * Start writing beautiful web applications with Vaadin
Get introduced to Vaadin open source web framework by its founder. The framework provides a desktop-like user experience on the web without writing any HTML, XML or JavaScript. The user interface is written completely in Java and run at the server-side. Applications are deployed as Servlets, Portlets or to Google App Engine and run in any modern web browser without plug-ins or applets. Java-developers interested in writing rich desktop-like user interfaces for web should attend - no experience of web technologies is needed.

Many people try to bring Domain Driven Design into a project and fail miserably. This talk looks at how to properly introduce Domain Driven Design to a project and also covers many of the common pitfalls people run into.
Many people try to bring Domain Driven Design into a project and fail miserably. This talk looks at how to properly introduce Domain Driven Design to a project and also covers many of the common pitfalls people run into.

We believe that writing correct concurrent, fault-tolerant and scalable applications is too hard. Most of the time it's because we are using the wrong tools and the wrong level of abstraction. The Akka framework is here to change that. Akka is leveraging Scala, and using the Actor Model together with STM it raises the abstraction level and provides a better platform to build correct concurrent and scalable applications.
We believe that writing correct concurrent, fault-tolerant and scalable applications is too hard. Most of the time it's because we are using the wrong tools and the wrong level of abstraction. The Akka framework is here to change that. Akka is leveraging Scala, and using the Actor Model together with STM it raises the abstraction level and provides a better platform to build correct concurrent and scalable applications. For fault-tolerance it adopts the "Let it crash" model which have been used with great success in the Telecom industry to build applications that self-heals, systems that never stop. Akka's Remote Actors (backed by a scalable non-blocking IO impl), provides the abstraction for transparent distribution and the basis for truly scalable and fault-tolerant applications. In this talk we discuss what Akka is, how it can be used to solve hard problems and the ideas behind its design and implementation. Akka is available at http://akkasource.org/

Real performance testing: Learn how to test your web application with WebDriver and Grinder.
Applikasjoner bør alltid testes grundig, og stadig flere begynner å sette opp en suite med automatiserte funksjonelle tester. Mange hopper imidlertid over testing av ikke-funksjonelle krav som ytelse fordi ytelsestesting har vært kostnadskrevende og vanskelig å få til. Vi vil vise hvordan dette lett kan gjøres ved å bruke funksjonelle webtester som ytelsestester, og demonstrere hvordan disse kan kjøres kontinuerlig.

Learn how JSR-310 will change the way you work with dates and times!
Most applications have some kind of date and time logic, whether it be as simple as accessing the current date or as complex as managing the flight times of an airline. JSR-310 is a new standard being developed from Joda-Time to improve on the basic Date and Calendar classes. This session will explain the problems with the JDK classes, explain how JSR-310 solves them and showcase some advanced features for handling time-zones.

This lightning talk points out some pitfalls when implementing RESTful services and why REST is not always suited for the job.
REST-baserte tjenester er blitt populære og mange ønsker å bruke det i stedet for webtjenester og SOA. Men, REST egner seg ikke i alle situasjoner og utviklere får problemer når tjenestene skal implementere mer avanserte løsninger. Da må man ofte ty til løsninger som er tungvinte eller som bryter med prinsippene bak REST. Denne lyntalen diskuterer restriksjonene rundt REST og viser eksempler på hvordan man kan få problemer hvis man velger REST. Vit hva du gjør, kjenn restriksjonene rundt REST og ikke vær religiøs/fanatisk tilhenger!

This session provides a comprehensive overview of the Spring platform's support for enterprise integration and event-driven architecture. Featured topics include JMS and Web Services support as well as both the Spring Batch and Spring Integration projects.
Spring is well-known as an Inversion of Control container. Most java developers are familiar with its Dependency Injection, Aspect-Oriented Programming, and Data Access support. Many are also familiar with Spring's role in the web tier, including a Model View Controller framework, REST support, and conversation management with Web Flow. However, fewer developers are familiar with Spring's support for enterprise integration. In this session, Mark will provide a comprehensive overview of Spring's support for messaging, scheduling, and batch processing. You will learn how these features provide a platform for event-driven architecture. Examples will include integration with JMS, Web Services, email, and more. You will also learn about Spring's support for Hohpe and Woolf's Enterprise Integration Patterns including demos of Transformation, Routing, Splitting, and Aggregation of messages. Finally, you will see how the Spring Batch and Spring Integration projects may be used together for automation of batch operations.

Investment Banking and Payments expert John Davies will cover some of the more challenging aspects of matching engine design
A matching engine is a service that matches one item against millions of others, except in this case it's against billions and they're arriving in the millions. John will cover two scenarios of extreme matching engines, one for matching buy/sell orders against each other as the prices change on the trading floor, the other a credit card authorisation system. Both systems were implemented in Java with smatterings of C & C++.

In this session, you'll see how a designer working in Photoshop and a developer working in NetBeans can produce a great looking application together, thanks to JavaFX and the tools in the JavaFX Production Suite.
Many JavaFX presentations focus on what the code looks like and how the language works, but they rarely show how to actually get started. JavaFX is said to be both designer and developer friendly but how do you get the designers involved? In this presentation we'll show what a typical JavaFX workflow may look like, starting with a fresh installation of the JavaFX Production Suite and Adbobe Photoshop, and going all the way to a complete application.

Understand git-workflows, commit topologies and how they can influence your organization of work. Example-driven talk with demonstrations of all the git features needed to become a true master of git-fu.
So you've been using git a little; it's time for git-fu! Learn about git-workflows, commit topologies and how they interact when your project performs its everyday work. Understand merge, rebase, interactive rebase, interactive add, stash, cherry-pick and rerere; do you really need them all? Get the "zen of git", with "real world" use-case centric live demos!

Adding non-obtrusive javascript navigation, while keeping the site search engine friendly and accessible for all audiences, by way of elegant DOM-manipulation and Ajax.
Usually, JavaScript based navigation is not friends with neither search engines or todays requirements for accessibility. This live coding-session begins with a simplified website with plain old HTML navigation, and transforms it into something a bit more visually pleasing by way of event-handling, DOM-manipulation and Ajax-trickery. The goal of this lightning talk is to illustrate that one does not necessarily need to code some insanely advanced stuff to create some insanely advanced looking coolery.

The talk examines the experience of conversion from CVS to Mercurial. What are the pitfalls one can encounter on, how the distributed model changes the workflow for developers, whether they like it or not, and my tips to others who are planning to switch to the distributed model of source code versioning.
Javaprosjektet jeg jobbet på hadde benyttet CVS i 6-7 år, CVS begynte å bli tungt og upålitelig, spesielt i bygge- og leveranseoppgaver. Vi måtte bytte det versjonskontrollsystemet og valget falt på Mercurial. Lyntalen tar for seg erfaringer med konvertering fra CVS til Mercurial. Hvilke fallgruver en kan møte på, hvordan den distribuerte modellen endrer arbeidsflyt til utviklere, enten de vil eller ikke, og mine tips til andre som har planer til å bytte til den distribuerte modellen av kildekodeversjonering.

We have all met requirements that are detestable. But do they need to be? This session will show that by restructuring your code and requirements and have testability in mind from the start, your tests will be simpler, faster and easier to maintain.
Testbarhet er et viktig kvalitetskriterie for kode. Det blir stadig mer fokus på automatisering av tester, og at større deler av kodebasen skal kunne testes ved hver innsjekk. Men, vi har alle møtt på krav som ikke lar seg teste like enkelt. Tester på slike krav blir ofte store med lang kjøretid og vanskelige å vedlikeholde. For å kunne lykkes med automatisering av tester er det viktig å bygge testbarhet inn i koden vår. For å mestre dette må vi tenke testbarhet både i arkitekturen vår og i arbeidet med kravene våre. Denne presentasjonen vil ta for seg konkrete eksempler på krav og typiske løsninger som kanskje ikke lar seg teste så lett. Gjennom omstrukturering av både krav og kode vil vi se at disse kravene kanskje ikke er så "detestable" allikevel.

This presentation will show how a scalable search engine can be built by combining powerful open source tools - MySQL, Hibernate Shards and Apache Solr.
At Integrasco AS we've spent the last year developing a new data store and search engine for social media data mining. Our goal was a highly scalable design able to run on commodity hardware and with flexibility with regards to potential new future meta data and the ability to instantly make this available for searching. This presentation will be an experience report from this project and how we achieved our goals and implemented a search engine for analysis of social and consumer generated media. Using Hibernate Shards and MySQL for data storage, and Apache Solr for full text and meta data search we are now running a system which is easy to scale horizontally as our data and customer base continue to grow.

This talk will show you how to make a runnable version of your web application.
Har du noen gang irritert deg over problemer med applikasjonservere? Har du revet av deg hår i ren frustrasjon mens du har lett etter mystiske problemer i produksjon? Denne lyntalen viser deg hvordan du kan lage en kjørbar versjon av en web applikasjon som kan være oppe å kjøre på en ny server på under 5 minutter.

When developing with Mock objects, is it possible to avoid the code mirroring and bloating effect? Some simple steps to make it happen.
One of the issues with TDD and using mock objects is the high amount of code mirroring between the unit test code and the code under test. This duplication have some bad sideeffects: * Tests become brittle - later changes in the implementation may break them. * Tests become extremely verbose and can be hard to follow * Refactoring the tests may become difficult This lightning talk is focused on giving developers some solutions to this problem.

Explore how decision making dynamics can go wrong—and how to fix them!—at the individual level and in groups.
Alistair Cockburn has described software development as a game in which we choose among three moves: invent, decide, and communicate. Most of our time at No Fluff is spent learning how to be better at inventing. Beyond that, we understand the importance of good communication, and take steps to improve in that capacity. Rarely, however, do we acknowledge the role of decision making in the life of software teams, what can cause it to go wrong, and how to improve it. In this talk, we will explore decision making pathologies and their remedies in individual and team dimensions. We'll consider how our own cognitive limitations can lead us to to make bad decisions as individuals, and what we might do to compensate for those personal weaknesses. We'll learn how a team can fall into decision-making dysfunction, and what techniques a leader might employ to healthy functioning to an afflicted group. Software teams spend a great deal of time making decisions that place enormous amounts of capital on the line. Team members and leaders owe it to themselves to learn how to make them well.

The Play! framework focus on giving back the agility and productivity to the web developers. Though promoting simple and easy principles, it allows developers to build complex web applications.
The Play! framework is more than just yet another web framework in the Java eco-system: it is also another way of developing web applications. Like RoR, Django, it encourages fast and expressive development, with a clean and pragmatic API. Most importantly, perhaps, it brings simplicity to the Java world. It is the first web application framework in Java that is built by web developers for web developers. Because it is a simple, stateless framework that promotes a RESTful approach it offers the possibility of building complex web applications and, by extension, complex systems.

A short introduction to the embedded database support in Spring 3.0 The introduction will cover: * Why use embedded database? * XML-based and programmatic configuration of the database. * Testing data access logic using embedded database.
Med Spring 3.0 har det nå kommet praktisk støtte for innebygde Java database motorer, inkludert HSQL, H2 og Derby. I dette foredraget vil jeg gi en rask innføring i: * EmbeddedDatabase og EmbeddedDatabaseBuilder. * Konfigurasjon av database i XML og programmatisk. * Praktisk demonstrasjon av EmbeddedDatabase for enhetstest av DAO.

In this one hour presentation we will introduce you to the Android operating system. We will provide you with a brief history of the operating system, and give you an overview of the main concepts of Android development so that you can start developing your own Android applications. At last, we will introduce you to an application that make use of the concepts we have presented, and guide you all the way from development, to signing, and finally publishing the application on the Android Market. Welcome to Android 101!
Gartner har mobile applikasjoner på sin topp 10-liste over strategiske teknologier for 2010. Apple har med sin iPhone til nå vært nærmest enerådende i dette markedet, men har nå fått skarp konkurranse av Googles mobile operativsystem Android. Det selges mer enn 60.000 Android-enhter daglig, og Gartner spår at Android blir større enn iPhone i løpet av de neste to årene. Ikke bare er Android basert på Java, men utvilking er enkelt og ikke minst gratis å komme igang med. Dette foredraget vil fortelle deg hvordan. Android 101 gir en introduksjon til utvikling på Android. Etter en gjennomgang av Androids forhistorie, går vi gjennom de mest sentrale konseptene i Android SDK. Disse konseptene danner basis for å forstå hvordan man utvikler applikasjoner enkelt og effektivt. Vi avslutter foredraget med å gå gjennom et praktisk eksempel på utvikling av en applikasjon som nyttiggjør seg flere av disse konseptene. Vi viser hvordan applikasjonen kan debugges, før vi går gjennom hvordan applikasjonssigneringsprosessen fungerer. Etter å ha demonstrert dette, slipper vi den på Android Market!

Cloud computing is changing the fundamental assumption of how business applications are built and run. Scala has successfully merged statically and strongly typed object-oriented concepts with functional programming paradigm. Both of them combined define a bleeding edge for new wave of Java-based business application development. These new trends will define business application development for years to come and that’s why developers need to be aware of them today.
The topic of this presentation is about using Scala programming language with GridGain’s cloud development platform to provide a simple and productive cloud computing platform. Scala is a hybrid function and object-oriented language that is rapidly gaining traction in becoming the “next” Java in JVM-based language evolution. GridGain is one of the most rapidly growing cloud development platforms for JVM-based languages. 2/3 of the presentation will be devoted to live coding demonstration of writing basic MapReduce application in Scala using GridGain middleware. All coding during demonstration will be done live. Overview of grid and cloud computing concepts as well as notion of Native Cloud Applications will be discussed. Short intro into Scala language will also be provided.

Business Process Management describes the realization of efficiencies in the orchestration of systems and people towards a common goal. This presentation brings BPM to the people using Spring and Activiti.
Most people tend to model systems using services and entities. They forget that entities exist over time, and transition from one state to another. Often, these states are modeled as status flags on the entity. Unfortunately, this doesn't really work out in practice. It's like trying to describe a complicated customer fulfillment process using a UML sequence diagram - it's missing a few things: who is doing what, and - most importantly - when. There is a better way: a workflow engine can be used to extricate the process state from your application, and manage it. In this talk, we will explore the basics of workflow engines, and of process oriented architectures. We will introduce Activiti - a powerful, lightweight, embeddable workflow engine created by Tom Baeyans (the creator of jBPM) from Alfresco and explore its use in a Spring-based application

This presentation will provide the attendee with a simple way of building truly RESTful APIs using Qi4j and the DCI pattern.
Implementing a REST API today is important in many cases, both as an integration point to your application and as a way for clients to access the application. But there are few frameworks out there that help you fulfil all the constraints of REST, and therefore only makes your API a REST-wannabe. This session will look at how you can use Qi4j along with the DCI pattern to implement a truly RESTful API, that follows all the constraints. We will look at how DCI maps to the RESTful way of thinking about web API's, and how Qi4j can help with the actual implementation

An application's ARCHITECTURE predominately determines its performance - not the brand of infrastructure it runs on, and not "tuning" the infrastructure. This talk will illustrate the effect of architecture on performance with numerous case studies, and discuss performance-oriented patterns of architecture.
Unenlightened personnel in IT management may believe that simply switching from one brand of software infrastructure to another will be sufficient to solve an application’s performance challenges. Other groups of people – vendor support departments, and authors of application performance management literature – may recommend simply “tuning” the software infrastructure. But if an application is ignorantly architected, or too inefficient in its use of computing resources, then no amount of “tuning” will bring about the desired performance characteristics. This talk will demonstrate the effect of architecture on performance with numerous case studies, and discuss performance-oriented patterns of architecture at both macro- and micro- scopes.

How to practice unit testing and test driven development in JavaScript? This presentation walks you through challenges of unit testing JavaScript, a selection of available tools, specifically focusing on those suitable for TDD, and patterns for writing testable JavaScript. Finally, we take a look at tool integration, both for IDE's and continuous integration.
Enhetstesting og TDD/BDD er i dag fullt mulig også for JavaScript, men desverre ikke bredt praktisert. Hvilke verktøy er tilgjengelige for JavaScript-testing? Hva slags problemstillinger møter vi når vi enhetstester JavaScript? Hvordan kan JavaScript-testing jobbes inn i den øvrige utviklingsflyten? Det finnes konseptuelt forskjellige teknikker for å teste JavaScript - via nettlesere, emulering, eller i hybridmiljøer. Dette foredraget tar for seg fordelene og ulempene ved de ulike teknikkene samt gir eksempler med verktøy fra hver leir. Gitt et godt testeverktøy ser vi på noen patterns for testbar JavaScript og hvordan vi kan teste noen konkrete aspekter som er vanlige i JavaScript-programmering. Avslutningsvis ser vi på hvordan JavaScript-testing kan integreres med Maven og continuous integration-verktøy så som Hudson.

Using a simple application that implements a blog this talk with cover the highlights of both the new Enterprise OSGi specification, and the Apache Aries project.
The aim of software engineers everywhere is to develop modular, reusable and extendable applications, both for the desktop and the web. Building this kind of application is difficult and for numerous reasons applications typically devolve into being complex and monolithic. The Apache Aries incubator project aims to change this by bringing the modularity of OSGi and the power of the Java Enterprise Edition together to make it possible to build innovative new applications for the web. The project builds on, and extends, the OSGi Alliances Enterprise specifications to make it easy to develop new web, and enterprise, modular applications using well known and understood Java Enteprise Edition technologies. This session is intended for existing JEE and OSGi developers with an interest in learning more about how existing JEE technologies can be integrated and used in an OSGi environment. The presenter will use his experience as an OSGi Enterprise Expert Group member and as an Apache Aries committer to explain · How to use Apache Aries to build a simple Web application. · How to use the OSGi Blueprint Container Specification to create lightweight components. · How, using open source offerings, to build OSGi applications that can exploit the advantages of a managed JEE-like environment as well as the modularity and dynamism of the OSGi framework

Watch in amazement as I build a complete website with frontend and database integration in less than ten minutes, using the power of Spring Roo.
Springsource has given us many fancy tools over the years, and now they also offer a rapid application development tool that really works. Spring Roo is a command-line tool for building the scaffolding and domain of your project. During this brief ten minute talk, I will write, from scratch, a web-application with multiple, interrelated domain objects, a relational database, an ORM layer, and a web layer. Don't think I can do it? Let me prove you wrong. Key talking points: * Write a prototype while discussing the customer's problem domain with them, have a prototype ready by the end of the first meeting * Set up persistence layer with one command! Maintain persistence layer with one command! * Round-trip aware coding tool that actually works * Confound your architects; Establish a complete (and open source) application stack from right out the gate * RAD tool that is actually Rapid (as long as you accept the limitations)

Learn how to write solid JavaScript using the language's beautiful features.
You can write bad code in any language, but JavaScript has had its share of it. In this talk Anders Norås shows you how to write high quality JavaScript code, leveraging the beautiful features of this underrated language. We'll focus on the good parts of JavaScript and stay away from the bad. You'll learn how to leverage loose typing, dynamic object, functional programming and more to write solid JavaScript code. We'll also cover how to organize JavaScript code and how unit testing will conquer your fear of a dynamic language.

Agility should be your means, not the goal itself.
Plans are worthless. Planning is essential. - Dwight D. Eisenhower, general and president (1890-1961) Sett det altfor mange ganger; smidighet er målet og ikke middelet. Hvor mange ganger har du ikke hørt: "Da blir det ikke smidig!" Hva er egentlig målet ditt da?

Be productive while building desktop/RIAs for the JVM and have some fun while at it.
Building a desktop application is a hard task, there are some many things to keep track of that many projects simply fail to meet their goals. Setting up the project structure keeping each artifact on a well identified location given its responsibility and type, defining the base schema for managing the application's life cycle, making sure the build is properly setup, and more. These are recurring tasks that should be handled by a tool or better yet, a framework. Griffon is such a framework. Inspired by the Grails framework Griffon aims to bring the same productivity gains to desktop development.

Cloud, business value, decisions, psychology
Denne presentasjonen vil ta en case-orientert gjennomgang av de psykologiske barriærer som hindrer norske bedrifter i å realisere gevinstene ved cloud computing. Presentasjonen vil være praktisk rettet, hvor vi analyserer typiske personas og ser på de psykologiske hindringene disse har og geleider dialogen og prosessen rundt disse hindringene slik at man oppnår gode beslutningsgrunnlag. Siste del av presentasjonen vil være en en gjennomgang av typisk NEI-argumentasjon med relevante svar sett i IT anno 2010 perspektiv. Dette foredraget egner seg godt for utviklere og arkitekter som blir overkjørt hver gang de prøver å gjennomføre smarte løsninger.

This talk will present a way to fuse Model Based Development with web application framework Grails which is geared towards rapid development and prototyping. This is done using a plugin for the Eclipse Modeling Framework that is called "emf2gorm" to generate Grails domain classes from a EMF model.
Grails er på mange måter et glimrende vevapplikasjonsrammeverk, men det mangler fremdeles noen biter på å kunne kalle seg "Enterprisey", heldigvis. En av disse bitene er at rammeverket foreløpig ikke er godt støttet av de store modellbaserte utviklingsverktøyene. For å bøte på dette har det blitt utviklet en plugin til Eclipse som kalles emf2grails. Denne presentasjonen vil handle om hvordan man kan bruke Eclipse/EMF sammen med emf2grails for å gjøre modellbasert utvikling for veven med Grails.

This talk will describe a successful way to use development-, release-, bugfix- and topic-branches in Git and how the branching-strategy changes the way you work in your development process.
Git har de siste par årene tatt utviklere over hele verden med storm. Vi jobber mer fleksibelt, distribuert, offline, uavhengig og hvem-vet-hvordan. En av de store styrkene til git fremfor for eksempel subversion er måten branching og merging håndteres og mange strategier for hvordan dette brukes dag-til-dag finnes. I denne lyntalen vil jeg gå gjennom en fornuftig måte å bruke utviklings-, release-, feilretting- og topic-branches i git og hvordan disse spiller sammen i en utviklingsprosess.

Tips, tricks and best practices for effectively maintaining and enhancing legacy Java code.
"Yeah, the guy that wrote that code left the company five years ago so no one has really dared change that..." Heard this before? With a decade (give or take) of significant Java development in the rear view mirror more and more of us Java developers find ourselves spending more and more time maintaining and enhancing existing application rather than enjoying the sweet-smelling luxury of the green field. The challenges involved include code thats prohibitively difficult to understand, test, refactor or enhance, usage of outdated APIs, frameworks, designs and more. This session targeted at the Java developer in the above situation will look at some practical techniques and strategies for: Improving structure and readability, Writing and automating tests, Managing dependencies and more. All with the purpose of safely and effectively handling our Java legacy.

This session will provide an introduction to the Java Persistence API and then a presentation of some of the new features available in Java Persistence 2.0.
The Java Persistence API is the Java API for the management of persistence for Java EE and Java SE applications. It provides an object/relational mapping facility for the Java application developer using a Java domain model to manage a relational database. The release 2.0 has been expanded to include several key new features. This session will provide an introduction to the Java Persistence API and then a presentation of some of the new features available in Java Persistence 2.0. The talk will provide an overview of the object-relational mapping and modeling additions, the query language facilities, the new criteria API, pessimistic locking, and support for validation. The attendees will learn through several live code samples on how to get started with leveraging these features in Java EE and SE environments using NetBeans and Eclipse IDE.

I would like to take you through some of the issues, problems and solutions that I saw when building Erjang. Specifically, I will take you through what I think is wrong with "Java concurrency", and in which situations the conceptual model in Erlang is better. In Erlang you model systems with Actors; but how do we evolve from object-heads to actor-heads? How do we get to a point where processes are as intuitive and natural as objects and classes?
Over the last few years, I have been meeting "Erlang people" more and more often, and I am getting the impression that they have a magical ability to reason intuitively about concurrent systems in a way that I have not. It corresponds somewhat to the way we "object heads" think intuitively about classes and objects - just in terms of processes. That bothered me, so I wanted to learn Erlang. Being a language implementor, the most obvious way to do that is to just go ahead and implement an Erlang VM, right? The result of this "little exercise" is Erjang, an open-source JVM-based Erlang VM. It has turned into a non-trivial project, Erjang is now 50k lines of Java code, it runs substantial erlang programs, including booting OTP so you can use the Eshell, it self-hosts the erlang compiler (erlc) and tcp/ip functionality works. In this talk, I would like to take you through some of the issues, problems and solutions that I saw going through that exercise. And specifically, I will take you through what I think is wrong with "Java concurrency", and in which situations the conceptual model in Erlang is better. In Erlang you model systems with Actors; but how do we evolve from object-heads to actor-heads? How do we get to a point where processes are as intuitive and natural as objects and classes? Is short: I will explain how Erjang works, what I learned along the way, and demonstrate that Erjang runs well enough to be obviously useful.

Find out how the iPhone and Android app used in the augmented reality voucher hunt that will run at rabattjakt.no (and around in the real world!) has been developed to beta version in just two-three months using open tools and platforms. You can do something similar yourself before Christmas after listening to this 15 minute lightning talk! Technology keywords: AR/mobile, Layar, Guice, Hibernate Search, GWT, Facebook integration The presentation will cover: * Why: Mobile internet is booming, advertising groving, but small businesses not present * What: Demo of mobile/augmented reality view and web view with Facebook integration * How: Architecture, sample code ("Elegant code that works"), tools ("Good (many free!) tools are a job half done") * Super-short Q&A Presentation by Innovation Consulting CEO Sondre Bjørnebekk, with more than a decade of coding java for food under his belt.
Find out how the iPhone and Android app used in the augmented reality voucher hunt that will run at rabattjakt.no (and around in the real world!) has been developed to beta version in just two-three months using open tools and platforms. You can do something similar yourself before Christmas after listening to this ten minute lightning talk! Technology keywords: AR/mobile, Layar, Guice, Hibernate Search, GWT, Facebook integration

Ever had to restart your application server because of high load and abysmal response times? Let's investigate some smells, and how to find the culprit!
Ever had to restart your application server because of high load and abysmal response times? Do you know how to determine if the crash was caused by a garbage collection timeout or perhaps a live lock? This talk will show you some of the most common smells to look for, some tools to analyse the problem, and a few answers!

Writing concurrent software is complex, and there are many pitfalls and hazards to watch out for. However it is a lot easier to write threadsafe classes up front than to add concurrency later. What then should you do if you need to add concurrency to your existing system?
Vårt problem: fakturavolumet hadde vokst over hodet på vår Java batchapplikasjon. Etter iherdige forsøk for å øke ytelsen på vår serielle applikasjon, så parallellprosessering ut til å være eneste løsning. Vår første utfordring var å finne hvordan vi skulle parallellprosessere. Skulle vi bruke flere instanser av applikasjonen eller tråder? Valget falt på å bruke tråder, men hvor skulle vi benytte tråder, og var koden vi skulle parallellisere trådsikker? Kodebasen hadde vært utviklet over flere år, og ingen hadde dessverre fokusert nevneverdig på trådsikkehet. Neste steg på veien var derfor å analysere og dokumentere klassenes trådsikkerhet. Selve kodearbeidet gikk ut på å fjerne delt tilstand der det var mulig, og å dele opp og fyre i gang deloppgaver. Vår største utfordring var med en modul som måtte ha delt tilstand, og vi kommer til å presentere alle løsningene vi trodde ville virke, og den som til slutt fungerte. Implementasjonen vår brukte deler av Java 5 concurrency-APIet og vi kommer også til å demonstrere vår bruk og verifisering av denne koden. Vi hadde utviklet, verifisert, og ytelsestestet og valgte å produksjonssette. Dessverre oppstod mystiske feil i produksjon, og mistanken gikk straks til den nyinnførte trådingen. Vi fikk derfor også kost oss med den tidkrevende oppgaven med feilsøking av trådfeil. Gjennom presentasjonen ønsker vi å presentere steg for steg hvordan vi gikk fram, hvilke feil vi gjorde, og bakgrunn for de valgene vi tok. Vi vil også presentere noen generelle utfordringer innenfor parallellprosessering, inkludert implementasjon, testing, feilsøking, APIer og profilingverktøy.

Many development shops have made the leap from RCS, Perforce, ClearCase, PVCS, CVS, BitKeeper or SourceSafe to the modern Subversion (SVN) version control system. But why not take the next massive stride in productivity and get on board with Git, a distributed version control system. Jump ahead of the masses and increase your team's coding productivity, debugging, and agility at zero cost.
Many development shops have made the leap from RCS, Perforce, ClearCase, PVCS, CVS, BitKeeper or SourceSafe to the modern Subversion (SVN) version control system. But why not take the next massive stride in productivity and get on board with Git, a distributed version control system. Jump ahead of the masses staying on Subversion, and increase your team's productivity, debugging effectiveness, flexibility in cutting releases, and repository and connectivity redundancy (at $0 cost). Understand how distributed version control systems (DVCSes) are game-changers and pick up the lingo that will become standard in the next few years.

Appengine is Googles platform for cloud computing. The talk gives a short introduction to Appengine, and how to avoid limitations and constraints in the platform and the SDK.
Appengine er Googles plattform for cloud computing. Appengine er enkel å komme i gang med, men begrensinger i plattformen og SDK kan være utfordrende. I foredraget vil jeg fokusere på begrensningene og strategier for å styre klar av disse.

Hands on with four NoSQL databases.
I dette foredraget får du en rask innføring i fire alternativer til relasjonsdatabasen. Vi ser på tilgjengelige APIer samt går gjennom og kjører eksempelkode for vanlige operasjoner. Sweetspot og spesielle egenskaper ved de forskjellige teknologiene blir også diskutert. Etter at du har sett foredraget kan du sjekke ut eksempelkoden og gå hjem og eksprementere med spennende teknologi. Du får god forståelse for når du bør vurdere de forskjellige implementasjonene.

The aim of a cyber-dojo is to introduce deliberate practice to software development. The talk will explain the nature of deliberate practice, demonstrate a live kata using the cyber-dojo server, and give away copies of the server software to anyone who would like to run their own cyber-dojo.
The usual format for a code dojo is fairly well known: participants split into small groups, each group codes on their own laptop, all groups work on the same coding exercise with keyboard drivers rotating within the each group periodically. Towards the end of the dojo the coding stops and everyone presents their work in turn. This form of practice is often called a kata. A cyber-dojo is different in one important respect: each group still has their own laptop but they all perform the kata completely inside a web browser. A dedicated cyber-dojo server hosts the kata, saving the source files (and the outcome of running the tests) every time the run-the-tests button is pressed in the browser. Running a code-dojo in this manner creates many new exciting benefits including: 1. starting the kata is virtually instant - participants do not need anything installed at all. 2. all the step-by-step incremental run-tests submissions can be inspected helping to place a much greater emphasis on the decisions taken during the kata rather than simply the code at the end of the kata. 3. the cyber-dojo server allows everyone to peek at the current submissions of all groups! 4. since all development environments are now identical it is even possible to introduce timeboxed iterations to the kata and rotate codebases amongst the groups at each iteration! 5. it speeds up the end of kata retrospective (since you don't have to physically involve each individual laptop).

Computer programs fail from time to time and it can be difficult to find the reason for failure. Common issues are often the root cause for failures in a production environment. The following three problem areas will be presented: improper initialisation, the use of arrays and database related issues.
Feil i produksjon er ofte merkelige. De kommer og går, og de kan være vanskelig å oppdage. Hvor gjemmer slike feil seg i produksjon? Hvordan gjenkjenner man dem, og hvor skal man begynne å lete. Dette er feil som kommer fordi situasjoner oppstår som man ikke forventer, eller som man tror aldri kommer til å skje, fordi datasystemer brukes ikke som forventet, og brukerne kan være svært kreative.

Learn how NoSQL makes scaling easy and how to unleash the power of CouchDB
There has been a lot of hype around NoSQL lately. In this session, you will get a brief introduction to NoSQL and learn why you should consider retiring your trusty relational database in your next project. There are still things that relational databases do better than NoSQL, but you will see that in most cases the downside for scaling is not worth it. Important NoSQL systems to be aware of and that will be covered in this overview are cassandra, hbase/hadoop, CouchDB, MongoDB and Tokyo Cabinet. You will see specific examples of how the schemaless nature of CouchDB allows you to store multiple types of documents in a single database and why this is a good thing. Learn how CouchDB's powerful map reduce views can rid your code of SQL or SQL abstractions. A database without replication is useless and master-slave replication still makes for a slightly rigid and vulnerable storage system. Learn about CouchDB's master-master replication and how it's filters enables partial replications. Replication is both data protection and scaling to handle more load. To handle more data, you need to shard your data. Sharding is dividing your data across different servers. While you can preshard your data, the scary bit is often to reshard a running system. See how Pillow can help you handle your sharding and resharding needs. Reliability and consistency are important for a large scale storage system. You learn why eventual consistency is sufficient and how to ensure your system is reliable. There is also a reason why CouchDB and Pillow are both written in Erlang and you will get some background for these choices. The talk will conclude with some key learnings from a year of working with Ruby and CouchDB in the Amazon cloud, EC2.

This concise and entertaining presentation will provide the audience with practical tools to address project overruns in a cost efficient manner.
Software estimation is an inherently difficult discipline. Research has found indications that increasingly popular agile frameworks may in fact reduce overruns, yet agile organizations are hardly immune to overruns, delays and bad business decisions based on poor estimates. A practice such as planning poker may be beneficial. However, it only deals with some aspects related to the complex process of software estimation. The agile literature is mainly concerned with estimating sprints or releases, and does not address underlying issues such as estimates of overall project schedule and cost. There are also many other estimation pitfalls related to organizational issues in desperate need of attention. This talks presents seven cost-efficient ways to reduce your project overruns, ranging from simple checklists, to target-price contracts. It is suitable for customers, contractors, managers, team-members and anybody else frustrated with unpaid overtime, cancelled vacations and stranded projects.

In this talk, you will be given all the inside info on how to learn Scala effectively.
Scala har det med å fremkalle de store følelsene. I de siste månedene har vi lært oss Scala, og hatt humørsvingninger som manisk-depressive kan misunne oss. Det er ofte bare fem minutter mellom "hurra!" og "helvete!", og av de mange fallgruvene man kan snuble nedi har vi sikkert ligget i bunnen av mesteparten. Scala er svært kraftfullt, men har kanskje en noe bratt læringskurve. I dette foredraget vil vi dele den erfaringen vi har opparbeidet oss, slik at du slipper å gjøre de samme feilene vi har gjort når du lærer deg Scala og kan forsere læringskurven uten blåmerker på knærne.

Pojos + JAX-RS = Simple REST: "Jersey is the open source (under dual CDDL+GPL license), production quality, JAX-RS (JSR 311) Reference Implementation for building RESTful Web services."
Denne presentasjonen er en introduksjon til en meget lovende spesifikasjon, JSR 311 og dens referanseimplementasjon, Jersey: "Jersey is the open source (under dual CDDL+GPL license), production quality, JAX-RS (JSR 311) Reference Implementation for building RESTful Web services." Pojo + JAX-RS = enkel og testbar REST.

Demystify the HATEOAS constraint Implement hypermedia systemsin Java
Soon enough the development community will embrace the Web as a platform for building distributed systems. With the REST architectural style as our guide, we'll build solutions that easily span enterprises, and readily compose systems into end-to-end business processes. May of REST's "beneficial constraints" are widely understood - including the HTTP uniform interface. But one constraint - the hypermedia constraint - is renound for causing nosebleeds when developers try to understand it. This talk will demystify the hypermedia constraint, and show how services can use it to advertise protocols for consumers to drive over the Web. It will also introduce some Java patterns and general strategies that allow developers to drive protocols while remaining loosely coupled from the services that implement them.

Lot's of presentations on Map/Reduce use examples that cannot be related to real world problems. In this presentation I will show how you can use Map/Reduce to implement a scalable Collaborative Filtering Algorithm.
Map/Reduce er en effektiv måte å implementere løsninger som skalerer. Det finnes mange tutorials på Map/Reduce, men alt for mange av dem viser ikke hvordan man kan bruke Map/Reduce til å løse virkelige verdensproblemer. I dette foredraget vil jeg gi en kort intro til Map/Reduce og deretter vil jeg vise hvordan man kan kombinere flere Map/Reduce tasker til å løse oppgaver som man kan relatere seg til. Til slutt i foredraget vil vi ende opp med en Collaborative Filtering Algoritme som skalerer. Foredraget vil basere seg på Apache Hadoop, og vi vil også kjøre algoritmene på Amazon Elastic MapReduce.

During this talk we will examine the alternatives when defining an interface (API/SPI) in Java, and the limitation each choice imposes on the continued development of that interface.
"Ikke bli lurt av Javas interface – klasser er ofte best til å uttrykke grensesnitt" Hvis et grensesnitt (API/SPI) skal benyttes av flere enn en liten gruppe programmerere bør utviklingen skje på en kompatibel måte. Inkompatible endringer bør kun utføres hvis nytteverdien er høy. Men hva er en kompatibel endring? Og vil ikke kompatibel utvikling av APIer ødelegge smidigheten? Gjennom dette foredraget vil vi se på alternativene man har ved utforming av Javagrensesnitt og hvilke begrensninger hvert enkelt valg legger på videre utvikling av grensesnittet. Noen av temaene vi vil berøre er: * Design for enkel videreutvikling. * Ditt grensesnitt, ditt ansvar: Enkel mocking og testing. * Viktige forskjeller mellom Javas kildekodeformat og bytekode. * 100% bakoverkompatibilitet er umulig. Vi går gjennom ved hjelp av kode og eksempler.

Demonstration on how to set up SOA-security with OpenSSO
The open source Single Sign On- solution OpenSSO has become a very popular tool for providing SSO and other security mechanisms in both large and small organizations. The tool is both lightweight and very powerful at the same time since it supports important standards such as SAML2 and WS-Security. In addition to using OpenSSO to solve SSO needs for your web-sites, it can also be used effectively as a SOA security tool. This lightning talk will show the audience how you can create simple security solutions to secure your Web Services using the OpenSSO platform.

Integrating systems seems to be a complex endeavour in many organizations. It does not have to be that difficult. Join me for some integration basics that will enable you to integrate and maintain the integration over time.
På QCon tidligere i år lanserte Stefan Tilkov begrepet CSOA eller fullt ut: Common Sense Oriented Architecture. Det er på tide at vi slutter å forsøke å kjøpe oss ut av problemet med dyre, kompliserte løsninger og benytter intelligensen vår i stedet. "There is no silver bullet" skrev Fred Brooks i et paper i 1986 og siktet til at det ikke finnes noen teknologi som dramatisk vil forbedre effektivitet innenfor et tiår. Det virker som vi ofte vil tro på denne sølvkulen. Integrasjon er vanskelig. Og det hjelper ikke at vi forsøker å unngå problemet med produkter. Disse produktene kan gjøre ting litt enklere, men de gir også ekstra infrastruktur, bugs, ukjent software og lite transparens. Ved å holde seg til enkle prinsipper og rammeverk kommer man faktisk lenger på kort tid. I dette foredraget vil jeg ta for meg noen glemte fakta om integrasjon, og vise hvordan man kan bruke abstraksjon og enkle rammeverk for å gjøre integrasjon på en god måte. Kanskje du skulle bruke RMI? Hessian? Eller litt REST? Litt WS-* kanskje? Alle er forskjellige, det viktige er å finne ut hvordan du kan utnytte de best. Vær pragmatisk og jeg lover deg at du får en mye hyggeligere hverdag. Dette handler i bunn og grunn om enkle prinsipper og kontroll, men vi har alt for lenge forsøkt å unngå å lære oss disse tingene. Det er på tide å ta til fornuften igjen!

Reasoning behind the PositronLogger and how to use it.
The PositronLogger is a Log4j Appender that lets you change log level with retroactive effect. This is useful when a log statement with a high log level is printed, since it allows you to display more of the previous context than would have been printed otherwise.

Based on how the city administration of Oslo introduced the Confluence enterprise wiki as a collaborative multi-tool to aid with internal project management, we consider whether a structured approach to using wikis can provide the necessary means to solve actual use-cases in information management and user involvement.
The city administration of Oslo has recently introduced the Atlassian Confluence enterprise wiki to be a collaborative multi-tool for addressing several of their challenges with internal project management and organizing information. In light of this effort this lightening-talk will consider some of the benefits of taking a structured approach when adopting such grass-roots knowledge management tools, and how Confluence in particular is well suited to this due to its powerful plugin-framework.

Do you know what your enterprise apps get up to in their time off? Fighting fantasy, hypermedia-driven, RESTful Web adventures – of course. This session challenges the notion that REST is suitable only for CRUD-based data services, suggesting instead that the Web’s architecture provides everything we need to implement sophisticated business processes.
Do you know what your enterprise apps get up to in their time off? Fighting fantasy, pick-your-path, hypermedia-driven, RESTful Web application adventures – of course. In this speculative dungeon delve I show how hypermedia-driven Web applications implement rich workflows. In the course of the hour we’ll tackle the many-headed Hydra of HATEOAS, the “Hypermedia as the Engine of Application State” monster; level up through the Web services maturity heuristic; and meet the dwarves with grudges. On the way, we’ll learn how to model business processes as domain application protocols, implement them in terms of resource lifecycles, and advertise them using HTTP idioms, media types and link relation values. With techniques drawn from the forthcoming O’Reilly book "REST in Practice", this session challenges the notion that REST is suitable only for simple CRUD-based data services, suggesting instead that the Web’s architecture provides everything we need to model and implement sophisticated business processes in Web-based applications.

Results from my studies suggest that people produce more realistic effort estimate when asked to first estimate under ideal conditions and then under realistic conditions. The studies, the possible reasons for the effect and the implications for effort estimation are presented.
Estimater av arbeidsmengde er som oftest overoptimistiske. Gjennom flere studier har jeg funnet at det å starte med estimering under ideelle forutsetninger (for eksempel i form av ideelle timer) for deretter å estimere mest realistisk arbeidsmengde medfører at estimatene blir mer realistiske. Den samme effekten fremkommer ikke dersom man starter med å estimere minimum arbeidsmengde. Presentasjonen går gjennom disse resultatene og hvordan dette funnet kan brukes til å forbedre estimering (og andre prediksjoner) i systemutvikling. Avslutningsvis vil NM i estimering bli avholdt.

How can we get the motivation back into pair programming when programmers "forget" to pair up?
I prosjektet hadde vi bestemt oss for at parprogrammering var noe vi skulle gjøre. Selv om alle hadde vært med på avgjørelsen, fikk vi allikevel problemer med å gjennomføre det. Etter kort tid satt vi alle hver for oss og programmerte. I oktober 2009 dro jeg over til Kent Beck i Oregon på Code Camp '09, Iterates satsning på seniorutviklere. En av de tingene jeg lærte var hvordan man implementerer parprogrammering på en god måte. Jeg vil i denne lyntalen fortelle om hvordan jeg gikk fram for å reintrodusere parprogrammering basert på tips fra Kent Beck, hva vi gjorde annerledes denne gangen og hvordan vi nå greier å holde det ved like.

An overview of the NoSQL landscape in 10 minutes. What are the NoSQL alternatives and where are their sweetspots?
I denne lyntalen går Tobias gjennom alternativer til relasjonsdatabasen. Han ser på fire tilnærminger til NoSQL og gir eksempler implementasjoner samt forklarer når man bør vurdere hvilke alternativ. Etter foredraget har du oversikt over hva som skjer i NoSQL-verden og vet nok til at du skjønner når du bør vurdere hvilke NoSQL-teknologi.

In a quick glance behind the scenes I'll tell you how JRebel works its magic and what it takes to develop such a tool.
JRebel came out as a class reloading tool in 2007, with a promise to save your time by skipping redeploy. Since then we have delivered on that promise, and then some, and JRebel has grown to a large project with hundreds of thousands of line of code. In this talk I'll reveal the basic principles that JRebel uses to skip builds and redeploys and show you some of the code doing the work. I'll also speak about some of the (unique?) challenges that our team had to face and how we solved them.

Ehcache now supports JTA. As a result, caches can now complement the database in a consistent way. Helping to scale, even without scarifying coherence when clustered. This session introduces JTA, how a cache fits the picture and how to take advantages of the benefits Ehcache JTA brings to application developers.
With systems growing larger, architects keep on looking for faster, yet also as consistent as possible storage solutions. Caching the data close to its consumers is a well known approach, that comes with its challenges. But also at the cost of loosing much of what the database provides: a transactional and consistent data storage. This session will show, with concrete code examples, how a JTA enabled cache addresses issues faced by system implementors and architects: * How does a transactional cache compares to a non-transactional one ? * What does XA provide you with for consistency ? * How does a JTA cache fit in an existing Java application ? * How does it fit in an XA environment ? * How was it implemented ?

Git is hot - everyone wants to use it! But how do you best migrate from your current VCS? Is the tooling good enough? Do you need super-developers on your team? What workflows should you use? I will go through our experiences moving from ClearCase to Git in a large Java-based project, covering transition, challenges and daily use.
Git er et kraftig open-source, distribuert versjonskontrollsystem som er stadig mer i vinden, og mange ønsker å ta det i bruk. Hvordan får man til en smidig overgang fra sitt trauste sentraliserte versjonskontrollsystem? Er verktøyene modne nok? Kreves det superutviklere eller kan alle ta det i bruk? Hva slags arbeidsflyt og prosesser skal man bruke? Vi har tatt i bruk Git i et større Java-prosjekt som omfatter forvaltning og videreutvikling av et salgssystem. Systemet har vært i drift siden 2002. Inntil i fjor benyttet vi ClearCase som versjonskontrollsystem, men valgte å gå over til Git. Motivasjonen var å få bedre ytelse, flere muligheter samt å spare penger. I dette foredraget ønsker jeg å dele våre erfaringer med Git. Jeg vil dekke både selve migreringen fra et versjonskontrollsystem til et annet, utfordringer vi har støtt på og "best practice" for daglig bruk av Git i prosjektet vårt. Jeg vil også komme inn på hvilke andre alternativer vi evaluerte og hvorfor vi valgte Git.

Lessons from real life security problems transferred into the field of software security. How these lessons can improve how we apply and think about security.
Sikkerhet har vært en del av samfunnet i all tid. Være det seg vakthold, låsing, beskyttelse etc. Sikkerhet i informasjonsteknologi kan dra mange lærepenger fra gamle erfaringer. Hvorfor ikke lære av historien slik vi gjør i alle andre fagfelt? Applikasjonssikkerhet er et ungt fagfelt med mange nye ideer, tankesett og utfordringer. Dette har ført til en usikkerhet til hvordan man bør angripe sikkerhetsproblematikk og få løftet sikkerhet opp fra sin status som den plagsomme i vennegjengen.

An introduction to testing data access layers, and how Jailer makes the process of generating test data from existing production data a breeze.
Jailer er et open-source verktøy for generering av testdata fra eksiterende databaser. Verktøyet forenkler uttrekk av testdata fra en eksisterende database, ved å la bruker definere hvilke data og avhengigheter som skal hentes ut. I tillegg er det mulig å eksport data til sql, xml og Dbunit format. I dette foredraget vil jeg demonstrere hvordan man bruker Jailer til å trekke ut en subset av produksjonsdata, og eksportere det til et format som kan konsumeres av dbunit. I tillegg brukes Dbunit og Spring 3.0 embedded database for å demonstrere integrasjonstesting av DAO-lag i en applikasjon.

Did you ever read or hear about people who get paid to write open source software and wish you had that dream job? Did you ever look at an open source product and wonder how it was built in such a short time and with such high quality? Did you ever wonder how you and your company could get into open source development? If you’ve ever asked yourself these questions, then this session is for you.
Did you ever read or hear about people who get paid to write open source software and wish you had that dream job? Did you ever look at an open source product and wonder how it was built in such a short time and with such high quality? Did you ever wonder how you and your company could get into open source development? If you’ve ever asked yourself these questions, then this session is for you. Jeff Genender is an open source software enthusiast who took his passion for open source and became a contributor on several well-known open source projects, which finally landed him several positions that actually paid him to work on this passion. In this session you learn about: * Contributing and learning "The OpenSource Way" (tm); * The development process and tools sets commonly used in open source, as well as how to leverage a remote development model effectively; * How to get involved with the open source methodology and change the way your company develops software; * How to be a good citizen in the open source community - and maybe even get paid to contribute to open source!

node.js is an event driven serverside javascript framework that uses google's v8. Attend this talk to get an introduction to this new exiting javascript framework and learn how to get started.
Introduksjon til javascript rammeverket node.js. Node.js er et eventdrevet javascript rammeverk som bruker google's V8 javascript motor for å lage fleksible og skalerbare servere. Javascript språket egner seg veldig godt til event drevet utvikling. Rammeverket er lett å utvide siden det følger CommonJS standarden. Du skriver allerede frontend kode i javascript, hvorfor ikke prøve det på serveren?

Using the combination of Webdriver, JRebel and Jetty is magic for TDD development of web applications. You can start with test first and develop new features with zero turnaround time for build and deploy.
Hva skjer når man kombinerer WebDriver, et rammeverk for automatisert testing av websider, med dynamisk klasselasting fra JRebel og kjører dette på Jetty? Foredragsholderen mener at man får en magisk opplevelse av ekte TDD for webutvikling. Årsaken er at WebDriver gir muligheten til å skille verifisering av kravet fra navigering av websiden. Testene blir langt mer robust for endringer og mye tydligere i forhold til å forstå kravet. JRebel er et verktøy som gjør at man kan endre javakode på en kjørende server uten hotdeploy eller andre teknikker. Når man lagrer en kodeendring i IDEet oppdateres denne automatisk i kjørende Jetty serveren uten deploy. Dette er både enklere og langt raskere enn tradisjonell hotdeploy funksjonalitet som man f.eks. finner i Tomcat. I tillegg får man automatiserte tester som enkelt kan inkluderes i automatisert test og byggeoppsett (CI) basert på Maven.

Hvilke tjenester kunne du ha utviklet om du hadde fri tilgang til all rådata hos Statistisk sentralbyrå og Statens kartverk? Eller hva med hele NRK's arkiv i digital form? Denne våren har den nye portalen data.norge.no og gründer-konkurransen Nettskap 2.0 økt fokus på åpne offentlige data i Norge. I denne paneldebatten setter vi søkelyset på hva som blir gjort for å frigi data i det offentlige og hvordan dette kan skape spennende muligheter for oss som utviklere!
Hvilke tjenester kunne du ha utviklet om du hadde fri tilgang til all rådata hos Statistisk sentralbyrå og Statens kartverk? Eller hva med hele NRK's arkiv i digital form? Denne våren har den nye portalen data.norge.no og gründer-konkurransen Nettskap 2.0 økt fokus på åpne offentlige data i Norge. I denne paneldebatten setter vi søkelyset på hva som blir gjort for å frigi data i det offentlige og hvordan dette kan skape spennende muligheter for oss som utviklere! Det hersker bred enighet om at åpne offentlige data er noe positivt, men hvorfor er det da så vanskelig for det offentlige å tilgjengeliggjøre sine data? Hva slags potensiale finnes det i disse dataene fra et nyskaping/gründer/demokrati-synspunkt? I denne debatten får både dataeierne (representert ved Difi og Teknologirådet) og konsumentene (representert ved Oslo Open Data Forum) komme med sine betraktninger. Målet for sesjonen er at du som tilhører skal få et inntrykk av hva åpne offentlige data innebærer, hva situasjonen er i Norge i dag og hva man kan få til av nyvinning med tilgang på slike data. Kanskje blir du inspirert til å basere fremtidige prosjekter på åpne offentlige data eller kanskje engasjerer du deg i bevegelsen for å tilgjengeliggjøre mer offentlige data?

Apples “App Store Gold Rush” is over. What should a developer with an iPhone idea think of. How difficult are App Store releases to handle. With experience from an iPhone project available at App Store, these and more questions will be answered.
Apples “App Store Gold Rush” er over. Hva bør en utvikler med en iPhone-idé tenke på? Hvor vanskelig er det å håndtere Apples regime over hvem og hva som får lov til å slippes inn på App Store? Med erfaring fra et enkelt iPhone prosjekt, tilgjengelig på App Store, blir disse og flere spørsmål besvart.

Why do we still organize our code in strictly hierarchical structures, while we use tags to categorize our private pictures or interesting links? Learn why we should start tagging our code too, and the many advantages that would have.
Most languages allow source code to be organized in smaller units, like e.g. packages in Java. Usually, these units can be organized in their turn, thus creating a hierarchy of packages and classes, interfaces, enumerations, etc... In Java, these packages are closely tied to the file system's directory structure, which may not always be an advantage. Hierarchical structures are typical of the 20th century. In the 21st century, however, tagging has become a much more popular way to classify objects. Web sites like Delicious and Flickr are examples of places where people tag objects using keywords rather than storing them in a hierarchy. Just compare those sites to the yellow pages of the early days of the Internet, and you can see the difference in flexibility. So why do we stick to strict hierarchies for our source code while we're boasting we're so agile in everything else? Tagging the code with multiple tags allows programmers to browse the source code of a project using different perspectives. Do you want to browse your code by layer or by feature? Maybe you're trying to find all classes using a certain pattern? Maybe code coverage doesn't matter that much in a particular layer of your application, but is critical in one of the subdomains of the model? Clearly, a more flexible way to look at your code than a simple hierarchy would be more than welcome!

We present a powerful selection methods that can help you help to improve your software qualities dramatically, at low cost. All are freely adoptable. All can be tailored to your development environment immediately. All of them give measurable improvements. All methods here fit the ‘lean’ definition - upstream and preventative, proactive.
For People who are responsible for quality – who want to learn advanced practical approaches for getting all types of system qualities. All methods here fit the ‘lean’ definition - upstream and preventative, proactive.

See how much better Clojure is at handling concurrency than Java with the classical account example.
Det klassiske kontoeksempelet demonstrerer hvor vanskelig samtidighet (concurrency) er i Java. Clojure tar en helt annen vinkling på samtidighet. Kontoeksempelet blir enkelt i et språk som er laget for å håndtere denne type problemer. I denne presentasjonen vil du få en introduksjon til hvordan Clojure håndterer samtidighet på en bedre måte enn Java.

This lightning talk gives a quick introduction to the various classes of cloud computing services that are available, who provides them, what they can be used for and how they can make your life easier as a developer.
Denne lyntalen tar for seg hvilke typer skyer som finnes der ute, hvordan de kan klassifiseres og hvordan de kan brukes. Det vil bli gitt en rask gjennomgang av de mest populære alternativene og hvilke fordeler de gir deg som utvikler eller tjenestetilbyder. Etter presentasjonen vil tilhøreren sitte igjen med en god oversikt over de forskjellige tilbudene skyen har, så man raskt kan se verdier i forhold til egen IT-strategi og systemportefølje.

In this presentation, Gojko Adzic talks about common failure patterns with requirements and specifications on agile projects and talks about ideas, patterns and practices for requirements and specifications that lead to much less rework, more consistent specifications with less functional gaps and ultimately happier customers.
In this presentation, Gojko Adzic talks about common failure patterns with requirements and specifications on agile projects and talks about ideas, patterns and practices for requirements and specifications that lead to much less rework, more consistent specifications with less functional gaps and ultimately happier customers. Learn how to * spot and avoid common failure patterns in requirements/specifications * get to the right requirements and specifications * focus projects on delivering business goals

Do you think you need a Java web framework to be productive? Do you think that pair programming and test-driven development won't work for real applications? Do you think that some aspects of your web application cannot be tested automatically? Let us prove you wrong!
Do you think you need a Java web framework to be productive? Do you think that test-driven development won't work for real applications? Do you think that some aspects of your web application cannot be tested automatically? Let us prove you wrong! Starting from scratch, we pair program a Java web application which accesses the database, using only the servlet-API for the web part. Every aspect of the application is written test first. The whole development takes less than one hour from start to finish. Through the course of developing the application, we will introduce several useful libraries which makes it easy to write good tests for different aspects of a web/database application.

Aesthetics in languages is discussed rarely during software implementation. What is the benefit from writing aesthetically pleasing software, and how can we achieve such a goal?
Estetikk er et begrep altfor få softwareutviklere tar hensyn til ved valg av språk. Dette fører til at applikasjoner blir planlagt på designavgjørelser som har utelatt å ta opp et essensielt spørsmål; vil denne applikasjonen tjene på å bli skrevet i et språk som fokuserer på skjønnhet i kildekode? I denne lyntalen beskriver jeg begrepet om estetikk ved å bevege presentasjonen gradvis fra den tradisjonelle betydningen over til hvordan estetikk også er like aktuelt og synlig i språk. I lys av dette viser jeg at kildekode også er påvirket som en direkte konsekvens. Målet med lyntalen er å vise at skjønnhet absolutt er tilstede i språk og kan være med på å heve kvaliteten på programvare. Samtidig ønsker jeg å inspirere utviklere til å strebe etter en estetisk perfekt uttrykkelse i kode ved å vise hvilke fordeler det gir.

In today's data-sensitive and news-sensationalizing world, don't become the next headline by an inadvertent release of private customer or company data. Attend this session to gain a working knowledge of encryption and learn techniques for leveraging Open Source APIs that make securing your data as easy as possible.
In today's data-sensitive and news-sensationalizing world, don't become the next headline by an inadvertent release of private customer or company data. Attend this session to gain a working knowledge of encryption and learn techniques for leveraging Open Source APIs that make securing your data as easy as possible. Encryption is quickly becoming a developer's new frontier of responsibility in many data-centric applications. Protect your persisted, transmitted and in-memory data and learn the terminology you'll need to navigate symmetric and public key cryptography on the Java platform.

An introduction to the joys and woes of developing Android applications in Scala.
Scala er et programmeringsspråk som kjører på JVMen uten å være Java. Android er en mobil applikasjonsplattform for Java-programmer uten å være en JVM. Snodig nok og heldigvis lar disse teknologiene seg utmerket vel kombinere. I dette foredraget vil jeg gå igjennom hvordan du kan gjør nettopp det. Vi vil se på hvilke verktøy du vil benytte og kommer til å gå litt utenfor de stiene Google har gått opp for oss. Av dette får vi endel fordeler, men noen kameler må også svelges underveis. Som eksempel vil vi bruke et JMX systemovervåkingsverktøy (LittleBro) skrevet i nettopp Scala på Android. Formålet med dette foredraget er å gi tilhørerne lyst og kunnskap til selv å skrive Android-applikasjoner i Scala.

* CAPEX idag: 5-15 mill og 12 mnd * CAPEX med cloud og nisje SaaS: 100-500k og 1 uke - 1 mnd * DV/BI realisert i skyer lat deg styre virksomheten/prosjektene etter et kart som stemmer med terrenget ? * Med bruk av DV/BI i skyene gir jeg deg "an give you an offer you can't refuse" * Denne lyntalen belyser problemstillingen og gir deg noen løsningsalternativer.
Hvor ofte har du ikke slitt med prosjektgjennomføringen pga Excel-mafiaen? Denne lyntalen vil ta livet av excel-mafian engang for alle og det med enkle midler. En del har gjort store økonomiske dv/bi løft. - så dyrt at ingen skal røre det eller gjøre tilpasninger. Mange tar seg ikke råd. Mange mener de har ikke råd. - Det koster milioner å få en DV/BI-løsning opp å stå, mens excel er jo "gratis". DV/BI har ikke noe i et prosjekt å gjøre. Tør du å styre skuta de etter et draft som ikke stemmer med farevannet ? Ingen har råd til å navigere etter FEIL styringsinformasjon. Med bruk av skyer blir DV/BI fort billigere enn "excel". Ved å beytte skyer kan man raskt, trykt og billig få opp en fullverdig DV/BI løsning, en DV/BI løsning som vil kunne dekke virksomhetens behov. Informasjon er ferskvare, mennskelig informasjonshåndtering introduserer en foringet datakvalitet Dårlig datakvalitet gir tap av kunder. Ta tilbake kontrollen i ditt prosjekt i din virksomhet. DV/BI til massene ! DV/BI realisert i skyere vil kunne tilgjengelig gjøre informasjonen 24*7 : Hvor som helst, når som helst.

Unfortunately architecture may do more harm than good, in spite of the architect's well meaning intentions. We take a journey through more than ten years of architecture experiences, what works and what sucks. From this starting point we look at the Norwegian governmental architecture principles.
Arkitektur kan gjøre mer skade enn nytte, på tross av arkitektenes gode intensjoner. I etterpåklokskapens tildels pinlig klare lys presenteres arkitekturerfaringer fra over ti år med Java-prosjekter, og trekker slutninger om hva som har fungert eller vært en fiasko. Med dette som bakteppe ser vi med kritisk blikk på DIFIs arkitekturprinsipper som statlige virksomheter skal følge, og vurderer om dette er arkitektur på vondt eller godt. Ikke minst ser vi på hvilke prinsipper som glimrer med sitt fravær.

The presentation explains the garbage collection strategies in the Sun/Oracle JVM (including Java 7’s "garbage first (G1)" collector) and discusses strategies for tuning and configuration of the various collectors.
The JVM developed by Sun Microsystems (now owned by Oracle) has been refined and revised with every release of the JDK since the advent of Java in the mid 90ies. Today, Java developers face an abundance of GC algorithms - from plain and simple serial stop-the-world collectors with a single reaper thread to highly parallelized collectors that run several GC threads concurrently with application threads. Each of these collectors can be configured and tuned in various ways in order to control pause times or increase throughput. The number of choices a Java developer has for configuring the JVM’s garbage collection for his application is overwhelming. Hence, garbage collector tuning for the SUN/Oracle JVM is a daunting task. The tutorial aims to shed light onto the garbage collection strategies in the Sun/Oracle JVM by explaining all algorithms (including Java 7’s “G1” collector) and discussing strategies for tuning and configuration of the various collectors.

The Play! framework is more than just yet another web framework in the Java eco-system: it is also another way of developing web applications. Like RoR, Django, it encourages fast and expressive development, with a clean and pragmatic API. Most importantly, perhaps, it brings simplicity and fun to the Java world. However, simplicity does not mean being limited to simple web applications. The framework gives you enough power to actually create just anything you can think off: with continuation, web socket support, asynchronous call it is one of the first framework to empower you. We will dive into details on how to use those features and realize that it is actually quite simple, Scala might even be part of the program... Infinity and beyond are now reachable to Java Web developers!
The Play! framework is more than just yet another web framework in the Java eco-system: it is also another way of developing web applications. Like RoR, Django, it encourages fast and expressive development, with a clean and pragmatic API. Most importantly, perhaps, it brings simplicity and fun to the Java world. However, simplicity does not mean being limited to simple web applications. The framework gives you enough power to actually create just anything you can think off: with continuation, web socket support, asynchronous call it is one of the first framework to empower you. We will dive into details on how to use those features and realize that it is actually quite simple, Scala might even be part of the program... Infinity and beyond are now reachable to Java Web developers!

The tools and techniques of SOA can be used to serve the customers of the business, or they can become goals in and of themselves. This talk provides a balanced view of service oriented architecture (SOA).
At JavaZone 2005, I gave a talk with the title "Why I hate SOA". In the talk, I outlined several weaknesses with the then much-hyped term Service Oriented Architecture. Six years have passed, and I have learned much. The question is: Has SOA learned the same things? In this talk, I will outline the real value proposition of Service Oriented Architecture: That of focusing on the services your business provides, both to human and computer users. By focusing on the business services, small, feature-oriented teams can deliver value. The thinking and tools of SOA can be used to serve the customers of the business or they can distract a project for its real goals. I will examine three shortcomings in many approaches to SOA: The focus on tools, the focus on reuse, and the use of SOA as an application architecture. Tools, reuse and application architecture have their place, but once they take the driver seat instead of delivering services to the user of the business, things can go wrong. The integration tools of SOA, when applied wrong, conceal the reality of most projects: 90% of integration problems can only be solved by people talking together. The reuse vision of SOA, when applied wrong, conceal the reality of most projects: Reuse is a most often trap, not an opportunity. Using SOA as an application architecture conceal the reality of most projects: Organizing developers as mindless cogs will force them to behave mindlessly. The talk will be filled with real world examples.

Compare and contrast various asynchronous web approaches and get a feel for where one might be a better choice over another.
The world is all about the asynchronous web these days. There are an increasing number of options for Java developers. In this presentation we'll cover 3 such options: comet, servlet 3, and websockets. We'll look at code and discuss pros and cons of each approach. We'll also cover any updates that come with Servlet 3.1 (which will likely still be a work in progress.) We'll look briefly at possible mitigation approaches when you find yourself bound to a particular approach. This session assumes at least a passing familiarity with the concepts as there won't be too much time to deep dive into each approach.

Modern programming conventions lead to cowardly writing of code. We will poke a hole in this abscess of cowardice, and look at the delightful code that crawls out.
h1. Feigheten rår. Allment adopterte konvensjoner for hvordan vi skriver kode er feige, og reduserer oss til et minste felles multiplum av hva vi tror andre programmerere kan. Vi skal sprekke hull på feighetsbyllen, og se hva slags deilig kode som kommer krypende ut.

High Five Driven Development and other easy learning methods one can apply in any project to increase the motivation in it.
Lyst til at jobben skal være en lek? Dårlig motivasjon på jobben? Lyntalen kommer til å kort gå inn på hva High Five Driven Development er og hvordan den utføres, samt andre enkle metoder for å øke motivasjonen på jobb. Dette er enkel coaching for ikke-coachere.

Experience report describing advanced requirement techniques such as Innovation Games and User Story Mapping
De siste tiårene er det blitt gjort store forbedringer innen programmeringsspråk, testing, systemutviklingsmetoder, m.m. Likevel er restulatet av sytemutviklingsprosjekter ofte skuffende. Løsningene virker ikke som forventet, de er unødig dyre og noen ganger tilogmed farlige å bruke. Vitenskapelige studier viser at underliggende årsker til at prosjekter feiler ofte kan spores tilbake til kravene, dette trass i et stadig økende fokus på områder som smidig utvikling, prototyping, kommunikasjon med klienter og inkrementell utvikling. I dette foredraget ser vi på noen sentale problemstillinger innenfor kravspesifisering og går gjennom prinsipper og teknikker som er vi har funnet nyttige, blant annet innovation games og user story mapping. Foredraget er basert på egne erfaringer, “best practise” og forskningsresultater.

h1. What your boss wants and how you can meet the expectations This lightning talk focus on the expectations of senior executives and how agile frameworks can be used to meet those expectations in a sustainable way.
This lightning talk focus on the expectations of senior executives and how agile frameworks can be used to meet those expectations

Given today’s increasingly complex application portfolios, a modern developer is faced with more and more non-programming tasks in addition to delivering code. This talk offers 12 concrete scripts that may free your energies so that you can get back into the highly productive state referred to as “flow”.
During this presentation I will present 12 scripts and hacks, ready to be copied and pasted into your project. They may either save you time directly, or help you cut down on the vast number of “TODOs” you have to juggle and keep track of in your mind when being responsible for an application portfolio. This way, you will hopefully have more time focusing on what you should spend most of your time doing: pushing code- or configuration changes into a production environment. Some scripts may be directly applicable to your project “as-is”, whereas others may function as a basis for customization and adaption to similar tasks. A few may even help you identify similar tasks and processes you falsely consider to be a “tedious manual job that I hopefully won’t have to repeat later”. And even if you cannot justify the few couple of hours it takes with a direct ROI within your first week, see these scripting jobs as an exercise to stay sharp. It is like doing ten push-ups before going to bed - you know it is good for you, and that it only takes a couple of minutes - you just conveniently “forget” it. If you are still not convinced, see these small scripting jobs as a way to improve your mental hygiene, by allowing yourself to do boring work in a fun way. If you find writing scripts more boring than creating and following up documents and spreadsheets, then you might be ready for a career change. Many of the example scripts have, by choice, been written in languages that do not need extensive installation procedures, lots of configuration, or big frameworks. The languages include Bash/Cygwin, Windows Command Line / PowerShell, cleartool, SQL, ant, and ”JUAN”; a home-made notification addon to JUnit.

Strøm, nettverk og diskplass er "smør og brød" utviklere som primært har jobbet med serverside utvikling. Mobile klienter tar med seg en rekke uvante problemstillinger som jeg ønsker å sette fokus på i denne lyntalen.
Veien til mobilutvikling kan virke kort for Java "EE" utviklere. Java er jo bare Java, right? Når man kommer i gang, finner man fort ut at ting er snudd på hodet. Klienten betaler for datatrafikken, man har ikke ubegrenset med strøm og lagringsplass er blitt en begrenset ressurs. I denne lyntalen ønsker jeg å dele mine erfaringer med andre serversideutviklere som ønsker å komme i gang med Android. Fokuset vil være på de utfordringene kan vil støte på når man går inn i mobilutvikling med mest server-side erfaring.

The tutorial explains the Java memory model: visibility of memory modifications in multi-threaded systems, reordering issues, volatile and atomic variables, initialisation safety and final fields, and lock-free programming.
With the increasing availability and use of multicore processors Java developers need to acquire some understanding of the Java memory model. This is because multithread applications that work nicely on a single-core processor might exhibit "inexplicable" deficiencies when running on a multicore processor platform. The reason may be differences in the caching strategies applied by different processors. In order to illustrate the issues this tutorial explains the Java features for multithread programming. Key topics include: memory model, visibility and reordering issues, volatile and atomic variables, initialisation safety and final fields, lock-free programming.

Experience report from using the open source monitoring system Nagios in the project implementing the Pension reform -- the biggest SOA project in Norway. Over 3000 measurements were polled regularly, on over 150 servers, on about 20 separate test and development environments, with one Nagios server to control it all. Custom functionality was written to enable testing of web services and other kinds of services, both on the service bus and directly towards backend systems.
Mange organisasjoner bruker overvåkningsverkøyet Nagios fordi det er open source og lett å komme i gang med. Det har også blitt brukt for overvåkning av servere og tjenester i norges største SOA-prosjekt, Pensjonsprogrammet, og her presenteres noen erfaringer med Nagios i denne sammenhengen. Nagios har overvåket helsen til over 3000 målepunkter fordelt på over 150 servere, fordelt på rundt 20 separate test- og utviklingsmiljøer. Nagios har også blitt utvidet med egenutviklede plugins som gjør det mulig å teste webservices og andre typer tjenester, mot tjenestebuss eller direkte mot baksystemer.

Programming Java can be easier than most people realize. We'll show you some techniques that will reduce the amount of code you'll have to write, and create a system that will actually be able to change when you need it to. Sprinkle some TDD on top and we've finally found a way to work that makes Java fun again.
Java må ikke være vanskelig, tregt og kjipt å jobbe med! Ok, kanskje det ikke er et ekspresstog som Rails, men ihvertfall et lokaltog med fin utsikt. Til tross for mange nye spennende alternativer, er Java fortsatt språket og plattformen mange av oss må forholde seg til i en god stund fremover. Java kan være enklere og morsommere enn mange tror. I dette foredraget vil vi vise deg de elementene vi mener må på plass for å jobbe med Java på en enkel, effektiv og endringsdyktig måte. Vi vil demonstrere hvordan du kan gjøre TDD mot web, holde kontroll på testdata, sikre enhetlig validering og holde koden din objektorientert. 4 ting på en gang! Vi har vært så heldige å få teste teoriene våre i reelle systemer det siste året, og har kommet et godt stykke på vei med teknologier som Spring, Maven, JUnit, WebDriver og Spring MVC. Vi vil forklare konseptene som gjør utviklingen enklere, og jobbe med kode for å illustrere poengene. Det er mulig å skrive ren, enkel og endringsdyktig kode i Java uten at det må gjøre vondt. La oss vise deg noen av triksene våre.

There are other ways to get good user experince than touch technology! By incorporating physical sensor listeners, it is possible to introduce new intuitive behaviors. This speech is an introduction to Android sensor services and how this can enrich user experience.
Vi forventer i dag å få servert enkle og intuitive brukergrensesnitt. I løpet av de siste årene er dette ofte realisert ved å ta bruk av touch-teknologi. Ved å innlemme fysisk sensorlyttere, er det mulig å introdusere ny intuitiv atferd for å forbedre brukeropplevelsen enda mer. Androidtjenester gjør det svært enkelt å legge til denne funksjonaliteten. Denne talen er en introduksjon til Androids sensortjenester og hvordan man, ved å ta i bruk dette enkle verktøyet, kan berike brukeropplevelsen.

Webbit is a small and fast pure Java web server with WebSocket and EventSource support. Learn how to stream data to the browser.
Webbit is a small and fast pure Java web server with WebSocket and EventSource support. Learn how to stream data to the browser. http://webbitserver.org/

Learn how to design your applications so that they can reliably handle documents and data sets of any size, without blowing your entire hardware budget on memory. Discover how streaming applies to services (REST and SOAP), database connections (JDBC and JPA), and large documents (XML and JSON).
Modern frameworks and libraries make it easy to expose application features as services. However, if used naively, the resulting services are often severely limited in the size of data they can accept. If clients try to pass even moderately large documents, such systems will lag, hang, or crash hard with an OutOfMemoryError. This talk describes how to design your applications so that they can reliably handle documents and data sets of any size without choking, and without blowing your entire hardware budget on memory. Areas covered: * Designing your APIs for streaming * Streaming patterns * Streaming services (web services and REST) * Handling large XML and JSON files * Handling large data sets with JDBC and JPA * Parallelizing streams * Connecting streams, with or without helper threads

HTML5 are here with a big bunch of sister and brother specifications and a lot of these can be used already today. A lot of these specifications will also change a lot of the way we design our web solutions and it does also open completely new doors for web development and how we do architecture. The attendee will be take on a tour trough the history of HTML5, the HTML5 specification and its sister and brother specifications.
HTML5 are here with a big bunch of sister and brother specifications and a lot of these can be used already today. A lot of these specifications will also change a lot of the way we design our web solutions and it does also open completely new doors for web development and how we do architecture. The attendee will be take on a tour trough the history of HTML5, the HTML5 specification and its sister and brother specifications.

Does your CI server give you all the feedback you need (and all it can deliver)? Or does it merely compile some code and run some tests? Unleash the full power of your CI server with deployment pipelines and spread the love outside the development teams too.
Utnytter du egentlig potensialet i CI-serveren? Eller bare sitter den der og kompilerer koden, kjører noen tester og en og annen metrikk? Er det bare utviklerne som har et forhold til den? I dette foredraget får du en innføring i konseptet deployment pipelines, og innføring i hvordan sette opp pipelines i Jenkins CI. Og hva dette kan gjøre med organisasjonen din. Skru CI-serveren opp til 11, involver større deler av teamet og gjør hele utviklingssløpet kontinuerlig, ikke bare integrasjonen.

We will show a scenario where a malicious hacker attacks a website and how he leverages the advanced techniques available to him. In short, we will show how hackers attack, exploit and abuse web sites in order to make money off you and your users.
Hackers can pose a serious threat to businesses if the threats they pose are left unhandled. We will show a scenario where a malicious hacker attacks a website and how he leverages the advanced techniques available to him in order to get what he wants while remaining undetected. We will explore what an attack may consist of and look at the different stages of a given targeted attack. The purpose of this presentation is to give the audience insight into the parts that make up an attack on a website.

A short introduction to Apache Wicket's concepts: components, behaviors and models; integrating with Spring, testing your web pages with Wicket's internal test framework. Most importantly we'll take a look at the new Wicket release 1.5 and see what has changed for the better and worse.
Apache Wicket is a component oriented Java web framework. With proper mark-up/logic separation, a POJO data model, and a refreshing lack of XML, Wicket makes developing web-apps simple and enjoyable again. This talk provides a short introduction to the framework's concepts: components, behaviors and models. We'll take a short look at integrating with Spring and integrating with JQuery. For the test infected we'll cover testing your web pages with Wicket's internal test framework. But most importantly we'll take a look at the new Wicket release 1.5 and see what has changed for the better and worse.

Code reviews increase code quality and reduce defect rate. But not necessarily for the reasons you might think.
You should do code reviews. Why? Because they increase code quality and reduce defect rate. But not necessarily for the reasons you might think.

* Lombok AST Transformations (& Implementation) * Groovy AST Transformations (& Implementation) * IntelliJ IDEA Static Analysis (& Implementation) * CodeNarc Static Analysis (& Implementation) * Spock Testing Framwork * Groovy++ Language * Mirah Language and Macros
AST Transformations are how many language features are implemented, and is the magic behind frameworks like Lombok, Groovy, Mirah, IDEA Inspections, CodeNarc, Spock, and Groovy++. This session reviews these approaches including examples of how and why we'd want to do this. Come see the newest language tools, look in-depth at production deployed AST Transforms, and view libraries based on these techniques.

Are agile projects a contradiction of terms?
Smidig begynner å bli veletablert, men for å komme videre må fortsette å utfordre det etablerte. Vår default mentale modell er fremdeles "Prosjekt" - og her ligger også den største hindringen for å bli smidige. Her ligger også synderen som fører til dårlig kvalitet og misfornøyde brukere. Er Smidig Prosjektstyring egentlig en selvmotsigelse?

This lightning talk explains why poor connection handling with queues can cause serious downtime, and discuss a template to help fix the problem.
Programming mistakes never make it past code reviews, extensive testing and continous integration, right? Unfortunately not. Programming mistakes go live and cause downtime. So, what are the typical mistakes that sneak past testing, and end up frustrating both customers and operation crews? In my experience, poor connection handling when dealing with queues and topics are overrepresented. In this lightning talk I focus on a few situations where connection mistakes lead to serious incidents. I also briefly go through the Spring JMS Template. This framework is a good starting point for making sure your application isn't too greedy with the connections.

Denial of Service (DoS) attacks can easily take down your web application. This lightning talk will give some examples that may smash your web application and send you a large bill.
Det finnes enkle tjenestenektangrep (Denial of Service- / DoS-angrep) som vil få mange webapplikasjoner til å gå over ende. Denne lyntalen viser noen av de enkleste og mest effektive angrepene som kanskje også fungerer mot din applikasjon. Og har du noen gang tenkt over at en et DoS-angrep kan koste bedriften din dyrt? Ikke nødvendigvis bare i tapte inntekter, men også i direkte utgifter.

Learn how easy continuous building and testing can be used in your Android projects by using Jenkins/Hudson.
A hands-on introduction to automated Android application testing using Jenkins CI. During this lightning talk we will create Android application and test projects and setup Jenkins to run continuous integration tests automatically from a code repository. The tests can run on either a physically connected device or an emulator, enabling a real-life scenario for the tests.

Crazy and profound examples of code that contribute to history or provoke current understanding of the practice of programming.
In most disciplines built on skill and knowledge, from art to architecture, from creative writing to structural engineering, there is a strong emphasis on studying existing work. Exemplary pieces from past and present are examined and discussed in order to provoke thinking and learn techniques for the present and the future. Although programming is a discipline with a very large canon of existing work to draw from, the only code most programmers read is the code they maintain. They rarely look outside the code directly affecting their work. This talk examines some examples of code that are interesting because of historical significance, profound concepts, impressive technique, exemplary style or just sheer geekiness.

Wrapping your Ajax calls makes for happy tests, consistent error handling and some neat tricks.
Jeg viser deg et enkelt grep du kan gjøre med Ajax-kallene dine som gir deg tydeligere kode, bedre feilhåndtering, og gjør det lettere å teste. For du tester vel JavaScripten din?

A crash-course in the theory and implementation of functional data structures using Scala as a host language.
This talk will cover the theory and implementation of 6 unique functional data structures in Scala. We'll start out with the concept of functional persistence and then dive right into actual data structures. Each data structure will be motivated and built up by the associated theory and ideas. All of these will be illustrated (with requisite colorful diagrams) and implemented with the necessary trappings to be a first-class Scala Collection. Finally, we'll look at some of the real-world constraints imposed by hardware architecture and the JVM itself, touching on how these constraints affect data structure design in ways that the theory doesn't show.

Cake mixes consist of a mix of things you already have in your cupboard plus a load of unnecessary, potentially harmful preservatives. They cost more than making cake from scratch, the resulting cake tastes worse, they take away people's confidence in their ability to make their own cakes, and they don't even save you any time. Hibernate has the same misperceived benefits and the same draw-backs. Gordon Ramsay wouldn't be caught dead using any cake mix. As professional programmers, we should be more sceptical of generic frameworks like hibernate.
Cake mixes consist of a mix of things you already have in your cupboard plus a load of unnecessary, potentially harmful preservatives. They cost more than making cake from scratch, the resulting cake tastes worse, they take away people's confidence in their ability to make their own cakes, and they don't even save you any time. Hibernate has the same misperceived benefits and the same draw-backs. Gordon Ramsay wouldn't be caught dead using any cake mix. As professional programmers, we should be more sceptical of generic frameworks like hibernate.

XP developers follow a certain way of life. Take something good and turn it up to the extreme. Extreme Performance Testing is born out of ten years experience working with XP, with the goal of further integrating performance testing into a normal XP development process.
XP developers follow a certain way of life. Take something good and turn it up to the extreme. Extreme Performance Testing is born out of ten years experience working with XP, with the goal of further integrating performance testing into a normal XP development process. No longer will you need to treat performance testing as just another stage towards production. Taking performance testing to the extreme is often viewed as difficult requiring special skills, extra resources, and much more time. In this talk, we'll look at Extreme Performance Testing's key practices, effectively translating the agile values and principles into a different set of practices. We'll look at real world examples that demonstrate these practices in action, understanding their positive impact on projects. We'll also explore the prerequisites for making Extreme Performance Testing most effective, and the reinforcing practices that amplify their positive effects. You'll come away from this talk with concrete advice on how to better integrate performance testing into classic agile methods and how to apply Extreme Performance Testing to your projects.

Code templates is an underused feature in most IDEs. This talk will, by using a live code session, demonstrate how you can use code templates. You will learn both how to use existing code templates and how to create your own.
IIn my experience many java-developers is not aware of the many features included in their IDE. Code templates are one such undiscovered feature. In this talk I will demonstrate how code templates can be used. I will code a real life example and use code templates both to generate code for test code and production code. The demonstration will be performed in Eclipse, but I will also describe how the same features can be used in other IDEs - such as Intelij. After attending the talk you will have learned how you can use existing code templates in your IDE and how you can create your own.

Hadoop is a MapReduce framework that has literally sprung into the vernacular of "big data" developers everywhere. But coding to the raw Hadoop APIs can be a real chore. Data analysts can express what they want in more English-like vocabularies, but it seems the Hadoop APIs require us to be the translator to a less comprehensible functional and data-centric DSL. The Cascading framework gives developers a convenient higher level abstraction for querying and scheduling complex jobs on a Hadoop cluster. Programmers can think more holistically about the questions being asked of the data and the flow that such data will take without concern for the minutia. We'll explore how to set up, code to, and leverage the Cascading API on top of a Hadoop cluster for a more effective way to code MapReduce applications all while being able to think in a more natural (less than fully MapReduce) way. During this presentation, we'll also explore Cascading's Clojure-based derivative, Cascalog, and how functional programming paradigms and language syntax are emerging as the next important step in big-data thinking and processing.

Complexity Theory is a new and intriguing discipline, offering powerful insights that unify observations of the natural world, mathematics, and computer science into a few elegant concepts. Come see what Complexity means, where it's found in nature, and how it can make us better software developers.
Some systems are too large to be understood entirely by any one human mind. They are composed of a diverse array of individual components capable of interacting with each other and adapting to a changing environment. As systems, they produce behavior that differs in kind from the behavior of their components. Complexity Theory is an emerging discipline that seeks to describe such phenomena previously encountered in biology, sociology, economics, and other disciplines. Beyond new ways of looking at ant colonies, fashion trends, and national economies, complexity theory promises powerful insights to software development. The Internet—perhaps the most valuable piece of computing infrastructure of the present day—may fit the description of a complex system. Large corporate organizations in which developers are employed have complex characteristics. In this session, we'll explore what makes a complex system, what advantages complexity has to offer us, and how to harness these in the systems we build.

Views and "instead of" triggers can be used to support backward compatible changes to a database schema.
Hva gjør man når det er over 20 systemer som er direkte integrert på databasenivå og man ønsker å endre datamodellen? Dette er ikke et umulig problem, løsningen er å gjøre endringen bakoverkompatibel! Vi ser på én mulig løsning: Bruk av view og "instead of"-triggere.

Functional programming with less pain in Java.
Java-språket får hard medfart og utallige sleivspark i Twitter-sfæren fra utviklere som ønsker like mye frihet og uttrykkskraft som tilbys av andre språk. Jeg vil vise hvordan man med et Collections-bibliotek kan bruke funksjonell stil også i Java, og oppnå snasen, lesbar og gjenbrukbar kode.

How should an action point look like? Let's have a look at our top 7 action points after 40 retrospectives.
Kontinuerlig forbedring og læring er noe de aller fleste snakker om i forbindelse med smidige metodikker, men mange faller igjennom når retrospektivet skal gjennomføres og aksjonspunkter skal følges opp. Etter 3 år og pluss 40 retrospektiv har vi gjort oss noen erfaringer om hvordan et aksjonspunkt bør se ut, hva det bør inneholde, hvor mange man bør ha og hvorfor noen fører til forbedringer og andre ikke. Dette eksemplifisert gjennom våre topp 7 aksjonspunkter.

The ability to inject code into compiled classes is of immense help when troubleshooting problems, especially in an enterprise environment. I'll present three different real-world cases where code injection came to my rescue; solving each one with a different tool and within the constraints at hand. Come and learn them!
This presentation is aimed at giving you the knowledge of code injection that you may (or I should rather say "will") need and at persuading you that learning basics of code injection is really worth the little of your time that it takes. I'll present three different real-world cases where code injection came to my rescue, solving each one with a different tool, fitting best the constraints at hand. I'll also provide you with resources to learn the basics and tools easily and quickly. This is a practical presentation; we won't introduce AOP and will explain code injection only briefly, plunging right into the tools and how they can help you.

Experiences and lessons on how to select languages and libraries for the Java-platform
For designing and implementing systems there are choices like do you use Java or Scala, Spring or Guice, Eclipse or Intellij. Equally important are a clear strategy on how to introduce technology into your organization, keeping developers productive and integrate new technology into existing projects. Even the great Java-platform needs help from developers, architects and project managers to be as successful as the last evangelist explained to you. This presentation is a collection of advices based on experience from the last 10 years introducing Java-platform technology into new and existing projects. Examples will be given on how to choose language and libraries, how to learn, how to integrate, what is important for developers, how to handle project managers, all with the purpose of explaining how you can use fun and exciting technology to deliver your project.

Day in and day out we are subjected to poorly designed applications. From those we experience directly to the time we waste waiting on others who are struggling with systems that seem like they were built to hinder the user. It doesn't have to be like this and many users are waking up and demanding better applications. Are you prepared to deliver? After this workshop, you will be. When you're done, you'll have the tools you need to make sure your application helps your users kick ass! Usa-what now? While most developers are schooled in algorithms and programming languages, they often lack a grounding in the fundamentals of usability; we'll start by exploring what usability is dispelling many of the myths surrounding this misunderstood aspect of software. We'll show why usability matters and help you see how it can make the difference on your projects. The who - developing pragmatic personas. We can't build a great UI without knowing who we're building it for. Personas are a time tested technique to help teams understand their users and facilitate building the right interface. While personas are often backed by extensive ethnographic research, they don't require months and months of effort. We'll explore the use of pragmatic personas to see how they can simplify the task of interface design. As an exercise, we'll develop personas for our application. The what - figuring out just what to build. Of course just knowing who we're building for is only part of the picture, we have to know what our users are trying to do. Wether you favor use cases, user stories or more traditional requirements documents, at the end of the day our customers are using our application to further some other goal. In this section we'll discuss tasks and scenarios showing how they contribute to the overall design process. Using story maps, we'll write up a set of user goals expanding them into tasks that will help us design a set of interfaces. The how - designing rocking good interfaces. Want to know the secret to designing great interfaces? We'll talk about the importance of iteration; just as our code is rarely right on the first try, neither are our interfaces. To facilitate the iterative process, we'll discuss the vital importance of paper prototyping. That's right, paper and pencil are your best tools. We'll also talk about why some designs are better than others discussing the heuristics that are second nature to the experienced designer. We'll also discuss design guidelines talking about how to make sure yours aren't just a dusty document sitting in a rarely visited corner of the LAN. We'll sketch up a variety of approaches focussing on quick and dirty designs that allow us to explore a plethora of options. Testing our design - making sure we're on the right path. Just as we test our code, we must test our interfaces. While we may not have UIunit at our disposal, testing our UIs is just as important as testing our code. From recruiting users to preparing the space, we'll discuss how to get ready for a test. We'll talk about the various roles in a user test from the all important moderator to playing computer and taking notes. User tests can be very stressful, we'll discuss ways to put our customers at ease. We'll also discuss the best way to communicate the results of testing to the rest of your team. We'll prepare a deck to test a given scenario. We'll take that deck and test it with our "customers." Of course we can also desk check our interfaces using standard heuristics - we'll look at some existing applications discussing what was done right and what could be done better.

CoffeeScript is JavaScript without the Bad Parts, without the mess of braces and semicolons and bad design decisions. CoffeeScript is just the Good Parts, with a concise and pretty new syntax thrown in for free. Ever wish you could put the fun back in JavaScript? Let me show you how.
JavaScript. Love it or hate it, in the web development world it's impossible to avoid it. It was designed in one week by one man at Netscape, just to keep the browser from standardising on something even worse -- and it shows. Oh, it's not all bad, but the Good Parts -- which actually make up a pretty neat language -- are well hidden in among all the Bad Parts, which are there to make you, the JavaScript developer, suffer. CoffeeScript is a language designed to take the Good Parts out of JavaScript and make a new, concise and beautiful language out of them. It runs anywhere JavaScript does -- in fact, it compiles to fairly readable JavaScript -- so you can already use it in your web applications and wherever else you've been stuck with JavaScript. In this talk, you'll learn what CoffeeScript looks like, how it relates to the JavaScript you know, and what new features it has to offer. In fact, if you already know JavaScript well, you'll probably be perfectly fluent in CoffeeScript after this -- it's that easy. And trust me, your life will be so much better for it.

This session covers the Spring platform's support for NoSQL data stores and open protocols for messaging. It features a sample application designed to focus on modularity as a key enabler of the benefits of a cloud runtime, such as on-demand elasticity and "always on" availability. The application will be deployed to Cloud Foundry.
Applications are increasingly facing demands for horizontal scalability and cross-platform interoperability. NoSQL data stores are gaining momentum as a way to address the scalability challenges, but for Java developers, this means we need to explore new territory beyond relational database libraries like JDBC and JPA. Messaging systems are by their very nature able to handle distributed deployment models, but for Java developers, the cross-platform challenge suggests we should look beyond JMS. Open protocols such as HTTP and AMQP are attractive language-neutral alternatives. In this session, you will learn how the Spring application platform is evolving to accommodate these trends. We'll briefly explore the Spring Data APIs for working with NoSQL data stores, and we'll discuss open protocol options for messaging via Spring Integration Gateways and Channel Adapters. We will also take a quick tour of Cloud Foundry from an application developer's perspective. The session will include a demo of a sample application designed to demonstrate the characteristics of modularity that allow an application to take advantage of a cloud environment. It will make use of the RabbitMQ and MongoDB services available on Cloud Foundry.

Learn how to deploy Java applications on Windows Azure, Microsoft’s cloud services platform – this hands-on presentation takes you through the process from start to finish.
Presentasjonen gir en praktisk innføring i javautvikling på Microsofts Azure platform. I løpet av sesjonen utvikler vi en java applikasjon som vi bygger og deployer til Microsoft Azure. Det vil bli presentert nyttige tips og triks for de som ønsker å utvikle Java-applikasjoner som skal kjøre i nettskyen til Microsoft.

Have you ever wondered how to design a RESTful data format? This talk will tell you how.
What is a hypermedia format? This talk will define what a hypermedia format is. We will look at different types of formats, and try to create our own using design patterns commonly found in existing formats. We will also look at how the 7th constraint of REST applies (HATEOAS or the hypermedia constraint) to hypermedia and its use.

Learning the syntax of a new language is easy, but learning to think under a different paradigm is hard. This session helps you transition from a Java writing imperative programmer to a functional programmer, using Java, Clojure and Scala for examples.
Learning the syntax of a new language is easy, but learning to think under a different paradigm is hard. This session helps you transition from a Java writing imperative programmer to a functional programmer, using Java, Clojure and Scala for examples. This session takes common topics from imperative languages and looks at alternative ways of solving those problems in functional languages. As a Java developer, you know how to achieve code-reuse via mechanisms like inheritance and polymorphism. Code reuse is possible in functional languages as well, using high-order functions, composition, and multi-methods. I take a variety of common practices in OOP languages and show the corresponding mechanisms in functional languages. Expect your mind to be bent, but you’ll leave with a much better understanding of both the syntax and semantics of functional languages.

Understanding Java bytecode can bring to the light some of the aspects in Java that may not seem obvious from the first sight. This talk will introduce you the JVM and bytecode basics with a lot of examples and some practical tips for problem solving.
If you never goofed around with assembler or machine code Java bytecode can seem an obscure piece of low-level magic. But sometimes things go really wrong and understanding that bit may be what stands between you and solving the problem at hand. Looking to deepen you Java programming skills? Understanding bytecodes is necessary to solve performance issues, some classloading issues and to generate code at runtime. And some things you can do are just plain freakin' cool. This talk will introduce you the JVM and bytecode basics using live coding examples. It's my hope that you'll walk out armed for the next battle with low-level issues. From the basics, to more advanced gotchas: * How to obtain the bytecode listings * How to read the bytecode * How the language constructs are mirrored by the compiler: local variables, method calls, optimizations, autoboxing, exception handling, etc * insight to some bytecode manipulation libraries (ASM, Javassist)

Introducing the Apache incubator project Whirr: it starts clusters in the cloud. You'll learn exactly how Whirr works, even in a sophisticated context like HBase. System Architecture, Code, and Configuration, and the Cloud will be discussed, not to mention how to use whirr to avoid knowing all of this.
Whether it's HBase, Cassandra or one of the many others, you've probably already hears about NoSQL. Perhaps you've wanted to try it out, but don't have the infrastructure or expertise to setup an elaborate clustered environment. During this talk, you'll see how to make your own NoSQL platform using infrastructure clouds such as Amazon EC2 or GoGrid. We'll demonstrate how you can use Whirr to start up your own configurable cluster with just a couple of commands, and how you can integrate this into your automation for to achieve, for example, continuous testing flows. We'll also show how Whirr uses jclouds for node management, and how you can easily add additional services using the underlying jclouds ComputeService interface.

En transparent GUI-prosess vil ikke bare forbedre resultatet, vil det mest sannsynlig øke effektiviteten og reduserer frustrasjon blant utviklerne. Slik involverte vi utviklere, arkitekter, produkteiere og brukere til å begynne å tegne.
Brukervennlighetserfaringer fra et smidig prosjekt: Hva gjør man når brukergrensesnittet ikke forankres godt nok, det er for mange uavklarte detaljer, fremdriften er for lav og kvaliteten for dårlig? Til tross for gode hensikter ble ikke designet av UI godt nok forankret hos prosjektdeltakerne. Det dukket opp for mange endringer i løpet av hver enkelt sprint som resulterte i lav utviklingsfart og mye frustrasjon blant utviklerne. Konsekvensen var at vi etablerte en åpen og mer formell GUI prosess. Vi inkludert et bredere spekter av prosjektdeltakerne og oppmuntret dem til å tegne, skisse, diskutere og kritisere ulike løsninger for brukergrensesnittet. Ved å gjøre det på denne måten distribuerer vi bedre eierskap og engasjement til skjermbildedesignet, og brukergrensesnittet blir både bedre forankret og spesifisert. Målet er å redusere frustrasjon blant designere (for ikke å vite hvilke behov som faktisk gjelder) blant utviklerne (for ikke å vite hva de skal utvikle), og blant prosjektledere, produkteiere etc. på grunn av dårlig fremdrift og lav kvalitet.

You think you knew refactoring ? Think again ! Years of programming and pairing teaches different approaches at how to solve the same problems. This talk is a code-oriented dive into hair-splitting differences that can make your day. It is not about keymaps, but about approaches for changing code. Experts and beginners alike will learn from this talk.
Using IntelliJ, the talk will give live demonstration of different approaches to the common refactoring operations. This will include deleting code, renaming code, introducing parameters, introducing variables, creating variables, inlining and selecting code. This is the stuff you don't pick up by casual messing around with the "refactor" menu, and is valuable for professionals with 10+ years experience as well as beginners. Everyone will learn something.

Puppet er fri programvare for å deklarativt styre konfigurasjon av servere, miljøer og infrastruktur. Vi går gjennom de sentrale konsepter innen infrastruktur som kode, hva Puppet er og hvordan det kan brukes til mer effektiv styring av infrastruktur.
Det er mye buzz rundt konfigurasjonsstyring i DevOps-sfæren. Puppet er fri programvare for å deklarativt styre konfigurasjon av servere, miljøer og infrastruktur. Vi går gjennom sentrale konsepter, Puppets arkitektur, infrastruktur som kode, automatisere oppsett og reproduserbar konfigurasjon av servere og applikasjoner, forbedret feilsøking og reduksjon av feilkilder; og ikke minst hvordan reproduserbar konfigurasjon av infrastruktur kan føre til mer effektiv styring. Etter foredraget vil du forhåpentligvis ha grunnlag nok til å starte prosessen for implementasjon konfigurasjonsstyring på ditt prosjekt. Foredraget er generelt og baserer seg på konkrete erfaringer fra bruk i store bedrifter og åpne nettløsninger.

TBD
Posten Norge lanserte Digipost våren 2011. I tiden etter dette har det blitt jobbet mye med ulike integrasjonsløsninger for bedrifter. Sist ut av løsningene er et flunkende nytt REST-API som ble lansert i august. I denne lyntalen ser vi på hvordan vi har designet og implementert en sikkerhetsmekanisme som lar API’et håndtere innhold med høyeste sikkerhetskrav. Vi ser også på hvordan denne sikkerhetsmekanismen lar seg implementere uten at det går på bekostning av prinsippene bak et RESTful design.

Join us on a journey that lands in advanced regex in Java. We start in the 1940s AI research, passing the 1970's Unix pioneers, and soon end up in pattern matching of text in modern programming languages like Java.
Join us on a journey that lands in advanced regex in Java. We start in the 1940s AI research, passing the 1970's Unix pioneers, and soon end up in pattern matching of text in modern programming languages like Java. Regex is the often forgotten super tool, that you can benefit from every day -- on the command line, in your code editor and in your programs. This introduction will teach you both the three compulsory operators and some more advanced concepts like lookaroands.

Creating and delivering technical presentations is not just the realm of conference speakers anymore. Let’s face it: if you have to give a technical presentation and it’s boring, you’re not going to make much of an impact.
Creating and delivering technical presentations is not just the realm of conference speakers anymore. Let’s face it: if you have to give a technical presentation and it’s boring, you’re not going to make much of an impact. However, if you can make it entertaining and informative, you sell your ideas much better. This session takes a different approach to how to build presentations, by providing patterns and anti-patterns you can use to make sure you’re getting the most leverage from your presentations. Don’t take a knife to a gunfight! The ability to create compelling presentations that explain your point is one of the things that keeps your job from disappearing.

Through code and demos you will learn how to deploy apps on Heroku, scale them, and manage them.
Heroku provides a Cloud Application Platform where app deployment is just a "git push" away. Through code and demos you will learn how to deploy apps on Heroku, scale them, and manage them.

Learn how to write highly concurrent, distributed and fault-tolerant systems on the JVM using Akka
We believe that one should never have to choose between productivity and scalability, which has been the case with traditional approaches to concurrency and distribution. The cause of that has been the wrong tools and the wrong layer of abstraction — and Akka is here to change that. Akka is using the Actors together with Software Transactional Memory (STM) to create a unified runtime and programming model for scaling both UP (utilizing multi-core processors) and OUT (utilizing the grid/cloud). Akka provides location and network transparency by abstracting away both these tangents of scalability by turning them into an operations and configuration task. This gives the Akka runtime freedom to do adaptive automatic load-balancing, cluster rebalancing, replication and partitioning. In this talk you will learn what Akka is and how it can be used to solve hard scalability problems. Akka is available at http://akka.io (under Apache 2 license).

All your well-known java-frameworks work with Scala. But not all of them work equally well. When it comes to database access, JPA is the prescribed choice in most java projects. But in Scala, it doesn't have to be, and it really doesn't work that well. This talk will take a look at database access using both raw JDBC, JPA and Scala-based frameworks in the form of Squeryl and ScalaQuery.
I Scala "funker" alle rammeverkene vi kjenner fra Java. Men ikke alle fungerer like bra, og vi mister en del på veien. I java-verden er det en "opplest og vedtatt sannhet" at man bruker JPA når man jobber mot en database. Men liker vi egentlig de begrensingene som JPA setter? Hva om vi vil ha mer kontroll på når - og hvordan SQL kjøres? Må vi virkelig bruke tekstlige spørringer som gir oss feil først i kjøretid? Hva om vi vil ha _mer_? Denne presentasjonen vil kikke på ulike måter å jobbe mot en database fra Scala, fra rå JDBC via JPA og JPA med scala-overbygg til rene Scalarammeverk i form av Squeryl og ScalaQuery.

Get rid of all your custom Junit runner the @Rule's are here
Sliter dere med å få rask feedback fra tester ? Har dere prøvd å kategorisere tester men endt opp med å flytte de vekk fra kildekoden de hører sammen med ? Rune vil med denne lyntalen bringe fokus på en ny funksjonalitet i Junit som gjør deg i stand til med enkle grep å kategorisere dine tester uten at det går på bekostning av ansvarsflytting, oppdeling av prosjekter eller massiv konfigurasjon i byggeskript

This presentation will cover the ongoing JVM convergence effort that is being undertaken by the Oracle JVM team to produce a combined JVM by taking the best features from HotSpot and JRockit. It wil include the grand vision of this effort, the current status, and what the near and long term milestones are.
As a result of the merge between Sun Microsystems and Oracle the combined company has got not one but two industrial-strength Java Virtual Machines (JVMs). What will Oracle's future JVM be like? Over the past few years HotSpot has released a number of new innovative features: NUMA-aware GC, string concatenation optimization, Garbage-First GC, SSE 4.2 support that is particularly useful in array data manipulations, effective escape analysis, etc. In the meantime JRockit is well known for its speed, innovative Deterministic GC, and impressive monitoring tools such as Mission Control, Flight Recorder, improved JMX agent, native memory tracking, etc. There were many possibilities considered for Oracle's future JVM. The path that was chosen should make happy both the existing as well as any new JVM users. Oracle has been assembling a single JVM taking the best features and characteristics from HotSpot and JRockit. The future converged JVM will have a source base derived from Hotspot but heavily enhanced with all the important and popular JRockit features: Mission Control and Flight Recorder support, native memory tracking, soft real-time GC, and many many more.

This talk will give you an idea of the effort needed to modernize your build to use the latest and greatest buildsystem. It highlights the problems and solutions found when introducing Gradle to your enterprise build.
Gradle er et fleksibelt og kraftig byggesystem hvor byggescript skrives i Groovy. Hvordan gjøre overgangen fra ditt gamle byggsystem så smidig som mulig? Vi har tatt i bruk Gradle som en erstatter for Maven. Dette foredraget tar for seg noen av utfordringene vi møtte ved å bytte ut Maven med Gradle, og hvordan vi løste disse. Foredraget tar også for seg det vi har erfart er de største styrkene og svakhetene ved Gradle. Vi vil også fokusere på hva vi som utviklere har vunnet på å ta i bruk Gradle.

Learn the benefits and pitfalls of JPA 2.0.
The release of the JPA 2.0 specification heralded a wider array of functionality and a more advanced feature set. This made some developers jump for joy at the prospect of being able to do more and still be compliant with the specification. The problem is that the standard doesn’t often come with a detailed instruction booklet describing when to use the new features, or the specific problems they were meant to solve. For the most part, developers must decide for themselves how and under what circumstances they will apply a given feature to their applications. We will discuss what the new features are and when they should be applied, as well as the conditions that could lead to their misuse. We will offer tips on what the most useful features are and explore some of the more puzzling parts.

This notion of sending messages has a strong synergy with actor based messaging. This session shows you how to model goal direction and task definition as small, manageable chunks of application functionality which are both far easier to reason about and far more convenient to scale compared to the mass of plumbing found in many enterprise applications.
Prototypical applications found in industry today are heavily orientated toward solving the relevant problem, with a UI that is designed for simply satisfying input to the domain objects; resulting in UIs that often leave the user with little specific information on what the primary intent of the display is. Goal-directed design however can greatly assist in these scenarios by placing the user experience in a central place during the inception of any given system. Goal-directed design is orientated toward capturing user intention and sending messages (or commands) back to the server, rather than mutated transformation objects (DTOs) that are simply persisted by the system, with little appreciation for what specifically changed or what the user was achieving. This notion of sending messages has a strong synergy with actor based messaging. This session shows you how to model goal direction and task definition as small, manageable chunks of application functionality which are both far easier to reason about and far more convenient to scale compared to the mass of plumbing found in many enterprise applications.

Charset encoding is an issue in most applications. If you work with strings, then you also have to understand charset encoding. Still, few software developers feel they understand charset encoding thoroughly. This talk aims to teach you charset encoding once and for all.
Tegnsettenkoding er noe du finner i alle lag av enhver applikasjon. Har du strenger, så har du enkoding. Hvis du ikke har kontroll på enkoding vil du ofte ende opp med rare tegn på websiden, databasen vil ikke sortere norske tegn rett, og du ender av og til opp med filer med en god blanding av enkodinger som føles umulig å nøste opp i uten å fikse alle de rare tegnene manuelt. Etter denne lyntalen skal du ha en god forståelse av tegnsettenkoding, slik at du ikke må strø "charset=utf-8" tilsynelatende tilfeldig utover kodebasen din i håp om å få rett sluttresultat.

Compare iOs and Android plattforms, communities, user experience for both developer and users.
Android eller iOs? En informert fremstilling av forskjeller og likheter mellom disse to plattformene. Hva passer deg best som sluttbruker? Hvilken plattform bør man utvikle for? Sesjonen vil være aktuell både for sluttbrukere og for utviklere.

Come and hear about the latest plans and developments for the future of the Jav platform.
Java SE 7 was launched officially on 28th of July this year; the first new version of the Java platform in nearly five years. Now that various issues have been resolved, Oracle are keen to maintain the momentum of Java as a platform. In this session we'll talk briefly about Java SE 7 before discussing some the changes being made to the JCP to provide a more transparent development of new Java specifications. We'll then talk about the planned features for Java SE 8 discussing modularity and lamba expressions as well as other ideas that are being proposed for inclusion.

In this talk we illustrate Groovy's DSL capabilities through numerous realistic examples. Throughout the talk, we will also tackle the often forgotten but key aspects of readability vs complexity, testability, evolution, and the various considerations to keep in mind while designing DSLs.
There have been many attempts to create languages which allow us to express our problems in higher-level languages: from COBOL to Object-Oriented languages, from Logic processing languages and SQL to rules engines. All have taken us forward in leaps and bounds but have failed to get very close to the language of the subject matter expert. This talk looks mostly at Groovy's features to see how far we have come with a general purpose programming language for writing DSLs.

We will take a look at client- and server-side RIA architectures from the security angle, identify some of the most common security problems and discuss strategies for avoiding them. We'll go through an example application implemented in both architectures and demonstrate the problems. Java-based RIA frameworks, Google Web Toolkit and Vaadin, are used in the examples.
Rich Internet Applications (RIA) provide desktop-like usability with web deployment model. The benefits of this combination are obvious and RIA is now common a choice for the presentation layer in many applications. Unfortunately, moving logic from the server to an untrusted client may open up security holes that would not be present in the page-oriented "Web 1.0" architecture. In this presentation we will take a look at client- and server-side RIA architectures from the security angle, identify some of the most common security problems and discuss strategies for avoiding them. We'll go through an example application implemented in both architectures and demonstrate the problems. Java-based RIA frameworks, Google Web Toolkit and Vaadin, are used in the examples, but the demonstrated principles are applicable to most other frameworks and languages as well.

Use DDD ideas and techniques to address really severe security vulnerabilities.
Since 2004 Injection Flaws and Cross-Site Scripting (XSS) has topped the OWASP Top Ten of most harmful vulnerabilities. Time to do something about it. In this code kata we address both Injection Flaw as well as XSS by applying techniques from Domain Driven Design - thus Domain Driven Security. In specific we use DDD context mapping to understand what the problem really is and DDD value objects to shape up our module APIs to make these vulnerabilities go away by enforcing indata validation and outdata encoding in a way that feels natural for the developers.

hardcore, java, physics
Ved å studere hvordan en kodebase endrer seg over tid kan man observere hvordan svake og sterke krefter beveger koden i bestemte retninger. Det er særlig summen av de små endringene som er interessante. Vi har studert et par kjente open-source prosjekter for å identifisere noen av de rådende kreftene. I denne sesjonen vil vi først introdusere konseptet "code entropy" for så å vurdere og diskutere tilstanden til sammenlignbare kodesnutter.

An introduction to MongoDB, the highly scalable document oriented database, with discussion various integration points for MongoDB & the JVM including Spring's "Spring Data" component for MongoDB, the Morphia Object Mapper for Java, MongoDB's Scala Driver "Casbah", Mongo-Backed Akka Durable Mailboxes, Lift's MongoDB Active- Record integration, and MongoDB's Hadoop integration.
MongoDB is a scalable, high-performance, open source, document-oriented NoSQL database. It features document-oriented, JSON-based document storage and dynamic schemas providing simplicity, power and flexibility, combined with full indexes similar to what a traditional RDBMS user would expect. MongoDB also provides solid replication & high availability features as well as an auto-sharding system for transparent horizontal scalability. This talk introduces MongoDB for developers who aren't familiar with it, and discusses various integration points for MongoDB & the JVM including Spring's "Spring Data" component for MongoDB, the Morphia Object Mapper for Java, MongoDB's Scala Drivers (Casbah, as well as a new experimental Asynchronous driver), Akka Durable Mailboxes, Lift's MongoDB Active-Record integration, and MongoDB's Hadoop integration.

Learn why JRuby is such a powerful tool for your toolkit, with demos of JVM tools, real concurrent threading, and the latest performance improvements. Thomas Enebo will demonstrate how to: use Java libraries, deploy a Rails app to any Java server (or run it with a lightweight Ruby-friendly server), and build applications.
With half a million Ruby developers worldwide, there’s no denying the success and speed of development this language provides. In this interactive session, Thomas Enebo, JRuby developer at Engine Yard, will present how to tap into Ruby to complement an existing investment in Java. It will offer attendees a deep-dive of JRuby, a Java implementation of the Ruby programming language, which allows organizations to build secure, high-performance application functionality with Ruby while utilizing existing Java code and the JVM. Learn how adding JRuby to your development environment will not only help you build applications faster but will also be a fun experience. Find out why Ruby and Rails are grabbing the attention of enterprise developers.

Come listen to the principles and technical practices that enabled the team delivering Digipost to incrementally deliver software of high quality and value into production whenever they want, and extremely fast. You can too!
Manifestet for smidig programvareutvikling sitt første prinsipp sier at; det å levere programvare av verdi kontinuerlig, er vår høyeste prioritet. Dette er ofte lettere sagt enn gjort, fordi det forutsetter masse hard jobbing med å komme frem til en infrastruktur og en prosess som støtter en rask flyt fra idé til produksjon. Jeg vil gi et innblikk i hvordan teamet som utvikler Digipost gradvis har utviklet evnen til å kontinuerlig levere programvare av høy kvalitet til produksjon når vi vil, og ekstremt raskt. Du vil også få vite hvilke fordeler dette gir, utover rask ledetid fra idé til produksjon, og hvorfor det er smidigere. Det er ganske sikkert flere grunner enn du tror.

Are you looking to learn a new programming language, but having a hard time deciding which language to choose. Come to my lightning talk and I'll give you tips I find useful.
Leter du etter et nytt programmeringspråk, men vet ikke helt hva du skal velge? Da er dette lyntalen for deg! I denne lyntalen vil jeg presentere det jeg mener er de viktigste kriteriene for å velge sitt neste språk. Overraskende nok er det ikke nødvendigvis Scala!

This talk will dive into some of the more remote regions of the kingdom of Scala. Specifically, we will cover topics such as higher kinds, programming at the type level, typeclasses and delimited continuations.
Scala is an intensely powerful language. One of the most obvious ways in which this manifests is the syntax, which is wonderfully amenable to internal DSLs and flexible APIs (not to mention endless reams of obfuscated sources and fanciful operators). However, despite the superficial flash of Scala’s syntactic skin, its true power lies in the type system and in the language’s deep semantic constructs. This talk will dive into some of the more remote regions of the kingdom of Scala. Specifically, we will cover the following topics: * Higher-Kinds (what they are and how they can be applied) * Type-Level Encodings (really exploiting Scala’s type system) * Typeclasses (just like Haskell...except not) * Delimited Continuations (and you thought kinds were confusing!) Please note that this is an advanced talk targeted at the Scala practitioner who is already fairly comfortable with the language. With that said, we hope the talk will remain reasonably accessible to the Scala beginner – so long as they don’t object to the presentation of odd and esoteric language features with disturbing enthusiasm.

Moving from Java to Scala sometimes feels scary. To make the transition a little bit easier it might help to keep some of the existing Java frameworks your company have experience in using. At least that is our theory when we chose to keep SpringMVC as web framework in my current Scala project. Time will tell if we are right or wrong in that theory :) But I did stumble upon a nice little side effect. That Scala could make Spring Java Config go from cool to great. In this lightning talk I will show how a Spring config could look in Scala, and how we could use Scala's features to create very readable and type safe Spring configuration.
Moving from Java to Scala sometimes feels scary. To make the transition a little bit easier it might help to keep some of the existing Java frameworks your company have experience in using. At least that is our theory when we chose to keep SpringMVC as web framework in my current Scala project. Time will tell if we are right or wrong in that theory :) But I did stumble upon a nice little side effect. That Scala could make Spring Java Config go from cool to great. In this lightning talk I will show how a Spring config could look in Scala, and how we could use Scala's features to create very readable and type safe Spring configuration.

På norsk
Mange systemer står i dag ovenfor store moderniseringsbehov. Gamle systemer hvor både dokumentasjon og kjennskap til språk er mangelvare. Denne presentasjonen vil ta for seg hvordan Tine har startet en stor modernisering av ett av kjernesystemene for rapportering av storfe-opplysninger. Det eksisterende systemet er et filbasert batch-system, skrevet i Cobol, som kjører inn opplysninger i databasen en gang om dagen. Målet er et system, skrevet i Java, som løpende oppdaterer og gir tilbakemeldinger. Men det å erstatte alt i en stor klump var et alternativ ingen likte. Vi vil vise hvordan vi har stykket opp problemstillingen, og klart å rulle ut deler av systemet som gradvis skal erstatte det gamle.

Cucumber-jvm is a rewrite of the JVM support. It is now written in a native Java-API, which compiles down to fast JVM bytecode. It enables many JVM capabilities and makes it even easier to integrate with your Java applications.
Cucumber-jvm is a rewrite of the JVM support. It is now written in a native Java-API, which compiles down to fast JVM bytecode. It enables many JVM capabilities and makes it even easier to integrate with your Java applications.

TBA
"Du bruker det feil!" - er kanskje en av de mest brukte, og minst nyttige forklaring på hvorfor akkurat du sliter med å få det skinnende nye rammeverket til å fungere i din applikasjon. Er det slik at det er vi som bruker rammeverket som er mindre begavet? eller er det utviklerene av rammeverkene som er det ? Skal vi være ærlige med oss selv så må vi vel inrømme at det ofte er en kombinasjon. Hva kan vi så gjøre for å redusere risikoen for å få problemer med rammeverkene vi bruker ? Svaret ligger i historien. Ved analyse av konsekvensene av tidligere valg, kan vi identifisere en del suksesskriterier og risiko oppførsel. Dette fordraget vil oppsummere hva jeg har konkludert etter å ha opparbeidet mye egen erfaring, samt det jeg har samlet av andres erfaringer i bruk av diverse rammeverk og verktøy.

This presentation consists of a series of animations that visualize the components in the java.util.concurrent library. If you’re still using constructs like Thread.start or wait/notify, you'll want to attend this meeting. The presentation is packaged as a self-executable JAR file and is available for download.
This presentation consists of a series of animations that visualize the functionality of the components in the java.util.concurrent library. Each animation features buttons that correspond to the method calls in that component. Each click of a button shows how the threads interact in real time. The animations are controlled by the actual Java concurrent component they are illustrating, so the animation is not only a visual demonstration, it's also a code sample. Key points covered will be - An explanation of the use case for each of 14 concurrent components. - Description of the design pattern handled by the component - How the concurrent component handles the use case - Visualization through animation of the use case. Components covered include - Executors (non-fair & fair) - Runnable/Callable - Semaphore - Future - Reentrant Lock - ReadWriteLock - Condition - BlockingQueue - CyclicBarrier - CountDownLatch - CompletionService - ConcurrentHashMap - Fork & join - Compare & Swap If you’re still using constructs like Thread.start or wait/notify, you'll want to attend this meeting. The presentation is packaged as a self-executable Java Archive (JAR) file and is available for download. It'll serve as a valuable reference for any Java practitioner.

* The problem we want to solve: ** FTP, password, install, setup, etc... * The anatomy of a Git repository ** What should you put in your repo, and what do you exclude ? ** How does the clients work ? * Other posibilities with this setup.
Git er etterhvert et kjent og kjært versjonskontrollsystem for mange, men mulighetene med Git er mange. Vi har tatt i bruk Git som repository for distribusjon av artefakter til en JBoss ESB server. Aldri mer overføring til FTP-servere, utpakking og konfigurasjon på andre siden som feiler, osv. - bare push og pull! Dette lar oss blant annet enkelt skille mellom release og distribusjon av endringer på ene siden og aktivering av disse på den andre, ved hjelp av spesialtilpassede server-scripts. Samtidig kan driftsansvarlige lett rulle tilbake til tidligere versjoner ved behov, da all historikk ligger lokalt.

A rewrite of a batch from C to Java and Spring Batch has seen execution time go from 1 week to 16 hours, this talk explains how.
I forbindelse med pensjonsreformen har Statens pensjonskasse (SPK) skrevet om batchen som reberegner alle ytelser i forbindelse med regulering av folketrygdens grunnbeløp. Den tidligere batchen var skrevet i C og brukte en uke på kjøringen. I denne presentasjonen vil jeg vise hvordan den nye versjonen skrevet med java og med Spring Batch gjør beregningen på godt under et døgn. I tillegg til Spring Batch står Hibernate og Jdbc sentralt i batchen, noe som fører til en del utfordringer. I jakten på bedre ytelse stod vi stadig fast i problemer knyttet til for eksempel deadlocks og retries, hibernate og misforstått feilhåndtering. Presentasjonen fokuserer først og fremst på endringene som ble gjort på javasiden, men vil også nevne endringer gjort på databasesiden for å bedre ytelsen. Det vil være en fordel for tilhørere om de har erfaring med Spring Batch og Hibernate, men ikke et absolutt krav.

Learn how Netflix moved its production services from being completely data center based, to being mostly cloud based in a little over a year. Find out what works and what doesn't in cloud migration, and how to get the best out of cloud services.
Netflix has moved its production services from being completely datacenter-based, to being primarily cloud-based in a little over a year. This talk will briefly explain why we did it and why we chose Amazon's AWS. The talk will then delve into the evolution of our build and deployment architecture, starting with how our orignal monolithic DC-based SQL-tied webapp was built and deployed, and then detailing the evolution of our continuous integration systems which helped prepare us for the cloud move. And finally, it will cover our current full build pipeline and deployment system which keeps us agile in the cloud now by providing quick turnaround, and rapid roll-out and recovery.

Enterprise Integration Architecture at the seriously large end of the scale, billions of messages, billions of £/?/$/NOK and very little of the fluffy stuff.
One hundred thousand messages per second, up-times measured in years, billions of dollars a day, operations in over 100 countries, hundreds of millions of users, that?s enterprise! Regardless of what you program in and at what scale you are going to come across some form of integration, at the simpler levels the frameworks take care of almost everything but as things get more complex old solutions can get cumbersome and new ones are needed, not restricted to Java but definitely Java-centric. John will walk you thing some of the existing problems and solutions in this area, starting with simple integration problems we come across every day to solutions attempted at some of the larger banks and why they failed and what worked. Finally some new ideas to think about.

learn how to get benefits far beyond simple regression testing from your tests
Most of the discussion on automated acceptance tests focuses on immediate benefits in development and defect detection or regression testing. But that's not nearly all you can get from your tests. While working on his new book, Gojko interviewed more than 50 teams that got big pay-offs from automated acceptance tests, including some that have been using agile acceptance testing for six or seven years. In the long term, most of these teams got quite unexpected benefits, such as being able to support their system easier, significantly change their business models or survive the absence of key business people. Gojko will talk about these long term benefits of acceptance tests and what you need to do to get them.

The major trends in computing and how Java is evolving with them. Or not !
In the context of a number of high profile additions to the choices of programming language in the developers arsenal, some recent surveys have seen the Java language's lead over other languages erode in recent years. In addition, the days of the rapid buildout of the platform APIs is over. How will Java avoid the fate of becoming the Cobol of the 20-teens ? What trends in hardware and systems technology is being factored into the ongoing evolution of the Java platform to stave off its untimely death ? What are the key technologies that are going to keep Java at the top of the heap for the next 25 years ? In this session, we will take a look at the major trends in application and systems development, such as multiple languages, parallel programming, application frameworks, and see successfully Java is staying ahead of the curve.

Java posse recording or meet and greet. We will do something fun.
This year Dick Wall and Carl Quinn of the Java Posse podcast will visit JavaZone. They will do a Java Posse recording during the last slot on Wednesday, just before AweZone. The session will cover the top topics and questions suggested at their webpage. Be early – there’s refreshing liquid surprises to the first 300+ attendees!

Reducing the deployment cycle introduces fundamental changes in what constitutes effective software development. This talk sketches the changes from quarterly to monthly, then weekly, daily, and hourly deployment.

Last fall we decided after much consideration to use apache camel in some of our (new) products. We would like to tell a bit about why, how, and especially what we have learned from implementing real systems with camel. Camel is an integration framework based on enterprise integration patterns. Camel has a java DSL and a simple spring-integration that makes it very easy to get started with, and easy to implement relatively complex integration solutions. But what happens when you attack real problems that do not fit as well with the mickey-mouse-examples in camel tutorials, or when you need real infrastructure and can not tolerate data loss during a power failure? What about performance and memory usage? Testing? What works well, what does not work so well? etc. ..
I fjor høst bestemte vi oss etter mye vurdering å bruke apache camel i noen av våre (nye) produkter. Vi vil gjerne fortelle litt om hvorfor, hvordan og ikke minst hva vi har lært av å implementere reelle systemer med camel. Camel er et integrasjonsrammeverk basert på enterprise integration patterns. Camel har en java DSL og en enkel spring integrasjon. Camel gir svært mye kraft i lite kode, det gjør det lett å implementere enkle og kompliserte integrasjonsløsninger, men det gjør det også lett å gjøre betydelige feil som kan koste deg dyrt. Hva skjer når du skal angripe reelle problemer som ikke passer like godt med mikkemuseksemplene i camel tutorials, eller når du trenger ekte infrastruktur og ikke tåler at data mistes ved en strømstans? Hva med transaksjoner, asynkronitet og tråder, ytelse og minnebruk? Vi vil bruke en problemløsende fremgangsmåte med delvis live koding for å presentere integrasjonsrammeverket Camel brukt i reelle problemstillinger, samt gi en inføring i enterprise utvikling og integrasjon. Presentasjonen bygges naturlig opp gjennom å utvikle et konkret eksempelsystem hvor vi starter enkelt og gradvis kommer innom flere vanskelige problemer underveis.

If you're like most projects these days, you probably use Spring, Guice or another dependency framework. But how many dependencies do you really have? By exploiting the fact that you probably only have a very few number of real dependencies in your project, you can greatly simplify your application.
If you're like most projects these days, you probably use Spring, Guice or another dependency framework. But how many dependencies do you really have? By exploiting the fact that you probably only have a very few number of real dependencies in your project, you can greatly simplify your application.

Spring's been the leader in the enterprise Java technology space for years, but relatively little is known about the deep, powerful features in the core framework that go beyond the normal scenarios. Increasingly, people consume Spring through the frameworks that build on top of it - including Spring MVC, Roo, and Integration. This power and flexibility is not reserved just for other Spring frameworks, however. In this talk, we'll explore some of the more powerful, but less well-known, techniques in the core Spring framework.
The Spring framework has served people well for years, but few have exploited the incredible power of the framework's core IoC support and component model, including the Java-only configuration model, the annotation support, the native support for JSR's 250 and 330, and the incredible AOP and meta-framework support that the other Spring frameworks - Spring Batch, MVC, Integration - etc., all exploit. This talk introduces viewers to the powerful technologies including in the core Spring framework that can be used to meet any challenge - from component-level use cases to low-level framework-building scenarios.

Arquillian is the in-container test framework led by JBoss that is redefining the testing landscape in Java EE. It not only simplifies the task of writing tests, but it provides a tool for exploring the behavior of the Java EE programming models and deployment mechanisms. In some cases you'll use test cases to ensure proper interaction between client and server, others to verify portable behavior across compliant containers and countless more to assert the features of various technologies. We'll spend only a brief amount of time on theory and goals of Arquillian. Then we'll showcase recent additions to Arquillian's capabilities, inviting you to think of ways Arquillian can be useful to your application's test suite or your personal discovery process.
In this session, we'll address the missing link in Enterprise Java development: simple, easy integration testing. Unit tests and mock objects will only take you so far; the only answer which truly ensures that all components are playing nicely is a comprehensive integration suite. Unfortunately, writing integration tests has historically involved manual setup of a heavy, cumbersome test harness. That's time lost, but it doesn't have to be anymore. Here we'll introduce Arquillian, a powerful container-oriented testing framework layered atop TestNG and JUnit. Arquillian manages your runtime, abstracting out deployment and allowing you to focus on real test logic. We'll cover: * Transparent container lifecycle management * Declarative deployments * Test Enrichment (Dependency injection intotests) * In-container test execution Attend this talk to learn how the simplified component model of Java EE can be applied to testable development.

Do you think event handling is boring and that asynchronous programming can be error-prone? Reactive programming is here to help.
As programming is more and more based on events and asynchronous calls, the limitations of the observer pattern are becoming obvious. Reactive programming solves this by operating on streams of events rather than the events themselves. Frameworks for reactive programming in functional programming languages have existed for some time, but Reactive Extensions (Rx) from Microsoft marks a breakthrough for this paradigm in imperative languages. Reactive programming has also become popular in Scala. This is a practical introduction to reactive programming. Currently, this paradigm is less convenient in Java than in Scala or C#, but when Java gets lambda expressions (closures) this will improve a lot...

On a greenfield project, rapid deployments to production is an achievable goal. Learn how to deploy rapidly on your maintenance projects too – during normal working hours!
Hvis du starter med blanke ark, er hyppige produksjonssettinger greit å få til. Men hva om applikasjonen har vært i produksjon en stund, og muligheten til å gjøre endringer er begrenset? Denne lyntalen tar for seg noen enkle grep du kan gjøre i ditt prosjekt for å komme nærmere visjonen om kontinuerlig leveranse. Det handler ikke bare om automatisering, men også hvordan du ved å tenke gjennom hvordan applikasjonen brukes kan gjøre det mulig å endre den uten å påvirke brukerne. Resultatet er hyppigere og tryggere produksjonssettinger – i vanlig arbeidstid!

New Java developers consider providing an implementation of the "equals" method for a given class to be nothing but trivial... until eventually they read "Effective Java" and realize for non-trivial cases of classes with multiple inheritance it is considered impossible. Complexity abounds in all that we do in software development... choosing a language, choosing a framework, developing the architecture of the system. For most development shows this topic of complexity is never even discussed... resulting in accidental complexity. For a software project to survive long term, fighting complexity is a constant battle. Complexity must be understood and carefully designed.
Of all the non-functional requirements of software development, complexity receives the least attention and seems to be the most important from a long term standard point. This talk will look at some of forces that drive complexity at the code level and at a system level and their impact. We will discuss what causes us to over look complexity, how our perception of it changes over time and what we can do about it?

We show a simple standard problem in Java - how to sort a list? - and how this can be made much more concise and easier to read using the new language features in Java 8.
Vi gjennomgår et enkelt standardproblem i Java - hvordan sortere en liste? - og ser hvordan vi kan gjøre det mye mer konsist og lettere å lese via de nye språkmekanismene som kommer i Java 8.

This talk summarizes our experience introducing Drools as rule engine in a large project. We experienced time consuming coding with no IDE support, a scriptlanguage that nobody really mastered, and poor debugging ability. What not to do again. 
Vi innførte Drools for å erstatte en "hjemmesnekret" regelmotor. Motivasjonen for å ta i bruk en regelmotor var time2marked, gjøre det enklere å skrive forretningslogikk, erstatte  hjemmelaget med kommersiell tredjeparts-kode, og et ønske om å kunne bruke reglene på tvers av produktsystemene. I dette lynforedraget går jeg igjennom våre erfaringer med  innføring av Drools i et prosjekt.  Jeg snakker også om hvorfor vi  til slutt valgte å gå helt bort ifra regelmotorer og hva vi gjør nå.

This presentation covers three case studies where traditional RDBMS approaches had been taken, and ultimately abandoned in favor of NoSQL document databases and massive, fast-access storage mechanisms. The presentation covers Java, mongoDB, HBase, GridFS, and HDFS, and provides insights into how each of of the applications were designed, deployed, refactored, and launched in production.
Not-only-SQL systems can be applied in a large number of problem domains. In general, it's safe to say that NoSQL is a contender against traditional RDBMSs if data storage and retrieval needs aren't transactional. This presentation covers three case studies where traditional RDBMS approaches had been taken, and ultimately abandoned in favor of NoSQL document databases and massive, fast-access storage mechanisms. The presentation covers Java, mongoDB, HBase, GridFS, and HDFS, and provides insights into how each of of the applications were designed, deployed, refactored, and launched in production.

Software projects have traditionally been reasonably successful at focusing on quality for its end users. But there are several known and unknown stakeholders in any software project. How do you ensure that you deliver quality to all of your stakeholders? And is it even possible?
Systemutviklingsprosjekter har tradisjonelt vært flinke til å fokusere på, og levere, kvalitet til sluttbrukeren. De siste årene er det i tillegg blitt et økt fokus på hva driftspersonell ønsker fra et system. Men sluttbrukere og driftere er ikke de eneste interessentene som har en oppfatning av hva kvalitet er. Det finnes overraskende mange interessenter i et systemutviklingsprosjekt og de har alle hver sin oppfatning av kvalitet. Hvordan kan man sikre at du selv, alle interessenter og organisasjonen som helhet blir fornøyd med det du har vært med på å lage?

Cassandra is a scalable, highly available, column-oriented data store that has become a key player in a growing number of web-scale operations. It offers a compelling combination of a rich data model, a robust deployment track record, and an architecture that is as elegant as it is sound. Get to know NoSQL better by studying this leading solution.
Want to go deep on a popular NoSQL database? Cassandra is a scalable, highly available, column-oriented data store in use at Facebook, Twitter, Reddit, Rackspace, and other web-scale operations. It offers a compelling combination of a rich data model, a robust deployment track record, and a sound architecture. Get to know NoSQL better by studying this leading solution. In this session, we'll talk about Cassandra's data model, work through its API in Java and Groovy, talk about how to deploy it, and look at use cases in which it is an appropriate data storage solution. We'll study its origins in the Amazon Dynamo project and Google's BigTable, and learn how its architecture helps us achieve the gold standard of scalability: horizontal scalability on commodity hardware. You'll leave prepared to begin experimenting with Cassandra immediately and planning its adoption in your next project.

Learn how to seduce your colleagues over to the Git side by offering them a Subversion-friendly, backward-compatible infrastructure. No slides, only hard-core command line action! We'll go through the basics of git-svn, through centralized Git-SVN mirror, to the final migration away from SVN.
Our company Subversion repository recently rounded 100.000 revisions. Our main product now counts over 50.000 files, in a workspace of several gigabytes. The pains of tending to a project of this size is made worse by Subversion. Updates and commits take a long while, working with branches is unbearable, and the workspace itself is immensely slowed down by the thousands of miniscule .svn folders powdered around in each directory. At the same time, we haven't been able to make the switch to Git, for the same reason as many others: Lack of tooling, Windows-friendliness, learning curve - these are all excuses that can and will be overcome, some day. But for now, we had to come up with something different.. We decided that those of us who want to make the switch to distributed SCM should not have to wait for it. For over a year, more and more of the development team have joined in on doing SCM via our Git-SVN mirror. Setting up this kind of infrastructure is not trivial, but in this talk I’ll guide you through all the steps, as well as a few more you should make when you finally want to leave SVN behind. This talk is slide free! Be prepared for a lot of command-line action!

Discussion about the SQL and non-SQL debate, unveiling facts and speculation.
The “no-SQL” movement seems to be growing in popularity worldwide; especially as cloud computing is becoming more widespread. It seems that many developers believe we are facing a paradigm change in respect to how we store the information from our applications. But it is quite clear that the opportunities and consequences are not quite clear for everyone as this topic is becoming more hyped up. So what is the deal about “no-SQL”? First of all, we need to understand what a database is, and what kind of services the database provides us with. Also we need to apply lessons from history to many of the claims regarding non-SQL databases such as; you don’t need a schema when you’re not using SQL. But is this true? In this short presentation we will analyze what a database actually is and put this up towards various claims, facts and speculation surrounding the SQL/no-SQL debate

Learn why Apache Camel can make integration much easier using EIP patterns in its intuitive DSL allowing you to build integration flows in "lego style". See how flexible Camel is, allowing you to embed and run Camel in many containers ranging from standalone, web apps such as Tomcat, JEE such as JBoss, and OSGi containers. Hear about the importance of a thriving community and hear about other popular Open Source projects using Camel out of the box. See live code and examples and how you can quickly get up and running Apache Camel using Maven or Eclipse tooling.
Apache Camel, a very popular integration framework, builds on the principles of the EIPs (Enterprise Integration Patterns) and DSLs (Domain Specific Language). In this talk we show how integration can become much easier and accessible with Apache Camel. By wiring together EIP patterns, processes and transports, integrating becomes as simple as building routes "lego style.", The wiring is done using the Camel DSL. This talk includes live demos that show how to get started with Camel and build integration flows in the four DSLs: plain Java, XML, Groovy and Scala. We will also show you how you can use Eclipse tooling to build routes using a graphical drag'n'drop environment. This talk also describes the options available for running Camel, such as embedding Camel into an existing environment. As well as running Camel with OSGi. After this we shift focus to cover the Camel community showing the rising popularity of Apache Camel. As well as briefly touching other open source projects which leverage Apache Camel in any way.

As do most Java developers, you probably use a code coverage tool like Cobertura, Emma or Clover. But have you ever wondered know how these tools are implemented? This presentation will investigate how these tools work. You'll learn the basics of byte code analysis and transformation, enough to get you started developing your own code coverage tool. We'll also look into why code coverage alone is not a good metric, and how mutation testing can help us write more relevant tests.
De fleste Javautviklere bruker i dag et testdekningsverktøy av typen Cobertura, Emma eller Clover. Men har du noen gang lurt på hvordan slike verktøy er laget? I dette foredraget løfter vi på panseret og viser hvordan kodedekning er implementert. Måling av kodedekning er nemlig ikke er så avansert som du kanskje tror. Med litt kunnskap om bytekodeformat, bytekodeanalyse og transformasjon har vi byggeklossene vi trenger for å lage et enkelt verktøy for analyse av kodedekning. Foredraget viser to eksempler på slike verktøy laget av foredragsholderen, men gir deg også nok kunnskap til at du kan lage ditt eget. Vi viser også hvorfor testdekning i seg selv er en lite meningsfull metrikk og hvordan mutasjonstesting kan hjelpe oss å lage mer relevant tester.

• defining architecture ‘properly’: even the ‘standards’ are ‘wrong’ • what is ‘bad’ architecture • real architecture responsibilities – who does what to whom • the technical disciplines we need; quantification, estimation measurement – of multiple qualities and costs • architectural decomposition: a value basis • software design, the same process, a different level • the role of iterative feedback in verifying architecture • The Architecture Manifesto: (advice for the revolution
What should software architecture be? How is it related to major critical software qualities and performance, to costs and constraints? How do we decide exactly what to propose, and how do we estimate and prove it is justified. How can an organization qualify their own architects, and know the difference between the frauds and the experts? Would ‘real’ architects recognize what software architects know and do? We believe that most activity, going under the name architecture, is NOT – ‘fail’. Current ‘Software achitecture’ is no more real ‘architecture’ than ‘hackers’ are ‘software engineers’. If we are just informally throwing out nice ideas, let us call ourselves ‘Software Brainstormers’. But if we are dealing with large scale, serious, and critical systems, then we need to stop using cabin-building methods and start using skyscraper designing methods – we need a serious architecture and engineering approach.

Want to improve your developer testing skills? This presentation will explain how to analyze a given problem and evaluate different approaches for writing automated tests.
"Enhetstester er lett. Integrasjonstester er vanskelig." er en vanlig holdning blant norske utviklere. Det reelle problemet er egentlig ikke hvorvidt man tester enheter eller integrasjoner, men at mange utviklere ikke har peiling på hvordan de skal gå frem for å skrive skikkelige tester. Erfaringsmessig har det vist seg viktigere å bygge kompetanse på problemanalyse enn å pugge konkrete oppskrifter. Fremgangsmåte og prioriteringene som må gjøres for å skrive gode tester står derfor i sentrum, men også teknologi- og verktøyalternativer vil bli diskutert. Foredraget vil være case-orientert, med utgangspunkt i testing av et større logistikksystem.

TBA
Kontinuerlige leveranser er i vinden om dagen. Alle skal levere til produksjon hver uke, gammel funksjonalitet skal fortsette å virke, samtidig som ny funksjonalietet kommer på løpende bånd. Men hva krever dette av test? Hvordan kan vi være sikre på at alt fremdeles fungerer, samt at alt skalerer og er sikkert nok? Er en håndfull automatiserte funksjonelle tester nok? Prosjektet vi jobber i har siden januar levert ny funksjonalitet, kanskje ikke hver uke, men så snart noe er ferdig utviklet. Presentasjonen viser hva vi synes er riktig nivå av testing, hvordan vi har kommet frem til dette, og hvordan prosessen vår støtter opp om kontinuerlig testing. Vi viser hvordan vi har håndtert tradisjonelt sett tunge ting som avbruddstesting, ytelse/stress/kapasitetstest, sikkerhetstest, og hvordan vi fortsetter å håndtere det for hver nye leveranse.

Java, IPv6
IPv4 er på overtid, og IPv6 kommer for fullt. Den 8. juni 2011 hadde Google, Facebook og en rekke andre store internettaktører en 24-timers testflight på IPv6, og det er all grunn til å tro at også Javaprogrammerere vil komme til å få stadig mer kontakt med IPv6 i hverdagen. Java skal i prinsippet støtte IPv6, men etter å ha jobbet på et prosjekt hvor det var et krav at IPv6 skulle støttes, så jeg at det ikke alltid stemmer. Enhver som antar at "it just works", vil fort kunne få en overraskelse. Jeg vil presentere hva jeg lærte.

Find out how Spring Framework is evolving to support 'NoSQL' databases (such as Redis, Riak, Mongo or Neo4j) by bringing traditional Spring values such as portability, productivity and a unified POJO based programming model to this style of data access.
The needs of many enterprises have stretched traditional RDBMS based solutions to the breaking point and as a result, a plethora of new non-relational storage options have appeared: key-value stores, column storages, document and graph databases. This talk will show how the Spring Framework is evolving to support 'NoSQL' databases by bringing traditional Spring values such as portability, productivity and a unified POJO based programming model to this style of data access. During the presentation, the main features of Spring Data will be discussed by taking a tour of the various offerings out there such as Redis, Mongo and Neo4J just to name a few. Basic NoSQL knowledge is required.

For the last few years, the web has been all a-twitter about web 2.0 (and even the occasional reference to web 3.0.) Yes, the days of static web applications are officially over and while libraries like jQuery and Prototype make it easier to build modern applications, ultimately they are papering over issues in the web standards (and the browsers that implement them.) Today we're building to standards that are from the paleolithic era of web design but that's changing - and HTML 5 is a large part of that. In this talk, we'll discus just what HTML 5 is and why it matters. We'll show how you can build to HTML 5 today and which browsers support what. Thankfully, after many years of stagnation, the future of web applications looks bright!

For any code base there comes a time when you want to change it. But if you just steam ahead making changes that break the code and then fixing errors, a common situation is that every fix or change creates several more errors. It feels as if you have picked a fight with the Software Hydra - for every scary head you cut off, two more grows out! Instead, come learn The Mikado Method (http://mikadomethod.wordpress.com/book), a systematic approach to beat the Hydra and change the code in a safe way.
For any code base there comes a time when you want to change it. But if you just steam ahead making changes that break the code and then fixing errors, a common situation is that every fix or change creates several more errors. It feels as if you have picked a fight with a beast, the Software Hydra - for every scary head you cut of, two more grows out! Instead, come learn The Mikado Method (http://mikadomethod.wordpress.com), a systematic approach to beat the Hydra and change the code in a safe way. The method helps you visualize, prepare and perform business-value-focused changes while delivering continuously, and without having a broken code-base in the process. It enhances team communication, collaboration and learning, and helps individuals stay on track.

This experience report describes the rather extraordinary technical architecture of Oslo municipal's integration platform. It consists of no ESB-product, no application server, only Apache HTTP-server, several Java and spring-containers and ActiveMQs as a message broker.
I en av norges største bedrifter, Oslo kommune, blir tjenestene og plattformen etablert etter hvert som behovene oppstår, noe som har resultert i en omfattende tjenesteorientert arkitektur uten et konkret ESB-produkt. Tjenestene kjører uten applikasjonsserver, kun på Apache HTTP-servere, mange Java- og spring-containere og ActiveMQ som meldingsbærer. Dette erfaringsforedraget beskriver den tekniske arkitekturen, og gir en rask oversikt over hvordan nye integrasjoner implementeres. Du får også vite hvordan deployment, lastbalansering, overvåkning og organisering av tjenester foregår.

# Experience report from using PaaS on several projects. # An overview of the services you can find in the cloud and how they perform. # A simple howto into how you can use the different services.
Utvikling skaper verdi, hvorfor kommer driftsoppgaver i veien for at du kan gjøre nok av det? Dette er en praktisk presentasjon av våre erfaringer med utvikling, utrulling, forvaltning og drift av 3 applikasjoner i skyen. Ikke noe salg kun våre egne erfaringer. I denne presentasjonen kommer jeg til å gå gjennom prosessen fra valget av skyleverandør, gjennom utvikling, første utrulling, forvaltning og drift applikasjonene. Jeg kommer til å sette de forskjellige leverandørene opp mot hverandre på egenskaper som utrulling, skalering av ytelse, økonomi, åpenhet/innsyn og monitorereing. Jeg kommer så med våre erfaring med å leve i og utvikle for skyen. Erfaringene kommer fra 3 ruby on rails applikasjoner. Erfaringene er generelle innenfor bruk av PaaS og er lett overførbare til WAR og Jvm. Presentasjonen avsluttes med en introduksjon til hvordan du kan flytte inn i skyen og leve der. Dette gjøres gjennom en introduksjon til WAR-formatet og hvorfor dette er en styrke for Jvm og Java. Når man nå har en WAR ønsker jeg å vise hvordan de forskjellige leverandørene lar deg rulle denne ut på deres tjenester. Dette er en rask introduksjon på hvordan komme igang i skyen. Har du en WAR kan skyen kjøren den!

Continous delivery best practices

Distributed Computing, Architecture, design, Cloud Computing, resilient systems
In 1994 Peter Deutsch (Sun Microsystems) published the first 7 Fallacies of Distributed Computing. In 2009 Tim Bray published a discussion about how these fallacies apply to the Web. In this talk, I'll attempt to continue this discussion in terms of Cloud Computing, recently made relevant by the long Amazon AWS failure. The talk will also provide example Cloud architectures (exemplified by a set of AWS services) to discuss the different fallacies so the audience will know how to build resilient systems.

Object Mother and Builder patterns can help you write better tests. Reduce size of tests, improve reuse and simplify refactoring.
Å skrive tester har blitt nesten like viktig som å skrive selve produksjonskoden. Etter hvert som systemene blir større er det en tendens til at det blir mer og mer komplisert å skrive tester for koden. For å kunne teste spesifikke deler av koden så må systemet ofte settes i en riktig tilstand, og dette kan kreve mye “boiler-plate”-kode i testene. Jeg vil i denne lyntalen gå igjennom to patterns som jeg bruker for å forenkle måten vi skriver tester på, mer spesifikt hvordan vi oppretter domene-objekter. Disse er Object Mother og Builder. Ved å bruke disse får du økt gjenbruk, mindre testklasser, det blir enklere å gjøre endringer i koden og du får enhetlige testdata i testene dine.

Tasked with a major upgrade for a mission critical authentication and authorization server, how do we balance the need for incompatible changes with the needs for the 50 or so clients? This is an experience report from such an upgrade in a major Norwegian financial institution.
I et serverrom i en større norsk virksomhet har et sett med tjenester kjørt stabilt i 9 år, og sørget for bl.a. autentiserring, autorisasjon og single sign-on for både kunder og ansatte. Dette systemet har nærmere 50 klienter, og klient-API'en har vært bakover-kompatibel de siste 7 årene. Innenfor slike rammer er ikke endringer enkelt å få til, men nå tar vi sats for å revitalisere denne platformen og kommer med en oppgradert API og en solid utrensking på server-siden. Med så mange berørte parter må vi tenke nøye gjennom hva slags endringer vi gjør, men også hvordan vi kan lage rammer som gir både en stabil API og mulighet for endring de neste årene. Dette foredraget oppsummerer de erfaringene vi har gjort oss, hva slags typer endringer som ble gjort i gammel API og hvorfor.

Explore the Dependency Injection approaches available to Scala developers, and introduce a new open-source dependency injection Scala library with code examples and recipes.
This session will explore the dependency injection options available to developers using Scala. It will cover several options including Java frameworks like Spring and Guice, and Scala language approaches such as the Cake pattern. Along the way, the pros and cons of each option will be discussed, for example Guice provides a nice binding DSL, but also relies on annotations and factories, leaving a non-Scala taste in your mouth when using it. Meanwhile the Cake pattern is all Scala, but self types can be confusing for people new to Scala, as can any kind of guidance for binding injections to variables. The culmination of the talk will focus on a new open source library for dependency injection which has been developed for Scala in a real world application setting, based on picking the best of the Java and Scala approaches. The talk will be technical in nature, with plenty of code examples and a cookbook of recipes for different dependency injection usages.

The domain is the essential part of your application. It is important that you get a good understanding of what your domain is about. By using value objects, instead of just String, Integer and Boolean, you get to know your domain better. In addition, you will get code that is easier to read, easier to test and self documented.
Å ha en god forståelse for forretningsdomenet en jobber med er essensielt i forhold til å greie og levere gode løsninger for kunden. Som en byggekloss i domenet ditt, kan du benytte verdiobjekter. Det gir deg en rekke fordeler, både når det gjelder det funksjonelle (forståelsen av domenet) og det tekniske. Dessverre virker det som om få vet hva et verdiobjekt er, og ser mulighetene de gir. Jeg vil i min presentasjon gi en kort introduksjon til hva et verdiobjekt er, og deretter bruke resten av tiden til å overbevise deg om hvorfor du bør sjekke ut verdiobjektet nærmere.

Clojure arguably has the most deeply thought through way of handling of state on the JVM, and because of this it is hard to do concurrency wrong in this language. This talk will show the concepts which make Clojure a "muti-core ready" language.
Denne presentasjonen vil gi deg innsikt i hvordan Clojure som programmeringsspråk håndterer tilstand. Dette gjøres på en helt annnen måte enn hva vi er vant til fra objektorienterte språk. Ved å utvikle programmer på denne måten blir samtidighet og parallellitet mindre problematisk. Presentasjonen vil introdusere Clojure som språk. I tillegg vil vil det tydelig defineres Clojures syn på verdier, tilstand, identitet og tid. Clojure's innebygde typer og datastrukturer gjør det mulig å se verden på en enklere og bedre måte.

See how you can add caching to your Java app in 10 minutes with Spring 3.1: no intros, no fluff, just the essentials!
Quick overview of the new caching abstraction added in Spring 3.1

The lightning talk will discuss the challenges and opportunities when implementing different push solutions for the Android platform. it will also elaborate on experiences with different implementations, and why you should or should not use them.
Informasjon levert på sekundet er noe brukere forventer i større grad enn før. På mobile enheter løses dette gjennom push-teknologi. Det er flere mulige måter å implementere pushteknologi til Android-plattformen, fra helt hjemmesnekra kommunikasjon over protokoller som XMPP og MQTT, til tredjepartsløsninger og Googles egen push-løsning C2DM. Lyntalen vil gi en konsis oversikt over muligheter som ligger i de ulike implementasjonene, hvordan de fungerer, og hva de egner seg til.

Covers the benefits and drawbacks of NoSQL database Compares and contrasts popular NoSQL databases – Redis, MongoDB, and Cassandra. Describes how the Spring Data project simplifies the development of Java applications that use NoSQL databases.
Relational databases have long been considered the one true way to persist enterprise data. But today, NoSQL databases are emerging as a viable alternative for many applications. They can simplify the persistence of complex data models and offer significantly better scalability, and performance. But using NoSQL databases is very different than the ACID/SQL/JDBC/JPA world that we have become accustomed to. They have different and unfamiliar APIs and a very different and usually limited transaction model. In this presentation, we describe some popular NoSQL databases – Redis, MongoDB, and Cassandra. We will compare and contrast each database’s data model and Java API using NoSQL versions of a use case from the book POJOs in Action. We describe the benefits and drawbacks with using NoSQL databases. Finally, you will learn how the Spring Data project simplifies the development of Java applications that use NoSQL databases.

Learn when to use the new fork-join framework in Java SE 7 (and when not to).
The reality of today's chip architectures s that rather than seeing ever increasing clock speeds we now see ever increasing core counts. This has a significant impact on how we write efficient code since we now need to design for parallel operations to get the best from our hardware. Concurrent programming is hard to get right, especially when faced with early Java support in the form of the sleep, interrupt, wait and notify methods along with synchronised blocks and methods with a single monitor per object. Java SE 5 started the process of enhancing Java's support for parallel programming with the concurrency APIs. Java SE 7 includes the latest revisions to this in the form of the fork-join framework (also known as JSR-166y). This session will look at how the fork-join framework can greatly simplify the code required to process a set of tasks that can be distributed among a number of parallel processing units. We'll look at some good examples for effective use of the framework as well as one that is not suited and provide some hints on what to do in this case.

Debunking common JavaScript myths and showing you how to properly code client-side JavaScript.
JavaScript is in an unfortunate position. Everywhere, people spread bad, misinformed advice about the language and how to apply it to browser scripting/web applications. We'll debunk some common myths about JavaScript programming and learn more suitable alternatives. Expect to gain insight in what makes JavaScript such a unique and beautiful programming language and learn how to better your client-side code.

Basefarm has developed their new core system in Scala using a technology stack that developers will recognise from a regular Java project. In this talk I will discuss our experiences with Scala, with an emphasis on how Scala works with the good old Java frameworks.
Vi i Basefarm startet i 2010 å utvikle vårt nye fagsystem. Etter å ha vurdert flere programmeringsspråk falt valget på Scala. Vi valgte Scala blant annet fordi Scala er typesikkert og vi må skrive mye mindre boilerplate-kode enn i Java, samtidig som man kan dra nytte av de tallrike og velutprøvde Java-bibliotekene som allerede finnes. Av rammeverk endte vi opp med Hibernate, Spring og Spring MVC, som alle Java-programmerere er kjent med. I tillegg bruker vi Akka, som er et Scala-bibliotek som hjelper oss å håndtere concurrency, bl.a. ved hjelp av actors. Vi fant raskt ut at selv om det fungerer bra å bruke Java-rammeverkene fra Scala, så kan det oppleves som en skikkelig kulturkrasj fordi Scala gjerne lener seg mer mot funksjonell programmering enn Java. I dette foredraget får du et innblikk i hvordan det fungerer å bruke Scala og Java sammen, hvilke fordeler det gir oss å bruke Scala, hvilke hindre vi har møtt på og hva vi ville gjort annerledes dersom vi skulle gjort dette om igjen.

på norsk.. så da skal ikke denne skrives?
Jee6 har gitt nye muligheter som ikke tidligere har vært mulig. Man kan redusere antall rammeverk da mer er integrert i Java. Feks Spring. Hvor mye kan man presse ut av jee6 før nye rammeverk må inn? Hvordan har det vært å jobbe med Jee6. Det gir også en del intressante utfordringer og det kommer sansynligvis flere av dem. Jeg ønsker å dele mine erfaringer med bruk av Jee6 gjennom et års utviklingsprosjekt på Skatteetaten.

Akka is a unified runtime and programming model for scaling both UP (utilizing multi-core processors) and OUT (utilizing the grid/cloud). With Akka 2 this will be taken to a whole new level with its “Distributed by Design”
We believe that one should never have to choose between productivity and scalability, which has been the case with traditional approaches to concurrency and distribution. The cause of that has been the wrong tools and the wrong layer of abstraction and Akka is here to change that. Akka is a unified runtime and programming model for scaling both UP (utilizing multi-core processors) and OUT (utilizing the grid/cloud). With Akka 2 this will be taken to a whole new level with its “Distributed by Design”. Akka 2 provides location transparency by abstracting away both these tangents of scalability by turning them into an operations and configuration task. This gives the Akka runtime freedom to do adaptive automatic load-balancing, cluster rebalancing, replication and partitioning. Akka is available at http://akka.io (under Apache 2 license).

You don't have to choose between fast and realistic tests. Using JUnit @RunsWith test runners, I'll show you how to write a test will run fast enough to run all the time and that also can verify integration with external systems.
Define unit test: "A test that runs fast and can run in parallel with other tests", Define integration test: "A test that uses realistic third party software or systems" Using JUnit 4.8 @RunsWith test runners, on my recent projects I've created tests that can be configured to run both with in-process fakes and with real third party systems. I've used this on large scale for tests that integrate with a database and have toyed with using the idea for slow and fast-running web integration tests. By using this approach, I have tests that are fast enough to run with Infinitest and that can also verify integration with external systems.

In this session, we'll explore the concepts of BDD and ATDD together to drive agile development using a powerful trio of testing frameworks: Arquillian Drone, WebDriver and Thucydides. Rather than just test cases, you'll build higher-level, end-to-end functional behavior using reusable web test components and following a clear "given, when, then" perspective. The result: cleaner, clearer tests that both validate your requirements and document your system behavior.
Unit tests are programmer's best friend, but relying on them exclusively gives an illusion of overall system integrity. At some level, we need to verify how our components integrate and ensure unexpected behavior does not creep in when we shift the application into the target runtime. It all amounts to whether your application is providing the end user what he or she is really needs (tire swing) instead of what anyone thinks they need. How can we save our users from frustration, keep the fail whale at bay and communicate with stakeholders that the requirements are being met? We'll show you how the Arquillian testing platform can give you these guarantees by driving agile development. We'll explore the concepts of BDD and ATDD together using a powerful trio of testing frameworks: Arquillian, WebDriver and Thucydides. Rather than just test cases, you'll build higher-level, end-to-end functional behavior using reusable web test components and following a clear "given, when, then" perspective. The result: cleaner, clearer tests that both validate your requirements and document your system behavior. Testing behaviors has never been so easy, and so real! If you care about quality of your software you definitely shouldn't miss this talk!

This talk is about the expirences of going from a lightweight architecture based on Jetty/Spring to a fully blown clustered grid services hosted on the GigaSpaces XAP plattform. The speaker will try to give som insights into what you need to think about to succeed with creating and depoying a Java grid application.
Foredraget tar for seg erfaringene man har gjort med å gå fra en lettvektsarkitektur basert på Spring og Jetty til en robust gridbasert arkitektur med GigaSpaces XAP. Foredraget vil gå igjennom motivasjon for hvorfor man erstattet nåværende arkitektur og hvilke krav som gjorde at man valgte å benytte en grid plattform. For at tilhøreren skal forstå utfordringene gis det en kort introduksjon til GigaSpaces med fokus på hvilke egenskaper plattformen har som skiller seg fra Jetty eller andre applikasjonsservere som WebSphere og Weblogic. Foredraget vil belyse hvordan man i løpet av 2 år, gradvis endret arkitektur fra en tradisjonell servletbasert arkitektur med database backend til en linjær skalerbar clusteret in-memory grid hvor både data og applikasjon kjører på GigaSpaces plattformen. Overgangen ga en rekke utfordringer for områder som: arkitektur/design, opplæring, utvikling og drift. Foredragsholderen var tidligere med på erstatte en "tungvekts" J2EE arkitektur basert på Websphere med Jetty og vil avslutningsvis gi noen synspunkter på hvordan det har vært å gå tilbake til en kommersiell applikasjonsplattform.

In this experience based talk you'll hear why Gradle probably is the best option for describing your build.
Mange klamrer seg fortsatt til en illusjon at alle bygg er (nesten) helt like. Det stemmer kanskje i knøtteligaen men i litt større organisasjoner finner man nesten alltid spesielle krav til bygge/leveranseprosessene. Det virker logisk å velge et byggeverktøy som svært fleksibelt og samtidig basert på konvensjoner. Det verktøyet heter Gradle. Etter snart 2 års erfaring med innføring/bruk av Gradle i store og små prosjekter har Magnus samlet seg opp en rekke erfaringer. Fellesnevneren for bruk av Gradle i prosjektene (utover at det har vært suksesser:-) er at samtlige har hatt spesielle krav/ønsker som neppe ville vært mulig å finne ferdigsnekrede løsninger for. I dette foredraget vil du få smakebiter av styrken i å velge et verktøysett som gjør det lett for deg å tilpasse bygget ditt. Du får illustrert Gradles sterke (og noen svake) sider gjennom konkrete prosjekteksempler. Du kommer til å la deg forelske av Gradles støtte for inkrementell bygging, den nydelige DSL’en for å beskrive bygget ditt og fleksibiliteten til å kunne løse nettopp ditt problem. Vi starter med en kort introduksjon for de som ikke har hørt så mye om Gradle før.

Gives an overview of the common architectures found when dealing with Big Data and how to address it.
Hadoop is not an island. To deliver a complete Big Data solution, a data pipeline needs to be developed that incorporates and orchestrates many diverse technologies. Using an example of real-time weblog processing, in this session we will demonstrate how the open source Spring for Apache Hadoop project can be used to build manageable and robust pipeline solutions around Hadoop.

The PRD for Java 7 had almost 2000 changes. This talk is on 55 new features in Java 7 you (probably) didn't hear about in an ignite format of one per minute. No stopping, no going back....Questions, sure but only if time remains (otherwise save for later).
The PRD for Java 7 had almost 2000 changes. This talk is on 55 new features in Java 7 you (probably) didn't hear about in an ignite format of one per minute. No stopping, no going back....Questions, sure but only if time remains (otherwise save for later).

Minimize useless merge commits and take control over the commit history with git rebase. And have some fun while you're at it.
Umiddelbart etter man tar i bruk git ser man fordelene -- ting går raskt, man kan arbeide lokalt og en opplever gjerne færre merge-konflikter enn tidligere. Noen uker senere og en titt på historien viser en hel del commits som intetsigende lyder "Merge branch 'origin/master' into master". Etter et kjapt søk på Internett, dukker innstillingen autosetuprebase opp som en sølvkule. Men det er det jo selvsagt ikke, en konflikt i form av en simultan endring på samme linje må alltid løses. I tillegg finnes glatte steiner på rebase-stien. Så hvordan fungerer egentlig rebase? I denne lyntalen vil jeg prøve å fjerne noe av magien rundt rebase, og vil vise en arbeidsflyt som bidrar til at man får mye mer kontroll over historien. En ren historie gjør det også mye lettere å rulle tilbake endringer, håndtere konflikter og lage releasemeldinger.

Are you using jQuery? Do you want to increase your script performance? Learn about simple tips to dramatically enhance your code, especially on a large DOM.
Bruker du jQuery? Vil du vite mer om å forbedre ytelsen til dine skript? Lær om enkle tips for å dramatisk øke ytelsen til din kode, spesielt på store DOM'er.

From code review to continuous inspection with Sonar
The Job of a developer has evolved strongly in the last 10 years, pushed by new requirements and new tools such as Continuous Integration, Test Driven Development and refactoring. Software Development Industry has now reached a sufficient level of maturity to engage into new practices such as managing source code quality while developing applications. After introducing the concept of the internal quality (and non-quality), this presentation will show why and how to measure this quality in order to define action plans. We will then see how to use Sonar to support such practice in a classical approach code, audit oriented. Thereafter, we will see why and how to go further by using the powerful differential views in Sonar to support a new practice : the Continuous Inspection. This is a important transformation of this practice from a control oriented process to a development support oriented process

Introduction to C++11 for Java developers
Vi tilbyr en kjapp innføring i C++ for Java utviklere. Det er særlig de nye tingene i 2011 standarden av C++ som vil få fokus. I denne presentasjonen vil vi demonstrere hvordan du kommer i gang med et C++ prosjekt, men vi vil fort gå over til å diskutere og sammenligne sære språkdetaljer. Målet vårt er å lage en presentasjon hvor de flinkeste Java programmere kan lære akkurat nok om den nye versjonen av C++ til å gjøre et informert valg om de vil lære mer om C++11 eller ikke.

Modern programming thrives on rich spaces of data, information and services. With F# 3.0, you now have a tool that massively simplifies information-rich programming with enterprise and web data sources. F# 3.0 provides world-beating support for the direct language integration of massive information sources through a new technique called F# type providers. In this talk, we will describe the new features of F# 3.0 and show how you can use it to greatly simplify data access and transformation programming with SQL, Hadoop and REST APIs.
Modern programming thrives on rich spaces of data, information and services. With F# 3.0, you now have a tool that massively simplifies information-rich programming with enterprise and web data sources. F# 3.0 provides world-beating support for the direct language integration of massive information sources through a new technique called F# type providers. In this talk, we will describe the new features of F# 3.0 and show how you can use it to greatly simplify data access and transformation programming with SQL, Hadoop and REST APIs.

Learn about common serialization pitfalls and techniques for their solution, and get tips on optimizing the efficiency of serialized data.
Java serialization is a powerful core technology used by many applications and as an underpinning for many sophisticated Java technologies such as RMI, EJB, SDO, JPA, and distributed caching. Yet its implications for the design of Java systems are often overlooked. This presentation explains the continuing relevance of Java serialization. Whether for designing a system specifically concerned with serialization, developing reusable components, or updating code in which serializable objects exist, a good understanding of serialization considerations is invaluable. Learn about common serialization pitfalls and techniques for their solution, and get tips on optimizing the efficiency of serialized data.

Hypermedia and HATEOAS is one of the core principles of the REST architecture. We'll take a practical approach to the subject, and show you how you can implement this principle in an existing web-API.
I fagmiljøene diskuteres det stadig om hva som skal til for å kunne kalle et web-API for et REST-API. Vi mener prinsippet om at hypermedia skal være limet som binder APIet sammen og muliggjør tilstandsendringer er en av de viktigste fordelene REST-arkitekturen gir. Dette er også det som ofte mangler i ellers gode APIer. I dette foredraget tar vi en praktisk tilnærming til emnet, og ser på hvordan man med noen enkle grep kan innføre linker i et eksisterende API. Vi viser hvilke fordeler dette gir, og deler også noen erfaringer vi har gjort oss med å innføre linker i et produksjonssatt API.

Pros and cons with using Cassandra
Prosjektet jeg jobber i har benyttet Cassandra i nesten 2 år og vi har gjort oss noen erfaringer. Har du planer om å benytte Cassandra i ditt nåværende eller neste prosjekt? Kom innom denne lyntalen og vil jeg dele et par "pros and cons" som kan være nyttig

Looking at a real life project we describe how we had to adapt the architecture to suite an environment with a lot of unknowns. The case we will look at is a critical service for the owner and has a relatively large number of integration points. The project had little control over these integration points and ended up with a mindset of: The only thing you know, is that you do not know everything. Hence the architecture had to be adapted, several times.
Det tas utgangspunkt i et prosjekt fra virkeligheten og viser hvordan vi har måttet tilpasse arkitekturen gang på gang som en konsekvens av et miljø med mange ukjente. Caset vi ser på er kritisk tjeneste for eieren og har et relativt stort antall integrasjonspunkter. I tillegg hadde prosjektet lite kontroll på de omkringliggende systemene både når det kom til ytelse og oppetid, mens prosjektet selv skulle produsere en tjeneste med 99.9% oppetid. Vi ser på ytelsesproblematikk, oppetid, integrsjon med hyllevareprodukter, caching teknikker og ressurskontroll. I tillegg til dette måtte prosjektet også håndtere en stadig utvidelse av funksjonaliteten og en stadig økende brukermasse. Arkitekturen måtte endres flere ganger.

Git is more than just a version control system. When your code is stored in Git, you have a lot of different tools at hand in order to make your daily work easier. Git Bisect and Git Rerere are two of these.
Git er mer enn bare et versjonskontrollsystem. Når du bruker Git for å holde på koden din har du et utall av morsomme verktøy du kan benytte for å gjøre hverdagen din mye enklere. Jeg vil i denne lyntalen snakke om to av disse verktøyene: Git bisect - den mest givende måten å finne ut når en bug ble introdusert til koden din. Jeg vil vise hvordan bisect fungerer, og vise eksempler på praktisk bruk. Git rerere - aldri mer en merge du har gjort før. Rerere står for Reuse Recorded Resolution og gjør akkurat det - husker på hvordan du håndterte tilsvarende merge tidligere.

Embrace our UNIX heritage while staying within Java. Learn the techniques and tools to better embrace UNIX within Java -- native executables and man pages, proper daemonization, using native libraries easily, building great command line interfaces, and tools and techniques that let you embrace UNIX idioms.
Embrace our UNIX heritage while staying within Java. Learn the techniques and tools to better embrace UNIX within Java -- from native executables and man pages, proper daemonization without wrapper tooling, using native libraries more easily, building great command line interfaces, to the tools and techniques that let you embrace UNIX idioms -- this talk reaches out to the sysop in each of us. Over the last several years, the Java community has started to better embrace the environment in which it typically runs. It turns out that in many cases working with native tooling and libraries simply works better, and we've developed great ways to make it painless and straightforward. Working with UNIX goes both ways, though. As we embrace the UNIX way of using tools, we find it behooves us to also build our tools so that they play nicely from UNIX as well as using it. We can easily, and without breaking any of the Java rules, work with native package managers, create native executables from our jars, and work well within a multi-process world. It turns out that our practices in the Java world actually make Java tools some of the most pleasent to work with operationally, as long as we follow some basic practices.

With Java Annotation Processing, you can tell the Java compiler to validate parts of your code to fail at compile-time rather than run-time. This talk will give you an hands-on examples on how to use this seemingly unknown, but powerful technology.
Java annotation processing lar deg skrive compiler plug-ins som setter deg i stand til å gå gjennom koden, lete etter annotasjoner og utføre valideringer i henhold til annotasjonens bruk. For eksempel kan du sjekke at alle klasser annotert med @EJB har @SecurityDomain satt og at verdien ikke er feilstavet, alt gjort på kompileringstidspunktet. I dette foredraget vil Vidar gi deg en innføring i Java Annotation Processing. Foredraget forklarer hvordan du instruerer javakompliatoren til å validere kode slik at du får kompileringsfeil og ikke kjøretidsfeil, uten å ta i bruk mekanismer andre mekanismer enn Core java. Utfordringer rundt IDE-støtte blir også diskutert. Etter foredrag vil tilhørerne ha fått innblikk i hvordan Java Annotation Processing fungerer og hvordan de kan ta det i bruk i sine egne prosjekter. Annotation processing er ikke mye brukt og foredraget vil være en fin mulighet til å få en rask innføring i en spennende mekanisme som kan gi interessante muligheter.

Tired of bloated and unstructured test suites? Come see how Spock and Groovy can help you articulate concise, readable specifications for your system´s desired behavior.
Spock is an expressive and elegant testing framework for Java and Groovy applications. You use it as an alternative to JUnit to create readable and concise tests through a simple specification language. Because it is based on Groovy, it takes away unnecessary boilerplate common in Java based unit tests and leaves you with a structured specification of a program´s wanted behavior. It even comes with a built in mocking API. Spock is compatible with JUnit, which means Spock specifications runs seamlessly in IDEs, in builds tools and on continuous integration servers. This lightning talk will introduce Spock through several examples.

Are you using the Java Persistence API in your applications without considering the alternatives? Is JPA really the best choice in every situation? This talk will encourage you to think before you choose your persistence technology.
Havner JPA i persistenslaget ditt uten at du tenker over alternativene? Er egentlig JPA den beste løsningen på alle persisteringsoppgaver? Dette er spørsmål jeg med tiltagende frekvens har stilt meg selv de siste årene. I denne lyntalen vil jeg snu JPA-medaljen og avsløre dens hårete rygg. Hva er det egentlig man får med på kjøpet når man velger JPA, og hvordan påvirker dette resten av applikasjonen? Når bør man velge noe annet, og i så fall hva er alternativene?

Do web frameworks need to be large lumps of features and constraints ? No. Not really. This live coding session will cover Unfiltered, a toolkit for servicing HTTP requests in Scala. I start from scratch and end up with a working web application deployed in Heroku at the end of the session.
En sjelden gang i blandt dukker det opp et rammeverk som gjør akkurat det som trengs. Hverken mer eller mindre. Unfiltered er et av disse. Unfiltered kaller seg riktig nok ikke et rammeverk, men et toolkit for å håndtere HTTP requests for Scala. Jeg har nå hatt gleden av å bruke Unfiltered i et par prosjekter. Og har lyst til å dele min fasinasjon av dette rammeverket. Dette er ikke et foredrag i tradisjonell forstand, men en live coding session. Jeg vil på min tilmålte tid vise hvordan man, med blanke ark, kan komme i gang med Unfiltered. Vise grunnprinsippene Unfiltered bygger på, lage en liten applikasjon for å demonstrere prinisppene. Til slutt installere løsningen på Heroku for alle å se.

Publishing an opensource project - what's in it for you? Highlights of learning experiences that should improve your programming skills, and how you can go about doing it.
What's in it for you? Publishing a project was a great experience for me, and has facilitated improving my programming skills since version 0.1. I hope I can inspire you to do the same. I will also go through the steps taken to opensource a simple project, and get it synchronized to Maven Central, providing the information and pointers you need, along with a couple of tips that may save you some effort.

Learn how data grid technologies have evolved from just caching data to enabling highly sophisticated distributed systems.
Distributed caching technologies have now been around for more than ten years. Their capabilities have grown and matured over the years, and so have the users and their use cases. This presentation will look at how the use of data grids have evolved from distributed caching to doing highly sophisticated distributed computing today. The audience will learn how new capabilities has changed how data grids are being used from an architectural point of view and also how it helps solve new problems like running applications across multiple datacenters, sharing data across multiple platforms and making applications ready for the cloud.

Frameworks can kill you, others can save you. How do you spot the difference?
Rammeverk er utrolig utbredt i programmering i dag, og kanskje spesielt Java. Gjennom tidene har rammeverk reddet oss fra Java EE, forenklet utvikling og gitt en fantastisk mengde med kode vi kan studere for å lære mer. På både godt og vondt. Men kanskje det har gått for langt? Viljen til å bruke rammeverk er så stor at man fortsetter å bruke de selv om de har høyere kostnad enn verdi. Jeg har pirket borti en del rammeverk, og har opparbeidet meg en sunn skepsis. Rammeverk er der for å hjelpe deg, kommer de i veien må du kaste de ut før du blir sittende helt fast i hengemyra! Det er ingen grunn til å benytte rammeverk for rammeverkets del. Jeg har noen tips til hva du skal se etter for om rammeverket fungerer for deg, eller om du kanskje skal sette deg ned å skrive noe selv. Det er lett å undervudere problemene et rammeverk kan føre til, og å undervudere verdien et helt egenprodusert spisset rammeverk kan ha.

Slowly we're beginning to see alternative languages (to Java) appear in the enterprise. John will be looking at some of the advantages and demonstrating how we can use parts of the language without having to dive into the deep end.
There are literally hundreds of programming languages but Java, C & C++ cover over 90% of all the code written on the servers in the investment banking world. It's true to say that there's virtually nothing you can't do in these languages but it doesn't stop enthusiastic "alternative language groupies" telling us there's a better way and that we should all change what we're doing; Ruby, Clojure, Scala, Haskell, Erlang to name just a few. There is something we can learn from these languages without having to become an expert. John will walk through some existing production architectures looking at how some of the languages have changed the way we work.

Kotlin is a modern statically typed general-purpose language designed to be safe, concise, expressive and 100% Java-compatible. It is compiled to Java byte code as well as JavaScript, so it can run on both client- and server-side. This session gives an overview of the key features of Kotlin and demonstrates how the new language integrates into the existing infrastructure. On top of that we show how one can make Java APIs better using Kotlin, without having to alter them in any way.
Kotlin is a modern statically typed general-purpose language developed by JetBrains (creators of IntelliJ IDEA) and distributed under the Apache 2 License. Kotlin is focused on being a *good tool* for a wide range of development tasks: from mobile applications to enterprise software. It compiles to Java byte code as well as JavaScript, so it can run on both client- and server-side. We prefer pragmatic design to scientific novelty and learn from existing project all the time: both their strong and weak points. The main design principles behind Kotlin are: * 100% Java compatibility: seamlessly use Java from Kotlin and Kotlin from Java; * Fast bytecode and fast compilation; * Static type safety; * Conciseness and flexibility without too much complexity. This session gives an overview of the key features of Kotlin and demonstrates how the new language integrates into the existing infrastructure: from libraries to the IDE and build tools. On top of that, we show how one can make Java APIs better using Kotlin, without having to alter them in any way: * Kotlin’s extensions turn standard JDK collections into fluent data structures that can be processed in the spirit of LINQ; * Even Swing control layout can be turned into a nice declarative code by type-safe builders implemented in Kotlin... You can read more about Kotlin at http://kotlin.jetbrains.org And try it out at http://kotlin-demo.jetbrains.com/

What makes programming enjoyable and what makes it into a chore? What experience does experts in the fields have of fun projects and how can you make your everyday work more fun? Should we fire all architects and project managers? Or do developers just need to grow the **** up? These questions and others will be discussed by our experienced panel of top notch programmers both from Norway and abroad.
What makes programming enjoyable and what makes it into a chore? What experience does experts in the fields have of fun projects and how can you make your everyday work more fun? Should we fire all architects and project managers? Or do developers just need to grow the **** up? These questions and others will be discussed by our experienced panel of top notch programmers both from Norway and abroad. The panel will consists of the following: * Bodil Stokke of CoffeeScript fame from JavaZone 2011. She is suspicious of everything that sounds like enterprise talk, like "Java" and "Agile" * Christin Gorman is a hands-on developer with no authority but strong opinions. Her lightning talk from JavaZone 2011 was the most watched video from JavaZone * Kevlin Henney is a software development trainer and consultant and popular conference speaker. He was the editor for "97 Things Every Programmer Should Know" * Marcus Ahnve is a team leader, architect and Agile coach for Valtech. He speaks at JavaZone about how the software development lifecycle needs to include death. * Roy Osherove is a coach who specializes in Agile and Lean team leadership who often sings during his presentations. He recently moved from Isreal to Norway. You can read his thoughts at 5whys.com and at twitter @royosherove

Illustration of functional programming techniques based on common concepts and examples people are already familiar with: declarative approaches, logic programming, dataflow and transformation, immutability, lambdas, pattern matching, expression-based code.
From JVM to .NET languages, from minor coding idioms to system-level architectures, functional programming is enjoying a long overdue surge in interest. Functional programming is certainly not a new idea and, although not apparently as mainstream as object-oriented and procedural programming, many of its concepts are also more familiar than many programmers believe. This talk examines functional and declarative programming styles from the point of view of coding patterns, little languages and programming techniques already familiar to many programmers.

Learn to whip up some mouth watering comfort code in your own kitchen, certain to satisfy cravings and impress friends and family.
You know the code that is so deliciously fulfilling, you wake up craving it in the middle of the night? I like to think of this as comfort code. In this talk you will see simple, yet elegant code example dishes you can throw together, using ingredients every developer should have in the pantry. Kari will show you how to whip up some mouth watering treats, certain to satisfy cravings and impress friends and family.

Howto avoid, spot and fix performance problems arising when using external indexing technology in conjunction with key-value stores.
Valg, og bruk, av indekseringsteknologi i sammenheng med key-value databaser kan berike spørremuligheter, men vil det også påvirke ytelsen til systemet. Praktiske erfaringer ved valg av strategier og tuning av indeksering med basis i et Qi4J-basert system.

We use maven for builds, versioning and dependency management of components. This lightning talk describes the idea behind using our own tailored Ruby scripts for agile and swift delivery in a large development project.
Vi bruker git som versjonskontroll og maven for å styre avhengigheter, bygge og versjonere. Men for leveranser brukes egenutviklet Rubyscript som hjelper deg å levere ofte og hurtig. Lyntalen beskriver ideen bak ett sett med Rubyscripts som gjør smidige og hurtige leveranser mulig i et stort utviklingsprosjekt med flere hundre maven-artifakter og avhengigheter.

This speach examplifies unexpected ways of doing or not doing things in Java. Contains examples on how sometimes not to code in Java.
Java sin største styrke er at du kan forstå kode som er skrevet av andre. (Eller av deg selv to måneder før!) Her finnes ikke fnugg av operator overloading, implicits og multippel inheritance. Begrepsapparat og mengden programmeringskonsepter er håndterlig. Rett som det er treffer man likevel på konstruksjoner som er uventet, der reaksjonen er enten latter, hoderystning eller "går det virkelig an ?". Denne lyntalen inneholder rare, morsomme og overraskende kodeeksempler som foredragsholderen har snublet over i årenes løp. Eksemplene dekker tema som generics, method resolution, initialisering og serialisering. Målet er å vise at selv om syntaksen og semantikken i Java er overkommelig, så finnes det overraskende måter både å skyte seg selv i foten på og også å lage robust kode.

The increasing demand for real-time monitoring and decision making requires event sourcing and processing architectures, frameworks and tools. Come and get some complex event processing basics, know some frameworks and real world use case implementation using Esper.
The increasing demand for real-time monitoring and decision making requires event sourcing and complex event processing (CEP) architectures, frameworks and tools. In this presentation Peter will introduce you to the concept complex event processing and event stream analysis, the typical use cases, a comparison of a couple of open source frameworks and a comprehensive overview of Esper and how Extenda has used it.

Techniquies for building rock solid web applications on top of underlying systems that are rotten, outdated and/or deprecated.
Unstable back-end systems ? Changing data ? Test and production two worlds apart ? Based on real project experiences, this talk is about Selenium-based approaches to how quality can be achieved against all odds. With code.

An introduction to the Rust language and RustyCage the Rust IDE plugin for Eclipse. Rust is an experimental, concurrent, multi-paradigm, compiled programming language developed by Mozilla Labs.It is designed to be practical, supporting pure-functional, concurrent-actor, imperative-procedural, and object-oriented styles.
Rust is a curly-brace, block-structured expression language. It visually resembles the C language family, but differs significantly in syntactic and semantic details. Its design is oriented toward concerns of “programming in the large”, that is, of creating and maintaining boundaries – both abstract and operational – that preserve large-system integrity, availability and concurrency. It supports a mixture of imperative procedural, concurrent actor, object-oriented and pure functional styles. Rust also supports generic programming and metaprogramming, in both static and dynamic styles. Rust is influenced by Alef, C++, Camlp4, Common Lisp, Erlang, Haskell, Hermes, Limbo, Napier, Napier88, Newsqueak, NIL, Sather, Standard ML

This talk shows how you can link data across different data sets, and find near-duplicate records, without common identifiers using well-known statistical techniques. It also presents an open source Java engine for doing this easily.
What if you have customer data from CRM and from billing, but no common customer IDs? Or your CRM contains lots of duplicate customer records? How to link the records, or identify the duplicates? Similar problems recur in many, perhaps even most, systems, from CRM, to BI, to Linked Open Data. Solving them is a substantial challenge, as data quality is generally low, with names and other data written every which way. Surprisingly, statisticians have been working with this issue since the 1940s, and have developed a rich set of techniques for handling the problem. There is a considerable body of statistical and mathematical theory in this field, but the core ideas are simple and easy to understand and apply. This talk presents the basic theory, together with a solution: an open source Java engine based on Lucene, called Duke. The use of the engine is shown with concrete examples, including how the engine was used successfully in a project for Hafslund.

Stop learning frameworks and languages, start learning programming.
At every Javazone, the rooms are filled with speakers wanting to teach you the newest framework or the hottest programming language. And it's always revolutionary, it'll always make you 10X more productive, and it's always a blast to work with. So people learn their frameworks and their languages, but they never take the time to learn basic skills like unit testing, refactoring, object-oriented design or patterns. Enough already!

You know how you always mean to apply proper MVC principles but end up with a mess of jQuery instead? No more excuses: now there's Backbone. In this presentation, you'll learn how to harness the power of Backbone by example, as we build a simple browser side application from the bottom up using nothing but Backbone and your favourite DOM toolkit.
Have you ever tried to write a moderately complex browser side application with the assumption that jQuery is probably all you need for the job? I mean, fire off some AJAX requests, then just use some DOM manipulation to put the results where you want them—how hard can it be, right? Would you have enjoyed maintaining the code that resulted from that assumption? No, neither would I. Would you like to see a better solution? As it turns out, programmers have known how to keep their frontend code under control for a while using a surprisingly simple principle called MVC. Now that the browser has suddenly become a serious platform for application development, the need for MVC (or, at least, the basic concepts behind MVC) has become so apparent that we already have multiple rival MVC libraries for the browser platform. Backbone is arguably the most popular of the lot, and certainly one of the most lightweight. In this presentation, you'll learn how to harness the power of Backbone by example, as we build a simple browser side application from the bottom up using nothing but Backbone and your favourite DOM toolkit.

All your JRE's are belong to us! Why Java vulnerabilites are emerging as the most effective way to compromise computers, and a practical example why you should go home and uninstall Java now.
Utnyttelse av sårbarheter i Java er i ferd med å bli blant de vanligste metodene for en angriper å ta over en PC. Samtidig surfer de fleste av oss på nettet med Java-applets aktivert i nettleseren. Kan man stole på at sandkasseteknologien gjør nettsurfing trygt? Denne lyntalen prøver å gi svar på hvorfor utnytting av Java-sårbarheter nå er i vinden, og du vil få se både angrepskode og en demonstasjon på hvordan et sikkerhetshull i Java kan utnyttes. Det vil til slutt bli gitt råd til utviklere, arkitekter og nettsurfere om hvordan de bør forholde seg til Java på klientsiden. Koden fra lyntalen kan lastes ned fra http://all-your-JREs-are-belong-to-us.com

A treatment of advanced Git topics like interactive rebasing, the reflog, git reset, and integration with external diff tools.
Now that Git has been in the wild for several years, leading edge developers and projects are considering it their primary source code control tool of choice. Distributed version control systems have so much to offer, but are you using Git and its DVCS capabilities to their fullest? This talk assumes a working basic knowledge of Git and, quicly progressing from from there, explores some of the intermediate to advanced uses of this unique version control tool. We will work through examples of powerful features including interactive rebase, rebase-on-pull, external diff tools, rerere, advanced logging features, the RefLog, and the reset command.

The road to Continuous delivery may sound easy when reading about it. But is it? I was given the change of introducing this idee to a team that was f... up. They had the tools but did not use them right. How did we do? where are we on the path to Continuous delivery..
Everyone talks about it, everyone “knows” how to do it, but everyone has an excuse for not doing it. I entered a team where everyone was running around like headless chickens and could not do anything right. Code was hacked in production. Errors occurred, was fixed, and then unfixed by by another developer trying desperately to make things work. A depoy when I arrived took 3 days to put into production !!! just because of an minor error. I was given the task of making it right. Where to go? of course “continuous delivery”. what happened? did I make it? what was the issues on the way? how did i do it.. (doh.. did i spoil the surprise?)

HTTP was invented by Tim Berners Lee 20 years ago. A lot has happened since then. We look at HTTP-related problems and how Google's SPDY solves some of these.
HTTP ble funnet opp av Tim Berners Lee for 20 år siden. Mye har skjedd siden den gang. Vi ser på utfordringer med HTTP og hvordan Googles SPDY løser noen av disse.

Liquibase is a tool to help controlling migrations in SQL databases. The tool has existed for quite some time, but still it is not that known. After several years of experience with this tool vi explain why you should use this type of tool, and how to get started with Liquibase.
Liquibase er et verktøy for å hjelpe til med å få kontroll på migreringer i SQL databaser. Verktøyet har eksistert lenge men er likevel mindre kjent. Etter flere års erfaring med verktøyet går vi gjennom hvorfor man bør bruke slike verktøy, hvordan man kan komme i gang med Liquibase og hvilke erfaringer vi har med det.

Java release 8 will have language features for support of functional programming: lambda expressions, functional types, extension methods, and method references.
Java release 8 will have language features for support of functional programming. We will have lambda expressions, functional types, extension methods, and method references. The session will explain the new features and their use. Extension methods, for instance, will have an impact beyond the context of lambdas. They add a new kind of multiple inheritance to Java that we will have a lot of fun with.

This presentation will discuss different pros and cons with organizing code, either horizontally or vertically.
Når en skriver kode, er det ikke uvanlig å ønske å dele inn koden i moduler/komponenter. Det kan være mange grunner til det; lagdeling, funsjonalitet, gjenbruk. Når koden deles inn, kan en velge mellom horisontal inndeling eller vertikal inndeling. Denne lyntalen vil se på ulike fordeler og ulemper som følger med de ulike valgene, og forhåpentligvis gjøre at du som utvikler/arkitekt er bevist på valget ditt neste gang du skal gjøre et slikt valg.

The shell will serve you loyally, always and down to the last command. - "Some assembly required"
Shellet kan bli din beste venn og gi deg alt du trenger, kjapt og effektivt. Men; "Noe montering må påregnes" Jeg vil gjerne dele mine erfaringer om hvordan jeg har konfigurert mitt shell for å all den informasjon og funksjonalitet jeg trenger.

Self-made solution or a well established framework? We started using the Activiti framework, but ended up with our own custom solution. Everything went fine until our home grown solution started to grow in size and complexity...
Vi utvikler en saksbehandlingsløsning for Oslo kommune, og har behov for å støtte langvarige prosesser. Det opprinnelige valget falt på Activiti Business Process Management Platform, som lar oss modellere prosessene i XML. Selv om det tilsynelatende var rett verktøy for jobben, forklarer vi hvorfor Activiti ble hevet ut og erstattet det med en enkel, skreddersydd løsning basert på en tilstandsmaskin. Noen måneder senere begynte imidlertid den enkle løsningen vår å ese ut. Var ikke verden så enkel som den så ut? Var vi i ferd med å re-implementere Activiti? Vi forteller hvordan dette gikk, og hva vi erfarte underveis.

DIY: Create the next Instagram in your web app, using only well-known technologies like HTTP, Java Servlets and Java 2D.
I dette foredraget vil jeg gå gjennom det det grunnleggende som skal til for å lage en enkel "asset manager" web-applikasjon, basert på kjente teknologier som HTTP, Servlets/Filtere og Java 2D. Nesten helt uten bruk av tredjeparts biblioteker. :-) Dette enkle fundamentet vil på sikt kunne utvides til å gjøre relativt avansert "on-the-fly" bildemanipulering, f. eks legge på retro "lomo-look" a la Instagram/Hipstamatic og lignende tjenester. Jeg vil presentere en relativt rett-fram arkitektur med tanke på god ytelse og skalerbarhet. Web-applikasjonen vil kunne brukes, både som backend for å serve web-klienter (nettlesere) direkte for bruk på nettsteder, eller som en REST-style backend for tykkere klienter (mobil eller desktop). Til slutt vil jeg gå igjennom litt dyrkjøpt erfaring, og identifisere noen typiske feller, samt komme med lure tips og triks for å overvinne noen vanlige utfordringer i denne type teknologi.

You have to solve the problem but your enterprise integration project will almost never look pretty in real life. They always feel somewhat bad. But this slightly less bad thing over here compared to that inherently ugly and expensive thing over there might just be good enough.
Store enterpriser har integrasjonsutfordringer. Utfordringene *må* løses, og gjerne på bare litt for kort tid hvis du er heldig med prosjektet. Og så kommer følelsen av at dette blir dårlig. Enterpriseløsninger man bare må fikse, gjerne med en tungvekts produktportefølje i tillegg, har liksom en dårlig aura rundt seg. Det ender på en måte alltid opp som "dårlig". Men hvis vi bare kan endre tilnærmingen litt og få til noe som er litt bedre, bare sånn passe dårlig, er det kanskje godt nok?

This ain't your granddad's Futures
With Scala Improvement Proposal 14, Scala's Futures will get a big upgrade with the new Future and Promise APIs. In this talk I will talk about the new APIs and how Futures and Promises can be used to compose asynchronous dataflow. We'll see how Futures can be used in for-comprehensions, how to gracefully handle failure, how to avoid blocking operations and get a glimpse into the implementation. This surely is the Future I was Promised, and now it is yours too!

This session presents a comprehensible, clearly arranged style for implementing consistent Swing application by showing detailed sources for a contact editor example.
In this session we explain how to implement consistent Swing applications in a comprehensible and clearly arranged way. We show detailed sources for a contact editor example and discuss a bunch of tips. The presented implementation style is applicable for the popular desktop patterns "Model-View-Presenter" and "Presentation Model" and variants; it can be used with or without visual editor, with different binding approaches and component creation mechanisms, as well as different layout techniques. It can be ported to other toolkits such as JavaFX, the SWT and even to other environments, e.g. the GWT.

An approach to combine responsive web design with server side components to make advanced responsive web solutions that work for all kinds of devices.
Responsive Web Design er en rekke teknikker for å optimere websider til forskjellige typer enheter og browsere. Tilpassingen gjøres ofte av browseren, men mange responsive sider er store og tunge og ikke særlig brukervennlige på mobilen. Det er også en utfordring å tilpasse fastbredde innehold til en slik context. En alternativ løsning er å gjøre en tilpassing av websida på server siden ved å servere ulike versjoner til ulike weblesere. I denne presentasjonen vil vi se hvordan vi kan kombinere det beste fra begge disse metodene – også kalt RESS.

The highs, lows and lessons of splitting the Guardian's platform from one monolithic application to many loosely coupled applications.
A few years ago the Guardian (www.guardian.co.uk) completed a major rebuild of it's systems that produced a single application that succesfully served the high volume of traffic to the site, accomplished many of the project's other goals and was judged a success. However, we weren't satisfied. Any new addition risked affecting the whole site's performance and stability, the code base was continuously growing and there was little room for innovation and experimentation. In this talk I'll discuss the various ways we've attempted to break down the site into a collection of smaller applications including the difficulties and missteps as well as the successes.

The next step in the technology evolution has reached the Enterprise world. Today, companies want to offer their employees a chance to work on a mobile platform, to achieve more efficiency and perform advanced tasks. Users normally deal with desktop applications or websites, and need vast amounts of data instantly accessible, even in an offline situation. How to do this on a mobile platform? Which opportunities and pitfalls can arise? This presentation focuses on building an Enterprise Android application, with regards to large amounts of data that needs to be synchronized, ORMs for Android, architecture challenges like distribution and handling the fragmented Android world, and what is happening when we push the limits of Android.
Det neste steget i teknologi-evolusjonen har nå nådd Enterprise-verden. Stadig flere bedrifter vil tilby arbeidstakere å jobbe på mobile plattformer. Man ønsker å utnytte store og små håndholdte enheter til daglige arbeidsoppgaver, slik at det oppnås større effektivitet og kan utføres avanserte handlinger hos brukere som ikke sitter bak en PC til enhver tid. Brukerne idag har gjerne en desktop-applikasjon eller en webside å forholde seg til i sitt daglige virke, basert på store databaser, mange skjermbilder og rike brukergrensesnitt. Det forventes at man kan utføre avanserte oppgaver og få tilgang til store mengder informasjon på kort tid, gjerne uten å være online engang. Hvordan kan man da gjøre dette mobilt, da spesielt på nettbrett? Hvilke muligheter og fallgruver kan man støte på, og hvordan håndterer man disse? "To boldly go where no man has gone before"! Her vil det bli et dypdykk i både kode, GUI, bruk av interne komponenter, arkitektur og finurlige Androide quirks, samt fokus på synkronisering av store datamengder mot Oracle databaser. Presentasjonen vil benytte eksempler og erfaringer høstet fra blant annet et stort Enterprise-prosjekt på Android-plattformen for Mesta AS.

If you want to do Continuous Delivery, you should develop on mainline, or at the very least merge to mainline daily. In this talk I will explain some techniques and patterns that can be used to achieve this, such as: Feature toggles and Branch by Abstraction.
For å kunne levere kontinuerlig er det viktig at kodebasen blir integrert kontinuerlig, dvs. at man merger til mainline minst en gang om dagen. På denne måten legger du til rette for at koden er klar for deploy oftere, det blir lettere å estimere oppgaver, og du sparer deg selv for unødvendig smerte. F.eks. "merge hell" og kode som er vanskelig/umulig å refaktorere. Noe som lett kan forekomme når en feature-branch bare blir merget tilbake til mainline etter at den er ferdig. Jeg vil derfor gå gjennom teknikker og patterns som "branch by abstraction" og "feature toggling", som gjør det lettere å kode direkte i mainline.

The adoption of good architecture governance, establishing a well functioning framework and good quality assurance procedures require years of investment in good and systematic work. But what do you do when you have limited resources and the environment calls for governance?
Å innføre god arkitekturstyring, etablere et godt ramme- og metodeverk og gode kvalitetssikringsrutiner, krever flere års investering i godt og systematisk arkitekturarbeid. Men hva gjør du når du har begrenset med ressurser og miljøet roper etter styring? Gjennom enkle virkemidler kan du øke kunnskapen i organisasjonen og få bedre dokumentasjon på arkitekturen i systemene. Du får til og med et virkningsfullt styringsverktøy for videre livssyklusplanlegging!

Learn about Java agents and the power of java.lang.instrument package. Learn how to program Java in unusual way and what kind of tricks the Java tools perform with the classes in order to provide you the state of the art.
A Java agents are pluggable self contained components that run embedded in a JVM and intercept the classloading process. They were introduced in Java 5 along with the powerful java.lang.instrument package. Java agents can be loaded statically at startup or dynamically (programmatically) at runtime to attach to a running process in a fail-safe fashion. Java agents were an awesome addition to the JVM as it opened a lot of opportunities for tool designers and changed Java tooling landscape quite drastically. In conjunction with Java bytecode manipulation libraries it is now possible to do amazing things to Java classes: we can experiment with programming models, redefine classes in runtime, record execution flow, etc. In this session I’d like to give an overview of Java agents’ functionality along with the usage examples and real world experiences. You will learn, how to implement an agent and apply Instrumentation API in combination with bytecode manipulation libraries to solve interesting tasks.

Everybody is giving cloud experience reports these days and they all talk about the same problems. Guess what, the P2P paradigm has been dealing with these problems for years. This talk gives you an introduction to P2P principles and a cool example application that lets your irc-presence last forever.
IRCPeer er ingen vanlig irc-klient. IRCPeer sørger for at du kan være online 24/7 uten at du må betale for premium hosting. Ved hjelp av enkel P2P teknologi sørger IRCPeer for at en annen bruker av IRCPeer hoster din sesjon når du ikke selv er online. Så lenge du er villig til å hoste en annens sesjon når du er online vil noen hoste din når du ikke er online. Det hele er løst ved hjelp av en DistribuertHashTable basert på Freepastry, pircbot og implementasjon i Scala.

In this talk I will show how Polyfilling can close the browser gaps and allow you to use HTML5 features today.
Som webutvikler ønsker jeg å ta i bruk nye nyttige HTML5-funksjoner i dag. Problemet er at jeg fremdeles har en del brukere med eldre nettlesere (IE6, IE7, IE8). Et annet stort problem er at støtten for nye HTML5 funksjoner fortsatt er veldig fragmentert. Jeg ønsker å bruke nye HTML5 API’er i dag. Jeg ønsker samtidig at siden min skal fungere for alle mine brukere uten spesialhåndtering for de ulike nettlesere. Jeg vil i denne lyntalen vise hvordan Polyfilling tilfører kode som normaliserer nettleser-API’ene og tilbyr den funksjonaliteten nettleserene burde støtte native.

An experience report from writing a Java backend for a multiplatform mobile application.
Lyntalen gir en erfaringsrapport fra utvikling av en Java backend som leverer tjenester til en multiplatform mobilapplikasjon. Tjeneren er bygget ved hjelp av verktøy som Jersey, JDBCTemplate og Jetty. Foredragsholderen vil raskt beskrive case og hvordan applikasjonen er implementert. Deretter vil positive og negative erfaringer bli delt med publikum. Til slutt vil alternative tilnærminger i form av bruk som rammeverk som Dropwizard (http://dropwizard.codahale.com/)bli vurdert opp mot implementert løsning.

Salesforce.com, the Social CRM in the cloud, only a few clicks away and no software or hardware to install! Isn’t salesforce.com just a point & click solution then? Where is the charm in that for a Java developer? Or the challenge? Well, what if your clients request advanced customizations to the standard salesforce.com installation? Who then is equipped for the task if not a skilled java developer as yourself? To solve these customization requirements salesforce.com has introduced their own development platform, force.com. Based on standard Java functionality it introduces flexibility as in any other Java project. Force.com with its flexibility have many advantages and opportunities, but I also see several challenges. Especially regarding quality ensurance of delivery and code, and obtain maintainable solutions. This talk will highlight some of the advantages and challenges implementing a salesforce.com solution, and sketch a solution for continuous integration that ensures quality of your tests, your code and your deployment routines
Salesforce.com, the Social CRM in the cloud, only a few clicks away and no software or hardware to install! Isn’t salesforce.com just a point & click solution then? Where is the charm in that for a Java developer? Or the challenge? Well, what if your clients request advanced customizations to the standard salesforce.com installation? Who then is equipped for the task if not a skilled java developer as yourself? To solve these customization requirements salesforce.com has introduced their own development platform, force.com. Based on standard Java functionality it introduces flexibility as in any other Java project. Force.com with its flexibility have many advantages and opportunities, but I also see several challenges. Especially regarding quality ensurance of delivery and code, and obtain maintainable solutions. This talk will highlight some of the advantages and challenges implementing a salesforce.com solution, and sketch a solution for continuous integration that ensures quality of your tests, your code and your deployment routines

How Comoyo made sure that the Norwegian football league could be viewed on the Internet. Testing a heterogeneous system mostly (but not entirely) based on Amazon EC2 resources.
Comoyo provides infrastructure for moving pictures, both movies and TV, as well as live television. On March 23, 2012, the Norwegian national soccer league started up, and we were in no way certain that we would be able to handle the load we expected all the football fans in Norway to generate. The movie delivery subsystem is mostly, but not entirely, consisting of components hosted in Amazon's Elastic Compute Cloud (EC2), and mostly (but not entirely) written in Java. In this talk we describe how we used multiple tools to generate what we believed to be realistic loads against our systems, and how we used this to tune the system to actually perform. This may seem like a simple task, but it wasn't: * The system is made of components, but the component developers were not aware of the full system architecture. * Some components thought to "just work" (such as load balancers) were discovered to be a bottleneck. Initially, we didn't even think about load balancers, since they were effectively invisible for the developers. * Writing test scripts for load testing is a skill separate from writing other types of tests, and the test tools themselves are much less well standardized or developed and much easier to use for some tasks than others. The interplay between performance monitoring tools and test tools is less than perfect, but fusing data between the two is necessary to interpret test results. * We did all of this, we learned how to harness the tools, we delivered the Tippeliga, and we did it all in just a few weeks. In this talk we share some of the hard won lessons on how to write tests, interpret their results, and how to actually tune a system for high performance.

HazelCast open-source data grid provides a simple and easy way to get started with Grid technology. This talk provides a couple ideas on how you can have fun with this, while you learn new skills about grid computing.
For mange Java applikasjoner blir databasen en flaskehals. Det har vært mye fokus på skalering ved hjelp av alternative databaseteknologier (Big Table, Document database, NoSQL etc.). Hvorfor ikke ta steget helt ut og kutte ut databasen for prosessering? Flytt databasen til minne og opplev dramatiske ytelsesforbedringer langt utover bytte av databaseteknologi. Denne lyntalen er ment å vise hvor enkelt er å utvikle slike løsninger med open-source gridløsnigen HazelCast. Lyntalen vil vise hvordan man skriver og leser til et grid. Samt hva som skjer når lasten øker og "hardwaren" svikter.

Learn about G1, the next big thing in garbage collection, about the inner workings of a modern JVM and how you can tune your JVM for optimal GC performance. See what problems Mark-And-Sweeps solves, what limits there are, and where G1 takes over when Java system goes from large to huge.
With Java systems getting larger and larger, using more and more heap, just raising the max heap size will no longer save you from long GC pauses. Concurrent Mark-And-Sweep has been the solution for a long time, but as heaps grows beyond a couple of giga bytes in size, Mark-And-Sweep GC pauses will grow beyond levels acceptable in modern Java systems. This presentation takes us through the inner workings of a modern JVM and how you can tune your JVM for optimal GC performance. The problems we're facing with ever growing heap sizes will be explained, together with how Mark And Sweep garbage collector does garbage collection today, what limits there are, and how the G1 (Garbage First) garbage collector will take over tomorrow, when Java heaps goes from large to huge.

The talk will get you into the existing spring-based ecommerce middleware setup of the Otto Group, describe the aspects that led to the refactoring project and present the approach followed to identify and prioritize requirements. You will get an understanding on how the project operated in a very unique context of various companies
In 2010 the world’s 2nd largest web retailer (b2c) – the Hamburg-based Otto Group – decided to refactor large parts of its existing multi-tenancy middleware and backend landscape from a classical 3-tier layout towards a service oriented architecture. The aim of this project is to support the upcoming challenges imposed by the global growth strategy which includes the promising BRIC nations. The latter will cause a significant increase of traffic driven to the 50+ web shops operated by the Otto Group companies. Additionally the new platform will support the companies in utilizing the large amount of data (traffic, user tracking, orders …) being collected during runtime much better than today. The talk will get you into the existing Spring 2.x-based setup, describe the aspects that led to the refactoring project and present the approach followed to identify and prioritize requirements. You will get an understanding on how the project operated in a very unique context of various companies having different requirements with respect to their business goals. Finally you will be presented the high-level architecture and how it is supposed to support the future ecommerce strategy of the Otto Group using technologies like JEE 6, Glassfish v3.x, ESB, messaging, CRM/ERP integration and caches. For more company information please visit: http://goo.gl/9YICz and http://goo.gl/6vfuF

How do we secure REST-based services? What mechanisms are available and what are the pitfalls we need to avoid?
Mens sikkerhetsmekanismer i SOAP-baserte tjenester er veldefinerte, finnes det mange forskjellige måter å sikre REST-tjenester på. Vi ser på hva som er viktig når man skal sikre REST-tjenester, og hvilke feil man bør unngå. Vi går gjennom noen av løsningene som benyttes av større aktører og ser hvordan disse beskytter tjenestene.

Native mobile applications or not ? I'll try to discuss some of the choices we made while developing a mobile application for Oslo County. We chose to go with native apps, and I'll tell you why.
Bør jeg bruke MEAP i mitt mobilprosjekt, eller bør vi skrive appene native? Ønsker å dele noen erfaringer og tanker som ble gjort i forkant av et mobilprosjekt levert på Android, iPhone og Windows Phone 7. Vi valgte å gå for native apper, jeg forteller hvorfor.

Learn how Comoyo use MongoDB on Amazon EC2 to build a solution for storing large data with high availability and scalability, without sacrificing reliability.
Many developers are discovering that traditional relational databases make it hard to scale to the large data volumes and user traffic required by Internet-scale applications. MongoDB is sailing up as one of the leading contenders in the NoSQL space. We at Comoyo are using MongoDB on Amazon Elastic Cloud Compute (EC2) for our payment subsystems, with a target of some hundred millions users regularly accessing the system. As we are handling financial transactions with high demands on reliability, we needed to make sure that MongoDB did not sacrifice our customers' safety on the altar of performance. This talk presents how we use MongoDB to gain higher availability and scalability than traditional databases, with simpler development and administration, without losing the required reliability and durability. The talk describes how we configured replication, and our approach to work around the lack of transactions in MongoDB. There will be pointers on tuning MongoDB for availability and reliability. Also, the talk will describe how we used MongoDB to implement once-and-only-once messaging semantics on top of Amazon Simple Queuing Service (SQS).

A lightning talk about common pitfalls and misconceptions concerning scope, context and visibility of variables in JavaScript. A little heads up for the people that is starting to embrace hipster-language numero dos. There will be mustasches!
I mange miljøer oppleves barter og skjegg som mer mandig enn det å være glattbabert. Du var kanskje ikke klar over det, men det er grunnen til at alle kule programmeringsspråk tar i bruk barteparenteser. Barter har derimot ikke alltid den effekten en tror de har. Selv ble jeg overrasket både av responsen jeg fikk av min egen bart i November, og den jeg fikk når jeg tok i bruk barter i JavaScript. Hvem hadde trodd at en enkel bart kunne være så forskjellig? Dette er varskolyntalen for deg som har begynt å snuse på hipsterspråk numero dos, JavaScript. Har du enda ikke rukket å sette deg inn i scope, kontekst og variabelsynlighet? Ta det med ro, her får du de grunnleggende reglene som gjør JavaScript litt mer begripelig i starten. Og hvis du lurte… jada, det er forskjellig fra Java.

Learn how to overcome the barrier of starting Test-Driven Development (TDD) on legacy code, and how to keep doing TDD even if other team memebers won't.
Er du en av de som sier "Jeg skulle gjerne drevet med testdrevet utvikling..." * "men de andre utviklerne på prosjektet driver ikke med TDD, og derfor blir ikke koden testbar" * "men det er legacy kode vi jobber med, så TDD blir umulig" så er denne lyntalen for deg! Du vil få se hvordan man fint kan drive med TDD på såkalt utestbar legacy kode, via konkrete Javakode-eksempler som du kan ta med tilbake til kontoret på mandag og innføre i din egen kode. Se teknikker for hvor man starter, og se at du _ikke_ trenger å kjøpe mock-rammeverk for testing av private eller statiske metoder. Bli sjefen over din egen kode, lær praktiske teknikker for å få inn enhetstestene på plasser der du trodde du måtte gi opp!

Neo4j is the world’s leading graph database. Its expressive data model makes it ideal for managing complex, densely connected data. In this session you’ll learn how to use Noe4j to create and query data belonging to the complex history of Doctor Who, the world’s oldest sci-fi tv show.
Doctor Who is the world’s longest running science-fiction TV series. Battling daleks, cybermen and sontarans, and always accompanied by his trusted human companions, the last Timelord has saved earth from destruction more times than you’ve failed the build. Neo4j is the world’s leading open source graph database. Designed to interrogate densely connected data with lightning speed, it lets you traverse millions of nodes in a fraction of the time it takes to run a multi-join SQL query. When these two meet, the result is an entertaining introduction to the complex history of a complex hero, and a rapid survey of the elegant APIs of a delightfully simple graph database. Armed only with a data store packed full of geeky Doctor Who facts, by the end of this session we’ll have you tracking down pieces of memorabilia from a show that, like the graph theory behind Neo4j, is older than Codd's relational model.

Browser based application often need regression testing to ensure high quality and customer satisfaction. We share experience in using tools and methods for making easily maintainable automatic GUI-tests. Central topics are Selenium 2, WebDriver and the page object pattern.
Regresjonstesting av browser-baserte applikasjoner tar mye tid, men er viktig for å opprettholde god kvalitet ved videreutvikling. Automatisering av slike tester er alltid et ønske, men det er ikke lett å få testene lett vedlikeholdbare og robuste. Ofte blir testene lett utdaterte og til mer frustrasjon enn en hjelp. I lyn-talen deles erfaringer om fallgruver som oppstår ved innføring av slike automatiske tester. Som en del av erfaringene gjennomgås verktøy og metoder vi har benyttet for å unngå eller motvirke disse effektene. Fallgruvene er ofte tekniske men fører gjerne til andre utfordringer som mangel på motivasjon og "eierskap" i teamet. Noen sentrale tema er Selenium 2, WebDriver og page-object pattern.

PhoneGap is an HTML5 app platform that allows you to write native applications with web technologies and get access to APIs and app stores. PhoneGap uses web technologies like HTML, JS and CSS to bridge the gap between native and web applications.
Har du lenge sittet med en idè til en knallbra mobilapplikasjon, men har ikke kommet i gang fordi du må lære deg Java eller Objective-C eller C# for å utvikle en native app? Eller har du kanskje utviklet en webapp som du syns mangler litt native funksjonalitet? Da er PhoneGap løsningen for deg. Med PhoneGap utvikler man hybride applikasjoner som består av webteknologier som HTML5, JS og CSS3 og man bygger en app som er mulig å deploye til hele 7 ulike plattformer. PhoneGap er laget for å bygge broer.

Ever seen technical drawings you just couldn't make any sense of, even though you know very well what they were supposed to show? Sometimes a picture is worth a thousand words, but sometimes a thousand words can't repair the damage done by a bad drawing.
Ever seen technical drawings you just couldn't make any sense of, even though you know very well what they were supposed to show? Sometimes a picture is worth a thousand words, but sometimes a thousand words can't repair the damage done by a bad drawing. Why do some drawings communicate directly and simply while others just look like a thrown-together set of boxes and lines? Perhaps the first rule in improving technical drawings is to care. Next, consider the message, purpose and audience for a picture. Next, which details make a drawing convincing and which stand in the way of reading? Whether it's a nice font, balanced colours or straight lines, these details make a difference. And finally, practice. Practice a lot. It is difficult to produce a perfect drawing, whether drawn freehand or with a tool, but there is always scope for better.

AndEngine is an open source project for developing 2D android games. This lightning talk will give you a short introduction, and tell you how to work with the most common classes.
AndEngine er et opensource rammeverk for å utvikle 2D spill til Android. Det tilbyr et forenklet API til openGL og det kan enkelt knyttes til Box2D for å impl. fysikk. Denne lyntalen vil presentere hvordan man kommer i gang med versjon GLES2, som benytter seg av OpenGL ES 2.0.

An insight into how to adapt Scala-libraries (or similar) into Java.
Bruk av Java fra Scala er enkelt fordi at Scala har vært byggd utfra den forutsetning at Scala må bruke Java-funksjonalitet. Det samme gjelder andre språk som Groovy og JRuby. Hva om du trenger funksjonaliteten den andre veien? Om du har et Scala-bibliotek du svært gjerne ønsker å bruke. Hva er da riktig vei å gå fram?

Learn how to use Hazelcast to solve problems involving big data and high performance on computations. See examples of how this technology can be used to speed up Norwegian tax calculations!
De siste årene har det blitt mer og mer fokus på behandling av store datamengder og ytelse. Grid-produkter kan tilby et spennende alternativ til den tradisjonelle databasen, gjennom at mange maskiner jobber sammen med å holde data i et distribuert minne. Dette gir egenskaper som tilnærmet lineær skalering og ekstremt høy ytelse. Denne presentasjonen viser Open Source produktet Hazelcast. Med eksempler viser vi hvordan produktet fungerer, og går gjennom erfaringer vi har hatt med produktet det siste året. Eksemplene taes hovedsaklig fra Skatteetaten hvor produktet har blitt testet ut for områder som datainnsamling og skatteberegning.

Are you wondering if Apache Wicket is the right tool for larger projects? In this experience based talk we will give concrete advice for what to do and what not to do.
Leter du etter et bedre komponentbasert webrammeverk? Vil du lage brukervennlige nettsider, men misliker å skrive JavaScript? Ønsker du å skille presentasjon og logikk? Da har du kanskje vurdert Wicket, som kan friste med Java-sentrisk programmeringsmodell og lite XML. Kanskje har du skrevet noen enkle applikasjoner allerede, men tør du bruke Wicket til ditt neste store prosjekt? I dette foredraget deler vi våre erfaringer med Wicket. Vi forteller deg det dokumentasjonen ikke forteller, og det som blogg-eksempler og minimale demo-applikasjoner ikke tar hensyn til. Vi gir deg eksempler på arkitekturprinsipper som fungerer, og forteller om noen som ikke har fungert. Temaene er: * GUI-arkitektur i en voksende kodebase. Hvordan dra nytte av Wicket sin egen arkitektur? Hvordan strukturere når AJAX er faretruende enkelt? * Vedlikeholdbarhet i koden. Er du generelt bekymret for Wicket sin læringskurve? * Modeller og sesjonsstørrelse. Vi fulgte råd fra artikler og diverse blogger, og brukte en kombinasjon av Hibernate, Open Session In View og Wicket sin LoadableDetachableModel. Når vi så la på mer og mer funksjonalitet, ble koden veldig komplisert. Vi tok da grep, og forteller hvordan vi trives med en løsning som er stikk i strid med hva som anbefales! * Testing og verktøystøtte. Større (og mindre...) prosjekter trenger testing og verktøy Temaene illustreres ved hjelp av reelle kodeeksempler. Vi setter Wicket i en bredere kontekst, og sammenlikner raskt med andre komponentbaserte rammeverk som GWT og JSF. Vurderer du Wicket til ditt neste prosjekt, eller har du begynt å høste erfaringer? Da er dette foredraget for deg!

You're all over jQuery - you write plugins in your sleep - and before that, you were a Prototype ninja. Your team treats JavaScript like a first class citizen, you've even written more tests than Kent Beck. Is that all there is in the land of the JavaScript developer? Believe it or not, the JavaScript party hasn't stopped. What other libraries are out there? What do they offer? This talk will survey the field of modern JavaScript libraries getting you up to speed on what's new. We'll dive in just deep enough to whet your appetite on a wide variety of libraries such as Backbone, Underscore, Zepto and more.
You're all over jQuery - you write plugins in your sleep - and before that, you were a Prototype ninja. Your team treats JavaScript like a first class citizen, you've even written more tests than Kent Beck. Is that all there is in the land of the JavaScript developer? Believe it or not, the JavaScript party hasn't stopped. What other libraries are out there? What do they offer? This talk will survey the field of modern JavaScript libraries getting you up to speed on what's new. We'll dive in just deep enough to whet your appetite on a wide variety of libraries such as Backbone, Underscore, Zepto and more.

Overview of the rising web APIs world, a disruption as important as open source for Web developers. Lastest version 2.1 of the open source Restlet Framework will be presented, as well as APISpark an innovative PaaS for RESTful web APIs based on Restlet.
The impressive rise of open web APIs disrupts the way we develop on the Web, in a way probably as important as open source. We will explain what is a web API, walk through the most striking ones listed below, explain their key success factors and present the main solutions to create, host and manage them: - Twitter Streaming API with its OAuth autentication and mandatory usage of SSL - CouchDB for its live JSON based notification API - Twilio API for its business model, its ability to control real-world telecom services and its comprehensive and versionned documentation - Google Maps Image APIs for support of non XML/JSON representations - Amazon DynamoDB API for an example of non-RESTful web API but pragmatic and nonetheless useful, an will think about a RESTful rewrite We will also explain in more detail how to develop a RESTful web API in Java thanks to Reslet Framework, the first open source project to offer a REST toolkit in 2005, that releases its 2.1 version along with the "Restlet in Action" book published by Manning. In the end, we will introduce APISpark, an innovative all-in-one cloud platform (PaaS) for web APIs, based on Restlet Framework that lets you create and host RESTful web APIs in just a couple of minutes.

Do you dream of becoming a Java community hero? Or would you like to help organize the JavaZone conference? This lightning talk gives a quick introduction to the javaBin organization and how you can join and contribute.
Har du lyst å være med å arrangere JavaZone? Eller kanskje bli en aktiv javaBin-er? Det norske Java-fagmiljøet består av en haug med kreative entusiaster som gjerne vil ha med akkurat deg i miljøet! Denne lyntalen gir en introduksjon til hvem vi er, hva vi gjør og hvordan du kan bli med.

There is a saying that "the road to hell is paved with good intentions". This is especially true when it comes to testdata and reuse. The greatest pain is often caused by testdata in sql-insert-scripts. This lightning talk will be about how we can avoid that pain by looking at the alternatives and being smart about reuse.
Vi har vel alle gjort det, vi trenger testdata kjapt og legger det i sql scripts. Det er ingenting galt i det, men det er en løsning som ofte ikke skalerer med et domene som utvikles over tid. Til slutt befinner du deg et sted du ikke vil være. Denne lyntalen vil presentere smerten med sql-insert-scripts i daglig utvikling, og veien tilbake til et smertefritt testdataoppsett.

Why do we use process engines? I´ve been working on a couple of projects utilizing two different process engines (jBPM and Documentum), and I´ve seen the shortcuts and work-arounds being made in order to cope with the limitations. In this speech I will highlight the pros and cons of process engines, based on the experiences made from these projects.
Når trenger vi prosessmotor? Etter å ha jobbet en del med to ulike prosessmotorer (jBPM og Documentum) er jeg fortsatt usikker på dette. Jeg har sett man ta mange snarveier, bygge egne tekniske løsninger rundt prosessmotoren og til slutt ende med å bruke minimalt av det motoren leverer. Hvorfor blir det slik? I lyntalen ønsker jeg å dele erfaringene fra arbeidet og belyse styrker og svakheter til prosessmotorer basert på erfaringene for disse to motorene spesifikt.

Clojure is a beautiful language. However most Java devs fail to see its beauty because of "all those pesky parentheses". They complain about foreign syntax, however Lisp arguably has no syntax. This talk will show you why that is!
Clojure er et fantastisk programmeringsspråk, men det er en Lisp. Det har en helt annen bakgrunn enn alle de mer kjente C inspirerte språkene, som Java. Mange Java utviklere har problemer med syntaksen til Lisp, alle parentesene... Denne lyntalen vil vise deg hvorfor denne syntaksen både er enkel og ekstremt kraftig. Man kan faktisk argumentere for at Lisp ikke har noen syntaks!

This lightningtalk will give you advice helping you avoid some of the most frustrating mistakes possible to make when developing for Android
Er du erfaren javautvikler som skal lage din første Android-applikasjon? Da har du mye moro foran deg, men også mange overraskelser og frustrasjoner. Du vil sannsynligvis bruke mye tid på å feilsøke fordi SDK eller runtime i mange tilfeller ikke sier fra om hvor feilen ligger. Du blir i tillegg tvunget til å skrive kode som for erfarne java-utviklere er uvant, og det er lett å få uoversiklig kode dersom du ikke benytter deg av enkle hjelpemidler. I denne lyntalen deler jeg noen av mine erfaringer med utvikling for Android og gir deg 5 tips som vil gjøre din første erfaring med utvikling for Android mer positiv enn min.

We present empirical results that show how relative estimation may result in biased assessments of similarity and over-optimistic effort estimates. We observe that tasks tend to be assessed as more similar than they are in reality when compared with each other, that the similarity of two tasks depends on the direction of the comparison and that it matters whether the comparison is based on difference in work-hours or as the ratio. We use these observations and other evidence to suggest ways of improving the accuracy of relative estimation as it is done in, for example, agile projects.
Most human judgment includes comparisons of a target object with one or more reference objects. Comparisons are known to sometimes lead to judgment biases. We perceive the moon as larger the closer it gets to the horizon. We feel water at room temperature is warmer if our hand was submerged in cold water just before. We estimate things are smaller than they really are when we compare them with smaller objects and larger than they really are when we compare them with larger objects. Software development effort estimation is also frequently based on comparing the effort of one task relative to that of another. We present empirical results that show how relative estimation may result in biased assessments of similarity and over-optimistic effort estimates. We observe that tasks tend to be assessed as more similar than they are in reality when compared with each other, that the similarity of two tasks depends on the direction of the comparison and that it matters whether the comparison is based on difference in work-hours or as the ratio. We also observe that the use of the Fibonacci-scale for agile estimation sometimes has unwanted side-effects which may lead to under-estimation of tasks. We use these observations and other evidence to suggest ways of improving the accuracy of relative estimation as it is done in, for example, agile projects.

The HTTP specification details how caching of HTTP Responses may be done. In this talk I will outline the possibilities and restrictions the specification mandates. I will also show how Edge-Side includes(ESI) and Cache Channels will benefit caching.
Har du noensinne lurt på hvordan HTTP caching fungerer? I dette foredraget vil jeg fortelle om hvordan spesifikasjonen sier at det skal fungere. Jeg vil gi eksempler og se hvordan de forskjellige cache-reglene oppfører seg. Her vil det også vises noen "Gotchas". Jeg vil også se på utvidelser til HTTP, herunder Cache Channels, og Edge Side Includes (ESI).

Sindre gives you a crash course in Ruby Metaprogramming, showing you techniques that will keep you, the developer, joyful and your code DRY.
Ruby har et imponerende arsenal av metaprogrammeringsteknikker som kan gjøre hverdagen til en programmerer mye enklere og bidra til å holde koden din DRY. Dette er kjapp introduksjon til flere av disse, med eksempler på hvordan disse kan hjelpe til i hverdagen. Lyntaleren viser eksempler fra egne prosjekter for å illustrere hvor enkelt metaprogrammering i Ruby er å benytte seg av og hvilke fordeler det kan bære med seg.

Kravmaga - combat techniques for survival in the enterprise getto. This presentation is about requirements. We will show a set of techniques to write better requirements and ultimately better software in realistic scenarios.
Hvordan jobbe med krav når du ikke vet hva du vil ha? Vi tar alt for lett på krav, kanskje fordi krav er fryktelig vanskelig, og det er lettvint å bare godta en spesifikasjon fra kunden. For kunden har jo alltid rett, ikke sant? Vårt fokus er på vår rolle som utviklere. Vi er glade i å programmere, og liker å dykke inn i tekniske problemstillinger. I dette foredraget ønsker vi å vise hvordan man så tidlig som mulig kan sette opp en feedback sløyfe mellom reelle tekniske ting og kundens behov. Og vise hvordan vi som programmerere kan bidra effektivt til dette ved tidlig prototyping. Vi har valgt å bruke ruby og cucumber til dette, fordi vi føler det er spesielt gode verktøy til hurtig prototyping. Målet er å basere kommunikasjon med kunde og andre stakeholdere på et veldefinert språk og med tydelige forretningsregler, og tidlig være i stand til å teste ut teknologiske og forretningsmessige antagelser.

Traditional relation databases may work fine for small data sets. With larger data sets, performance may become an issue. For a telecom company such as Telenor, the issue became a real problem. This is the story about how usage of denormalized indexed data and a graph database solved the problem for Telenor.
Telenor calculated in 2010 that it´s self-service web solution for businesses & enterprises, MinBedrift, would not scale with the projected customer growth beyond 2012. In order to achieve acceptable user response times, the current solution was dependent of nightly pre-caching the customers’ data. However, the time available for caching was closing fast, and then response times would become increasingly longer. In the end Telenor would start losing customers. This is the story about how usage of NoSQL solutions such as Lucene/Solr index & Neo4j graph database solved the problem, and then some more.

Gain a deep understanding of how hardware caches work, how to write programs to best use them, what the future holds and how that will change the way we write programs.
Caches are used in many layers of applications that we develop today, holding data inside or outside of your runtime environment, or even distributed across multiple platforms in data fabrics. However, considerable performance gains can often be realized by configuring the deployment platform/environment and coding your application to take advantage of the properties of CPU caches. In this talk, we will explore what CPU caches are, how they work and how to measure your JVM-based application data usage to utilize them for maximum efficiency. We will discuss the future of CPU caches in a many-core world, as well as advancements that will soon arrive such as HP's Memristor.

Self explaining method names, fluent interfaces, DSLs, helpful frameworks... We are always looking for ways to make our code more readable. But in our quest, we seem to have forgotten something. The most effective way to make any code more readable. I wish to demonstrate this long lost secret.
Self explaining method names, fluent interfaces, DSLs, helpful frameworks... We are always looking for ways to make our code more readable. But in our quest, we seem to have forgotten something. The most effective way to make any code more readable. I wish to demonstrate this long lost secret.

FedEx packages go through a tracked, automated process that has proven highly successful - but what about software? We’ll analyze continuous delivery practices that are fully-automated & transparent, and we'll show how to “fedex” your commits to production on application servers like JBoss, Tomcat, Weblogic and others using Jenkins and LiveRebel.
When you send a package through FedEx it goes through a tracked, automated process that makes sure that the package arrives promptly at the destination. The same should apply to every commit that you check into the trunk. Continuous delivery describes how this process can be made fully automated and transparent and we will show you how your commits can be “fedexed” to production on application servers like JBoss, Tomcat, Weblogic and others with the help from Jenkins and LiveRebel. The main idea of continuous delivery is the deployment pipeline. Every commit that enters the pipeline should go through automated integration and testing and if successful, produce a release candidate. We will show how Jenkins can be used to orchestrate the process all the way to the staging environment. Once we're there, the most complicated phase begins. The release candidate needs to be deployed to production, without disrupting the users or introducing risks. LiveRebel makes production updates quick, automated, non-disruptive and reversible. It finishes the job and delivers the updated version right into the users hands. In this talk we will build a full clustered environment and a deployment pipeline so that commits into the trunk would update a live chat server while you keep on chatting.

Why is maintenance challenging? The three main areas that will be covered are: * Maintaining the backlogg * Testing * Version control
Why is maintenance challenging? The three main areas that will be covered are: * Maintaining the backlogg * Testing * Version control

How to avoid relational database performance problems, and what to look for if you already have them.
Svært mange utviklere har opplevd å få ytelsesproblemer på en databaseserver etter at den er satt i produksjon. Her får du tips om hvordan å angripe problemet. En peptalk om databasedesign, tuning, indekser, monitorering, execution plans og viktigheten av å vite hvordan å bruke databasen som verktøy.

The power of objects is greatly underestimated. Isolated objects aren’t interesting. Class-based programs limit us to reason about isolated objects. The essence of object orientation is that objects interact to achieve a common goal. The talk extends traditional OO to give the programmer mastery of multi-object interaction.
Nygaard and Dahl invented Simula’s classes and objects to master complex problems. Alan Kay coined the term ‘object orientation’ with its networks of communicating objects to facilitate simple and powerful mental models. His goal was to make computers and programming comprehensible to everybody. Mainstream programmers missed the importance of communication in Kay’s OO and misused the term. Their much weaker approach is better called ‘class orientation’. I have extended Kay’s original OO with explicit concepts and code that specify how objects interact at runtime. With the DCI (Data-Context-Interaction) paradigm, programmers can reason about their code, new team members get quickly up to speed, maintainers lead a better and more productive life. The DCI Context is a new abstraction that supplements the commen class. While a class says everything about the inside of an object and nothing about the objects surrounding it, a DCI Context says everything about a network of communicating objects and nothing about their insides. The class is great for describing autonomous objects such as the domain objects in the Data part of DCI. The DCI Context is great for describing how use cases are realized by networks of communicating objects. Communication is now a first-class citizen of programming!

The development landscape is changing rapidly. Learn what this means for you and how you can cope using Grails.
It's an interesting time in the world of application development. We're in the middle of a perfect storm in which cloud deployments, alternative data stores, and rich, multi-device client UIs are emerging as the future standards. What does this mean for Grails developers and what does the framework offer in this very different world? We'll look at potential changes to the way applications are designed and how you can leverage the current and future features of Grails to take advantage of those changes. Find out how conventions and the plugin system can smooth your way to future architectures.

Introducing NoSQL and Cassandra and using it to implement a set of Big Data use cases for enterprise applications.
Big Data is a fast growing trend in enterprise applications that comes with a novel promise compare to past technological revolutions: being able to retrieve and manipulate as much data as necessary to bring up new use cases or to improve the user experience. This is made possible thanks to a set of new technologies and databases that are designed to handle any scale. This presentation will use one of them, Cassandra, to implement several use cases that follow the big data approach described previously: real-time analytic, storing a click stream or a news feed, and more...

I'll give an introduction and high-level semantics of C# 5.0's new support for asynchronous programming, asynchronous methods with embedded await expressions.
This talk will present the new language support for asynchronous programming available in the upcoming version of C#, C# 5.0. Writing distributed or even just IO-intensive applications that are responsive yet frugal with resources is a difficult task. With the rise of web programming this has become a common problem. The solution lies in adopting asynchronous operations that separate issuing a request from awaiting its completion. While it has always been possible to program asynchronously in C# it has never been easy. The challenge is that asynchronous operations rely on callbacks, forcing the programmer to cede control. This inversion of control-flow impedes the use of structured control constructs, the staple of sequential code. The new asynchronous methods available in C# 5.0 enable straigthforward asynchronous and concurrent programming using structured control constructs. I'll start with an informal introduction to the basic feature, its inherent support for concurrency, and its built-in extension points. If time permits, I'll sketch a high-level operational semantics designed to explain the feature without resorting to sample compiler output, the lower-level description contained in Microsoft's draft specification.

When a team consist of two persons coordination and cooperation should not need a framework. Still, SCRUM provides tools for planning and watching progress that are useful.
Når et team består av to personer er ikke lenger hele SCRUM-rammeverket nødvendig, ei heller fornuftig. Lyntalen tar for seg noen av de viktigste delene av SCRUM og hvordan disse kan benyttes, til sist kommer en oppsummering av hvordan SCRUM fungerer for et topersonsteam.

While memory management is free in Java, some ways are still better than others of how to make use of it... and to measure how much your object actually do use!
RAM prices have plummeted and servers with tens or even hundreds of Gigabytes of memory have become common these days. What this means to your application's architecture and deployment topology is important. On heap caching of data within enterprise application is a common example. Yet how do you make the best use of all that memory ? Since version 2.5, Ehcache comes with the ability to size your caches in bytes rather that in entry counts. Nothing really fancy, if it wasn't for Java's lack of sizeOf function. This presentation will take you, with code, through the journey of implementing the sizeOf library for the Java platform; across multiple versions, vendors and all their permutations (including 32 vs. 64 bit platforms, CMS, Compressed OOPS, ...). The library also led us to offer new & much more dynamic ways of making use of that memory for on-heap caches within your application...

Soccer Oriented Architecture is in everything that involves software development. It's not only methodologically, but also in sense of what platform we choose and how we choose to combine technologies. Soccer Oriented Architecture is not about building a team of superstars, but rather it's about combining team players that work together as a team.
Min erfaring som både Java og .NET utvikler tilsier at forståelse for fotball er grunnleggende for alle systemutviklingsplattformer. Jeg vil ta dere med på en fotballkamp mellom de to overnevnte erkerivalene. Hjemmelaget (i rødt) stiller med stjerner som Spring, Hibernate og Eclipse. Bortelaget vil bestå av talenter som MS Forms og Visual Studio. Jeg skal analysere spillestill(utviklingsmetodikk) og foramasjon (MVC) og peke på sterke og svake sider ved spillerne og dere respektive trenere. Det vil også åpnes opp for spillerkjøp.

This session will teach you how to deploy and scale Java, Play! and Scala apps on Heroku.
Heroku is a Polyglot Cloud Application Platform that makes it easy to deploy Java, Play! and Scala apps on the cloud. Deployment is as simple as doing a "git push". This session will teach you how to deploy and scale Java, Play! and Scala apps on Heroku.

There are many advantages to using a functional style in your programs. Learn what can be done to leverage functional style while retaining many of the productivity gains of the Groovy programming language.
Groovy doesn't claim to be a fully-fledged functional programming language but it does provide the Java or Groovy developer with a whole toolbox of features for doing functional style programs. This talk looks at the key Groovy features which support a functional style. Topics covered include using closures, currying and partial evaluation, closure composition, useful functional-centric AST macros, useful functional-centric runtime meta-programming tricks, trampolining, using Java functional libraries, immutable data structures, lazy and infinite lists, using Groovy 2's static typing and approaches for moving beyond Java's type system.

TBA
In the words of John Gage, "The network is the computer". At the heart of everything we do is a complex system of infrastructure from which we are often abstracted. For general application development this abstraction provides the convenience of simplifying our efforts. With a growing number of mobil applications with intermittent connectivity and higher latency, and with increased hostility on the network from a security standpoint, there is great value in pulling back the curtain and understanding the details of this computer. This session will start with the underlying understanding of networking at a low level. At this level we will discuss, IP, MAC, ARP, DNS and DHCP. As we walk up an abstraction level, we discuss sockets, NAT, gateways and firewalls along with the use of TCP and UDP. Spending some time at this layer can make network developers more productive, as we look at tools which help us answer the question, "who owns this port?", "where is this packet going?" and "What is my latency and why?". The session will end with a little fun looking at wifi, where will we sniff, snort, crack:) From a security stand point we will look at the challenges of wifi and how it has become the weakest component on the net. This session is extremely fast-pace. The attendees will come away with a more enhanced understanding of the this thing we call the internet. It will include through discussion or demonstration tools such as tcproute, tcpdump, nemesis, nmap, tcpmon and wireshark.

Football referees, hung out to dry by journalists, ridiculed by the public, accused of taking bribes and speculation of a traumatic childhood. They are by no means popular figures, but is it really fair to subject them to an Internet Explorer only web portal? This presentation shows how a new front-end was built for an internet explorer-only website. Through screen scraping and some cool tools, building a new front end can be done in a few nights without getting access to the webapp’s database or a public API.
Utskjelt og uthengt, beskylt for bestikkelser og spekulasjoner om en traumatisk barndom som mobbeoffer. Trakassert av Davy Wathne i beste sendetid. Fotballdommere utsettes for mye, men er det virkelig nødvendig å utsette dem for en webportal utviklet i Microsoft Visual Studio 2003 som kun fungerer i Internet Explorer? Er du litt lei av å skrive den samme koden dag ut og dag inn? Du er produktiv og får jobben gjort med Java og diverse open source rammeverk, men du savner den deilige følelsen av læring. Det å ha det skikkelig gøy mens du lærer nye ting? Du vet, den følelsen du hadde mens du studerte? Pet projects/hobbyprosjekter er mange utvikleres løsning på dette, men det er ikke alltid så lett å finne et problem du kan bruke som utgangspunkt for å lære noe nytt. Mange ganger tenkte jeg at "kanskje jeg skal lage noe som konsumerer et REST-API", men hvor mange twitter/facebook/<sett inn siste hippe socmed her> mashups trenger egentlig verden? Det finnes allerede mange gode der ute, og det er kanskje ikke så rart, for dataene til alle disse sosiale mediene er så lett tilgjengelig. Men hva med alle disse irriterende webappene, du vet, disse som ikke fungerer i annet en internet exploder og som hvertfall ikke har et åpent API? Hva med dem? Dette var utgangspunktet for _mitt_ hobbyprosjekt. Et hobbyprosjekt som har vokst til å ha over hundre unike brukere om dagen, og over 350 unike brukere i uken. Dette er historien om Dommer-FIKS: Presentasjonen vil vise hvordan Scala, Unfiltered, JSoup, Twitter Bootstrap og Heroku ble brukt for å utvikle en ny frontend for Internet Explorer-utyske på tre-fire kvelder. Løsningen ble laget uten å ha spesielt stor kjennskap til noen av teknologiene fra før. Målet med presentasjonen er ikke å gi en deltaljert intro til hverken Scala, Unfiltered eller Bootstrap. Den vil derimot forklare hvordan de valgte teknologiene alle bidro til at en ny frontend kunne skrives på noen få dager av en som knapt nok har hørt om CSS og Javascript. Den vil vise hvordan du kan få morroa tilbake i utviklingen og vil gi en rekke dommeranekdoter underveis..

The Agile Manifesto Principles need updating, badly! They are code focussed, and are not explicit enough about delivering real stakeholder value to all critical stakeholders! We suggest 10 entirely new agile principles.
The Agile Manifesto has its heart in the right place, We are only worried about its ‘mind’. And its first principle “Our highest priority is to satisfy the customer through early and continuous delivery of valuable software”, is central to the ideas in this paper. Our problem with agile is not in its ideals, but in the everyday teaching and practices we see. What has happened, is the same problem afflicting all software and IT projects, long before agile appeared. Our technocratic culture has forgotten our stakeholders and their values. The practices are far too ‘programmer centric’, and far too little ‘stakeholder value’ centric. The result is that ‘working software’ is delivered to a ‘customer’. But, necessary values are not necessarily, and all too rarely, delivered to all critical stakeholders. Code has no value in itself. We can deliver bug free code, that has little or none of the anticipated value. We can deliver software function, as defined in requirements, to the ‘customer’ – but totally fail to deliver critical value to many critical stakeholders. We fear this paper may not correct the narrow-mindedness of the coder community, and our principles do apply to a higher level of thinking than coding; but we are going to try to formulate a much clearer set of principles, a more explicit set; and in the subsequent paper, clearer ‘values’ than the Agilistas managed to do. We have one decided advantage – We are not subject to lowest common denominator politics – as they were – We can express our own opinion – unopposed!

This session is an experience report from a grid-architecture proof-of-concept at Skatteetaten (Norwegian Tax Office), aiming for increased maintainability, decreased lifecycle cost and linear scalability. The presentation focuses on the simplicity and testability of the programming model, as well as the challenges to consider for a grid application.
Skatteetaten har kjørt en proof-of-concept (PoC) for å vurdere grid-plattform som en del av det framtidige målbildet. Formålet er primært forbedret endringsevne og vesentlig reduserte forvaltningskostnader; sekundært massiv parallellprosessering. Denne sesjonen tar for seg grid-plattformens sentrale egenskaper og hvilke problemstillinger en grid-applikasjon må håndtere, med eksempler og erfaringer fra PoCen. Spesielt ser vi på hvordan programmeringsmodellen og plattformen tilbyr ekstrem enkelhet og ypperlig testbarhet. Samtidig må man være særlig oppmerksom på områder som aggregat-design, serialisering, versjonering og robusthet. Vi viser også hvordan man kan oppnå lineær skalerbarhet med parallellisert, minnebasert prosessering, inkludert en demo av realistisk skatteberegning fra PoCen.

Come join a fun talk as we explore the best and worst of web APIs. We'll see what makes an API great - and what makes it awful. From data formats to documentation to authentication - there's a lot to learn whether you're building the next Facebook API or you're building a small on-premise application.
APIs have seen dramatic growth in the last few years, and they're now powering everything we do. This is causing a fundamental shift in how we write applications - it's not just a UI and a database anymore. This makes good APIs even more important than ever. Come join a fun talk as we explore the best and worst of web APIs. We'll see what makes an API great - and what makes it awful. From data formats to documentation to authentication - there's a lot to learn whether you're building the next Facebook API or you're building a small on-premise application.

Visualize your git repository with simple command line tools an javascript graph libraries.
GIT gir deg massevis av historikk for kildekoden din, men har du noen gang brukt all historikken til noe nyttig? I denne lyntalen får du se hvordan du raskt kan hente ut statistikk og nyttige data fra GIT-repositoriene dine. Armert med kommandolinja og et regneark kan vi få informative visualiseringer på nulltid.

This talk will be a follow along live programming session without slides. We'll start with a clean slate Play Application, build a Backbone.js based client and integrate it all.
In this talk Anders Norås will teach you how to build single page web apps using lightweight tools and architectures. You'll learn to rapidly develop REST-services using the popular Play Framework, how to create a browser based MVC app with Backbone.js and how to use CoffeeScript to write great JavaScript code without the hassle. After attending this talk you'll be able to use your good old Java skills to program in a style mostly associated with hipster programming languages and platforms.

In this presentation we will present how we built a JavaScript plugin-plattform based on common technologies in the market such as Dojo, Spring, wro4j and maven. We load both data and new components asynchronously when needed based on the user interaction with the system. This enables us to integrate visual components in the presentation.
KLP Kundeside er en ny total løsning for KLP sine bedriftskunder. Løsningen spenner over alle KLP sine forretningsområder og gir brukeren en løsning å forholde seg til. Løsningens front-end er implementert i JavaScript og baserer seg på kun en sidelasting. Dette gir en veldig rask og god brukeropplevelse. Etter hvert som brukeren navigerer seg rundt i løsningen lastes nødvendig funksjonalitet etter behov i form av plugins. En plugin vil selv være ansvarlig for å laste sine data. Dette betyr at vi i vår front-end løsning har tatt steget videre fra å laste data asynkront til å også laste script asynkront. For å få til dette måtte vi utvikle vår egen plugin-baserte plattform for JavaScript. Løsningen er implementert i JavaScript og Java og baserer seg på vanlig tilgjengelig teknologi i dag. Dette gjør oss i stand til å utvikle og release ny funksjonalitet parallelt i forskjellige team. Plattformen gir mulighet for kontinuerlig deployment uten nedetid. Etter hvert som en ny plugin ferdigstilles kan den gjøres tilgjengelig på plattformen, uten at noe må stoppes. Ved å ha muligheten til å release små deler helt uavhengig av hverandre reduserer vi også risikoen ved utrulling av ny funksjonalitet betraktelig. Vår plattform legger også opp til deling av JavaScript funksjonalitet mellom pluginene via fellesbibliotek. Dette sikrer økt effektivitet og høyere leveransehastighet. Vi vil i denne presentasjonen fortelle om hvordan vi har utnyttet funksjonalitet fra Dojo, Spring, wro4j og maven for å få til dette. I tillegg kommer vi til å kjøre en live demo av løsningen som inkluderer live koding av ny funksjonalitet til løsningen.

In this talk, Josh Long and Oleg Zhurakousky introduce how to build applications and architectures that scale on Cloud Foundry, the open source PaaS from VMware, using Spring Batch and Spring Integration, with RabbitMQ as the communications fabric enabling distributed applications.
Cloud Foundry, the open source PaaS from VMware, and cloud in general, to some extent, provides today's developers with unique opportunities:scale! Unlimited scale! In this talk, Spring Integration committer Oleg Zhurakousky and Spring Developer Advocate Josh Long introduce how to use Cloud Foundry and RabbitMQ to build integration and batch processing solutions that can scale to meet any challenge with Spring Integration and Spring Batch.

How do patterns in literature, music, and architecture inform our perspective on the code we write and the systems we build? A timeless quote from Winston Churchill and a brief exploration of the humanities can provide a fresh perspective on the technology debates about languages, platforms, frameworks, databases, and more.
Winston Churchill famously said, "First we shape our buildings, and afterwards, our buildings shape us." He was talking about the reconstruction of the House of Parliament, which was damaged in a bombing raid in World War II. There was a debate about how to shape the chamber to best accommodate the deliberative activity of the body that met in it. Churchill was talking about buildings, but it turns out his insight is a very general one indeed. Developers are constantly debating their choices of language, platform, editor, methodology, and even where to put the curly braces. The robust internal dialog in our community is a healthy thing, but our debates are often focused on the wrong topics. Have you ever compared languages by performance benchmarks? Platforms by alleged claims of developer productivity? Methodologies by feature velocity? Then there is a very good chance you're doing it wrong. Rather than focus on the material content of our debates—language performance, editor productivity, methodological velocity—we should take Churchill's advice and think about the form of our choices. How will our choice of language influence the way we solve future problems? What assumptions does our methodology make about the nature of work? How will our choice of database affect the kinds of problems we think of as solvable? Drawing on lessons from building architecture, literature, music, the visual arts, and even software itself, we'll learn the priority of interpreting the form of things before attempting to understand their content. You'll come away with powerful new intellectual tools to help you navigate the perennial debates that technology leaders engage over and over—and you may never look at software architecture the same way again.

Cloudname is a system for coordinating distributed services. It provides a system for assigning coordinates to services and then tracking services through these coordinates. Services can use Cloudname to announce endpoints and accept configuration. Clients can resolve endpoints and keep track of these even when services go down, come up, and move to different physical nodes in a cluster.
Cloudname is an open source Apache licensed system for running services in the cloud (available from http://github.com/cloudname). The system consists of two parts: Nodee, which is a very simple service for provisioning and managing software artifacts and running processes in a distributed system. The other part is the Cloudname library, which is used for coordination of services in a distributed system. (Usually when we refer to Cloudname, we mean the Cloudname library). The Cloudname library aims to provide a minimal set of coordination and configuration services needed to run large distributed systems. It takes care of mapping and tracking services independently of physical their physical location. Services are assigned coordinates. When a service starts it will claim its coordinate. Once a coordinate has been claimed the service can use this to publish endpoints. Clients can resolve endpoints by way of resolver expressions. It is an important point that Cloudname is implemented as a library that uses Apache ZooKeeper to perform its heavy lifting.

Roy Osherove, author of 'art of unit testing', shares many tips on making your tests last the length of the project, without having to delete them at some point, and without being afraid to change them. more info at artofunittesting.com
In this session, Roy Osherove, Author of 'The Art Of Unit Testing' , explains how unit tests, done wrong, can actually hurt your project more than they help. ROy introduces the three pillars of good unit tests - Readability, Maintinablity and Trutworthiness, and shows many examples from real projects's code with ideas on how to improve them, and problems can occur. From good naming conventions, to having a single mock per test (plus the difference between mocks and stubs), roy shares many important lessons he learned the hard way, while developing software. Lots of videos on this subject and more can be found at artOfUnitTesting.com and roy on titter is @RoyOsherove

Securing your Java EE 6 applications running on GlassFish.
The hottest topic for Enterprise Java applications out there is security. It has so many different aspects and this session is going to cover the basics which are used ootb from the example application. Going further down to the OWASP Top 10 about application security and also shows how and where to integrate solutions for that.

This lightning talk will give you an introduction to SASS - a CSS precompiler. SASS will make your everyday life as a web developer to a much better experience, and after this talk you will know why you should use it.
SASS står for Syntactically Awesome StyleSheets og er en preprosessor som hjelper deg å håndtere css på en bedre måte. Denne lyntalen vil gi deg en basic introduksjon til SASS med hands-on eksempler, og du vil sitte igjen med et inntrykk av hvor mye bedre dette kan gjøre hverdagen din som webutvikler.

Most societies have been closed for practical reasons such as the cost of distributing information on paper. The Internet has removed most obstacles, but the government still acts as if they exist. This talk is about how we can change this so you can get the data you need!
Historisk har svært få samfunn hatt noen særlig grad av åpenhet rundt de data som samfunnet skaper, men dette skyldes sjelden vond vilje men snarere praktiske forhold som at informasjon på papir er kostbart å distribuere. Med utbredelsen av Internett er begrensningene forsvunnet, men store deler av offentlig sektor opptrer fortsatt som om informasjonsformidling er dyrt og arbeidskrevende, dette til tross for at åpning av flere data kunne hatt stor verdi for både enkeltpersoner og samfunnet som helhet! Denne lyntalen handler om hvordan vi kan endre på disse holdningene gjennom de muligheter og rettigheter vi som borgere av Norge har til data og informasjon, og om hvilke miljøer og grupper som allerede jobber med dette og kan bistå deg med å få frigjort eller tatt i bruk data som du har behov for!

Learn how a group of developers from SAP's IT division evolved over a period of two years from using an ageing Java 1.4-era set of skills & tools to become a Scrum-based team using Continuous Delivery to create a secure, highly-available and mission-critical part of SAP's cloud platform.
The SAP ID Service is SAP's identity management system for its websites and cloud operations. The team that built it came from a background of writing web applications in Java 1.4 for an ageing and proprietary platform where it took up to a week just to deploy a new release after it had passed mostly manual QA. With the SAP ID Service project starting in 2010 the team rebooted itself: we adopted Scrum and started building the SAP ID Service using a lean, modern and standards-based application server built from open source components and using Continuous Delivery for build, test and deployment. We are now at the stage where each commit leads to a build with automated test coverage via Cucumber followed by a blue/green deployment to a production-like QA landscape which is provisioned from a cloud and configured automatically using Chef. A similar deployment to production is just a couple of clicks away, and the cloud-based technology used for this also enables developers to provision their own landscapes using a simple web-based tool. This talk will describe our journey, not only sharing our experiences but also welcoming questions and stories from others in the room.

An introduction to MongoDB, the highly scalable document oriented database, with discussion various integration points for MongoDB & the JVM including Spring's "Spring Data" component for MongoDB, the Morphia Object Mapper for Java, MongoDB's Scala Driver "Casbah", Mongo-Backed Akka Durable Mailboxes, Salat for Object & Case Class Mapping between MongoDB and Scala, and MongoDB's Hadoop integration.
MongoDB is a scalable, high-performance, open source, document-oriented NoSQL database. It features document-oriented, JSON-based document storage and dynamic schemas providing simplicity, power and flexibility, combined with full indexes similar to what a traditional RDBMS user would expect. MongoDB also provides solid replication & high availability features as well as an auto-sharding system for transparent horizontal scalability. This talk introduces MongoDB for developers who aren't familiar with it, and discusses various integration points for MongoDB & the JVM including Spring's "Spring Data" component for MongoDB, the Morphia Object Mapper for Java, MongoDB's Scala Drivers (Casbah, as well as a new experimental Asynchronous driver called "Hammersmith"), Akka Durable Mailboxes, the Salat Object-Document mapping system for Scala, and MongoDB's Hadoop integration.

This session is an experience report from a grid-architecture proof-of-concept at Skatteetaten (Norwegian Tax Office), aiming for increased maintainability, decreased lifecycle cost and linear scalability. The presentation focuses on method and tools used to achieve high productivity in the project.
I en "Proof-of-Concept" for Skatteetaten ble en grid-basert plattform for skatteberegning testet ut. Utviklingsteamet fikk fritt velge verktøy og fremgangsmåte, og resultatet ble en høykvalitets løsning levert langt under tid og budsjett. Presentasjonen oppsummerer de viktigste valgene som vi mener er vesentlig for høy produktivitet i software-prosjekter i dag. Info til program-komiteen: Arbeidet med grid-produkter hos Skatteetaten er foreslått presentert i flere forskjellige foredrag for årets JavaZone: Tormod Varhaugvik (Skatteetaten): Virksomhetsarkitektur-perspektiv, problemstilling i Skateetaten, konsepter og hva man ønsker å oppnå. Trond Arve Wasskog (BEKK): Applikasjonsarkitektur-perspektiv, grid-egenskaper, programmeringsmodell, erfaringer og problemstillinger på overordnet nivå. Eivind Waaler (BEKK): Implementasjonsperspektiv, demo og kodeeksempler med bakgrunn i PoC på Skatteetaten. Dette foredraget, som også kan kjøres som full presentasjon, utfyller de andre ved å adressere utviklingsmiljø og organisering.

Enterprise search can grow big, really big! Using the world's most popular Open Source search engine, Apache Solr™, we will show you how the new upcoming version 4.0 makes scaling search in the cloud really simple and robust, using the new SolrCloud feature set.
h1. Problem Enterprise search can grow big, really big! And growing. Tens, yes hundreds of servers may be involved, locally or in the cloud. Managing this has been complex and time consuming - until now :) h1. SolrCloud to the rescue Using the world's most popular Open Source search engine, Apache Solr™, we will show you how the new upcoming version 4.0 makes scaling search in the cloud really simple and robust. A new feature called SolrCloud adds centralized configuration, distributed indexing & searching, automatic failover, recovery and leader election. Scaling is now as simple as adding a new server to your cluster and it will find its role where it is most needed and start serving searches.

Discover Ceylon, a new and modern language where you can say more, more clearly. We will walk you through our philosophy, features, tool set, ecosystem and community to help you get started in Ceylon.
Ceylon is a new programming language designed to execute on the JVM. We're fans of Java and its ecosystem. However, we think that the language and class libraries, designed more than 15 years ago, are no longer the best foundation for a range of today's business computing problems. Ceylon's design goals include: - easy to learn and understand for Java and C# developers, - eliminate some of Java's verbosity, but keep its readability, - improve upon Java's typesafety, - provide a declarative syntax for expressing hierarchical information (user interface, external data, system configuration) - support and encourage a more functional style of programming with immutable objects and higher-order functions, - great support for meta-programming, - built-in modularity. Come and join us for this introduction to Ceylon where we will show you its main features as well as the ongoing progress of the compiler, IDE, tools and the community behind it.

Interrested in developing an Android app? Learn about the possibilities using Ruby on Android!
Android has made great advances the last couple of years, and is one of the major actors in the phone ad tablet markets. The main programming language on Android is Java. Android offers a comprehensive API to apps running on the Dalvik VM. The API covers a large part of the Java standard library in addition to Android specific APIs. Android includes tooling to convert Java .class files to Dalvik VM compatible class files. Ruboto uses JRuby to allow you to run Ruby scripts on the Dalvik VM. Using Ruby code, you have access to the complete Android API. Currently, there are two offerings: ruboto and ruboto-irb. Ruboto is a framework and tool chain to develop stand-alone Android apps in Ruby. Ruboto-IRB is an interactive Ruby environment for learning, exploration, development, and testing. This presentation will introduce the different parts of Ruboto: * Installation * Hello World * Development tools * Emulator * Combine Java and Ruby in the same project * Limitations * Release There is a lot happening both on Android, JRuby, and Ruboto, and I'd like to present the last months development, and present the road map for the project. See what Ruboto has to offer.

Software architectures are the the firm foundations on which successful products are constructed, but if a product is successful over the long term its architecture will not only need to evolve, but must be actively defended against malignant forces.
Much has been made of the need to establish software architectures to provide the firm foundations on which successful products are constructed, but if a product is successful over the long term its architecture will not only need to evolve, but must be actively defended against malignant forces. The fact that software architectures tend to outlive the tenure of developers, architects, management teams and even companies makes the maintenance of software architectures over the long term crucial for the ability of products to deliver ongoing value. What happens to the architecture of established systems in an environment where concurrent feature delivery projects make architectural ‘adjustments’ for their own ends? How can erosion of this shared architecture be managed across multiple teams? How can projects acting in their own best interests avoid over-exploiting the common architectural resource on which they all depend? Should ownership of the architecture be distributed and shared, or centralised and tightly controlled? Perhaps most importantly, can we detect when the architecture has been violated? This talk explores how shared resources in other fields are managed for the common good, and draws analogies and lessons which can be applied to the shared ‘resource’ of a software architecture. Examples garnered from over twelve years working with greenfield and legacy software systems illustrate how to diagnose, understand the causes of, and address the erosion of application architectures so that products can flourish and be productive for future generations.

A world dominated by password based authentication and data leaks left and right, makes secure password storage mandatory. We’ll look at how to store passwords in such a way that they are tricky to exploit, even if the user database winds up on pastebin.com.
Brukernavn og passord er uten tvil den dominerende formen for autentisering i dagen informasjonssystemer. Mye kan sies om det, men det betyr i alle fall at vi som utviklere må sørge for at passordene lagres på forsvarlig vis. Det er veldig mange måter data kan lekke på, som SQL injection, feilkonfigurasjon, kompromitterte nettverk eller sårbarheter i tredjepartskomponenter, og det er vår jobb å sørge for at brukerdatabasen er vanskelig å utnytte, selv om den forsvinner ut døra. Og den jobben gjør vi stort sett ikke bra nok. Lagring av passord er likevel en veldig takknemlig og enkel oppgave å sette seg inn i, siden det er veldig få måter å gjøre det riktig på. Vi ser på hva man bør gjøre, og hva som ikke fungerer. Vi kikker også på hvordan passordcracking går for seg, slik at vi ikke bare får med oss hva som er de viktige teknikkene, men også hvorfor de er viktige.

Forget everything you know about software quality!
The needs to go faster to market and cut costs, dominating the industry lately, are significantly changing the landscape of software quality. Many pillars of successful quality strategies in the past are just slowing down delivery too much. We will have to find better ways to provide build in quality into our systems, track and assure it. Join Gojko Adzic to learn how you can reinvent your approach to software quality and scale delivery processes by engaging business users better, enhancing visibility, collaboration and knowledge transfer. This is a talk for anyone serious about software delivery, regardless of the role in their process.

I love testing. And I like productivity. There are many tools and libraries that make writing tests easier, more convenient, more fun. In this talk I’d like to introduce those that I found the most useful during the years, from selected advanced features of JUnit to assertion libraries, powerful behavior/fault injection, testing of database-related code, and finally to boosting your testing productivity hundredfold with Groovy.
I love testing. And I like productivity. There are many tools and libraries that make writing tests easier, more convenient, more fun. In this talk I’d like to introduce those that I found the most useful during the years, from selected advanced features of JUnit to assertion libraries, powerful behavior/fault injection, testing of database-related code, and finally to boosting your testing productivity hundredfold with Groovy. We will only skim the surface, you’ll get the opportunity to learn more details in an accompanying in-depth article.

A ten-minute exploration of the internals of a Git repository and a demo of some internal Git commands that show the inner workings of this powerful tool.
Fine, you can clone projects, commit code, pull, and push to GitHub. But do you know why that stuff works? Have you ever looked at the plumbing behind the porcelain? Come to this talk for a lighting-fast explanation of the internals of a Git repository and a demonstration of how to commit content without every running add or commit—or without even creating a file. A deeper understanding of Git awaits!

While porting an old application used for performing oil spill risk assessment, we were tasked with improving performance for a complex analysis. The end result is a 98% performance boost, using commodity Laptop-grade hardware and standardized software.
While porting an old application used for performing oil spill risk assessment, the task was to optimize the speed at which the processing of about 5GB worth of textual, tab separated, structural input files were analyzed. The process ended up split into separate tasks, each performing its own part of the parsing and analysis. This talk will outline the steps we went through in order to optimize and achieve a performance gain of roughly 98% - from 24 hours to 24 minutes - while keeping the application running on a commodity hardware laptop computer (A quad core MacBook Pro), Java Standard Edition 6 and standard, open-source frameworks.

Good designed languages, libraries and tools make programmers happy so they produce more value.
How programmer happiness can increase by using languages like ruby and coffeescript, templates like haml and ide's like light table. Why happy programmers are more creative and produce more value.

Using Java-based frameworks and Cloud-services to cheat our ways through life is knowledge worth passing on to others.
Verden er urettferdig. Hvorfor må de med lengst ben ta til takke med dårlige seter på et fly? Hvorfor skal de som er best i quiz alltid vinne quiz'en? Hvorfor skal man alltid stille seg bakerst i køen? Hvorfor skal flaks og tilgjengelighet bestemme om du får gå Birken eller se Justin Bieber i Spektrum? Hvorfor er det aldri jeg som skriver "FIRST" i kommentarfelter på nye artikler. Ved å benytte fantasi, nevenyttighet, teknologier, rammeverk og biblioteker så kan verden bli enda mer urettferdig - men, til din fordel. I dette foredraget vil vi presentere egne og andres prosjekter der f.eks Web scraping er blitt benyttet for å manipulere systemer til egen fordel. HTMLUnit, Cloud, XMPP, E-Mail, Fiddler, Android dekompilering, LittleProxy og mange andre løsninger er satt i system for å snike og jukse eller forbedre verden. Vi viser konkrete eksempler på hvordan man kan benytte Java-baserte biblioteker og Cloud-tjenester for å minimere antall ærlige dager i IT-hverdagen. Konkret så viser vi deg hvordan man skaffer Justin Bieber billetter, få tilgang til låste profiler på Sukker.no, hvordan man alltid får nødutgang på fly og hvordan man blir nummer en på Ruzzle.

Code examples are frequently copied and pasted. Example code should therefore be the best quality code you will ever write. This lightning talk will lead you through five steps on your path to writing exemplary code.
Når vi tar i bruk et nytt bibliotek eller rammeverk hopper mange av oss over dokumentasjonen og går rett til eksempelkoden. Dessverre er eksempelkode ofte full av feil og mangler. Det har forekommet at feil i eksempler har ført til alvorlige problemer i produksjon. Enten du skal skrive eksempelkode i en blogg eller lage en eksempelapplikasjon for et utbredt API er det viktig at eksemplene er av topp kvalitet. Med bakgrunn i erfaringer fra å skrive eksempelkode til det sentrale sikkerhetssystemet til en av Norges største finansinstitusjoner vil lyntalen gi deg fem gode råd til hvordan du kan skrive eksemplarisk kode.

Significantly up your JavaScript game by leaving loops behind and embracing functions as the primary unit of abstraction.
Are you comfortable passing functions around, returning them from other functions, and generally enjoy the pleasures of higher-order functions? Join in on an hour implementing ideas from functional programming in JavaScript. I will show you how you can significantly up your game by leaving loops behind and embracing functions as the primary unit of abstraction.

Puppet is an infrastructure-as-code tool that allows easy provisioning of servers. This session will show you how to code the infrastructure needed for your developments: JDKs, database servers, application servers, web applications, and all supporting services, in an automated and repeatable way, that can be easily used in hardware or virtual machines during development, QA or production.
Puppet is an infrastructure-as-code tool that allows easy and automated provisioning of servers, defining the packages, configuration, services,... in code. Enabling DevOps culture, tools like Puppet help drive Agile development all the way to operations and systems administration, and along with continuous integration tools like Jenkins, it is a key piece to accomplish repeatability and continuous delivery, automating the operations side during development, QA or production, and enabling testing of systems configuration. Traditionally a field for system administrators, Puppet can empower developers, allowing both to collaborate coding the infrastructure needed for their developments, whether it runs in hardware, virtual machines or cloud. Developers and sysadmins can define what JDK version must be installed, application server, version, configuration files, war and jar files,... and easily make changes that propagate across all nodes. Using Vagrant, a command line automation layer for VirtualBox, they can also spin off virtual machines in their local box, easily from scratch with the same configuration as production servers, do development or testing and tear them down afterwards. We’ll show how to install and manage Puppet nodes with JDK, multiple application server instances with installed web applications, database, configuration files and all the supporting services. Including getting up and running with Vagrant and VirtualBox for quickstart and Puppet experiments, as well as setting up automated testing of the Puppet code.

The most important question to be asked when developing a new software system is "How will we replace it?"
The most important question to be asked when developing a new software system is "How will we replace it?" It is however a question seldom asked. Instead organization focus on reusability, which unfortunately helps create rigid and inflexible architectures. The talk shows how to design systems made up of small parts, why you should standardize on protocol and not platform and how you will end with a system that is easier to scale and maintain.

Memory leaks can cause OutOfMemoryError. Know how to detect and - even better - avoid them.
In Java, memory leaks take the form of “unwanted references”, i.e., references that keep objects alive that are no longer needed by any part of your program. If these “forgotten” objects pile up they might even cause an OutOfMemoryError. The session explains various kinds of memory leaks, how they happen, and how they can be detected using tools (profilers and heap dump analyzers).

Bringing a modern web startup culture into one of the world's oldest institutions.
Starting in February 2010 a small group of developers, designers and product sculptors began work on http://alpha.gov.uk, demonstrating what a new, simplified and unified website for the UK government might look and feel like. It's been rapidly followed by public betas and the outcome of that work is intended to become the official UK government website before the end of 2012. This talk tells the story of bringing a modern web startup culture into one of the world's oldest institutions.

Application security must be solved by the people building it! Luckily, the basics of appsec are surprisingly simple. Understand what the problems are, how they might apply to your application, and how you can solve them.
As applications grow and mature to become a natural and integral part of business, government and society as a whole, so does the demands for application security. Often ill-defined, often poorly understood by decision makers, it’s never the less critical for any internet facing system. Application security is no longer optional. It can no longer be an afterthought. It cannot be addressed by adding another box to the server room. It cannot be outsourced, nor can it easily be retrofitted. Security must be designed and built into mission critical applications from the beginning, and the only people in a position to do this are the ones building it. Luckily, the basics of application security are surprisingly simple. In this introductory talk, we'll delve look into what every application developer needs to know about security, regardless of whether you see yourself as a backend or frontend person, or what language you prefer. We'll look into the basic forms of the most common threats and mitigation in some detail, in order to assist you in recognizing where problems may occur, what might happen, against whom and in what circumstances. And most importantly: how to best address them in your own applications. This will include subjects such as important security patterns, injection attacks, cross site scripting, cross site request forgery and session hijacking. The talk will focus on concrete examples, demonstrating both the issues and important tools and techniques for the responsible developer.

Video content is increasingly playing an important role on the web today. This talk covers everything you need to work effectively with video using Java and HTML5. Whether your plan is to build the next Youtube or just to add some video to your web site, this talk covers everything you need to get started.
Video content is playing an increasingly important role on the web today. Video provides an engaging and effective way of conveying your message to an audience. Yet as programmers, lack of tooling has made it difficult for us to access video. This talk covers everything you need to work effectively with video using Java and HTML5. After introducing the basic concepts of frames, codecs and container formats, we'll dive into video production, analysis and transformation using the open source library Xuggler. We'll then show you how to consume video in the browser using HTML5 video and Javascript. We'll also cover new APIs giving programmatic access to the user's webcam and how to process live video with effects in the browser using the Canvas API. The format of the talk is a mix of slides covering the theory with some fun demos showing what kind of video solutions you can create using what you've learned. Whether your plan is to build the next Youtube or you just want to add some video to your web site, this talk covers everything you need to get started.

The presentation covers how to tackle Android fragmentation, and how to write highly portable applications for both phones and tablets. ICS is out, and the adoption is steady but slow. Developers will have to support a large number of Android versions in years to come.
The number of Android powered devices are sky rocketing. To reach larger audiences, developers want to create applications that are compatible with as many devices as possible. Ice Cream Sandwich brings together tablet- and phone development, but adoption however steady is still slow. This results in developers having to cope with different Android versions for years to come. The diversity of devices running the operating system provide great freedom of choice for consumers. On the other hand, screen sizes, form factors and capabilities vary dramatically and provide additional challenges for developers. The presentation will cover how to use fragments to achieve a high level of code reuse in the UI layer. The presentation will also cover how to use the Android compatibility package to build applications that can be installed, from a single APK to both phones and tablets. The topics will be explained using code, and a complete overview of how to write highly portable Android applications will be given during the presentation.

A simple, monolithic web applications that serve up HTML to desktop browsers no longer satisfies the requirements of modern applications. In this talk, you will learn how to decompose your application into a set of narrowly focused, independently deployable back-end services with a NodeJS and HTML 5 front-end.
Today, there are several trends that are forcing application architectures to evolve. Users expect a rich, interactive and dynamic user experience on a wide variety of clients including mobile devices. Applications must be highly scalable, highly available and run on cloud environments. Organizations often want to frequently roll out updates, even multiple times a day. Consequently, it’s no longer adequate to develop simple, monolithic web applications that serve up HTML to desktop browsers. In this talk we describe the limitations of a monolithic architecture. You will learn how to use the scale cube to decompose your application into a set of narrowly focused, independently deployable back-end services and an HTML 5 client. We will also discuss the role of technologies such as NodeJS and AMQP brokers. You will learn how a modern PaaS such as Cloud Foundry simplifies the development and deployment of this style of application.

There's always the question of which build tool to use when starting a new project. At Knowit, we've been using both Maven and SBT for our Scala projects. I will explain our reasons and share the challenges we faced.
There's always the question of which build tool to use when starting a new project. At Knowit, we've been using both Maven and SBT for our Scala projects. I will explain our reasons and share the challenges we faced.

Many web applications has the need to push updates to a page in order to keep it up to date and display new information. In the Lift framework this is done with Comet Actors. This lightning talk will address challenges and possible solutions, using examples from a real life project.
I mange web-applikasjoner ønsker man å “pushe” oppdateringer til en side for å kunne holde den oppdatert og vise ny informasjon. I Lift-rammeverket benytter man "comet actors" for å løse dette. Denne lyntalen tar for seg utfordringer, mulige løsninger og prosjekterfaringer fra bruk av Lifts comet actors.

Continuous delivery teams are delivering ideas continuously and long before ohers have finished their first iteration. How do they do it? We will present a maturity model containing tools to accomplish this, and share experiences with several of them. Each one adds immediate value, and you shouldn't do them all at once.
Kontinuerlige Leveranser og Devops praktiseres av svært mange skal man tro buzzen. Ved hjelp av nye verktøy og prosesser dytter virksomheter idéer ut til sine kunder før andre er ferdige med sin første iterasjon. Det er kunden som bestemmer når noe skal ut i produksjon, ikke IT. Og dette får de til uten å kompromisse på kvalitet. Hvem kunne ikke tenke seg å ha det sånn? Hvordan får de det til? Vår erfaring er at det er lite hensiktsmessig, og til en viss grad svært farlig, å forsøke å få til dette i ett jafs. En mer fornuftig tilnærmingsmåte er å bygge stein for stein basert på tilstanden man befinner seg i, og gradvis forbedre situasjonen. Vi har laget en modenhetsmodell for kontinuerlige leveranser som inneholder teknikker og verktøy som bringer en nærmere målet, og det fine med å være på denne "reisen" er at hvert steg gir stor verdi i seg selv. I foredraget vil vi presentere noen erfaringer på godt og vondt med å implementere steg i modellen. Vi vil starte med å presentere modenhetsmodellen, for deretter å ta for oss noen av teknikkene vi har hatt erfaringer med. Disse er; effektiv bruk av versjonskontroll, branch by abstraction, feature toggles, deployment pipelines med Jenkins, infrastruktur som kode med Puppet, virtualisering av produksjonslike miljøer for utvikling og test (Virtualbox, Vagrant), one-click deploy (og tilbakerulling), nedetidfri produksjonssetting og håndtering av databasemigrering (og tilbakerulling).

Live pair programming of the norwegian screencast Zombie TDD.
Zombie TDD er en norsk screencast-serie med testdrevet JavaScript på både klient og server. I dag setter Christian og Magnar seg ned med emacsen og parprogrammerer tre nye episoder foran publikum. Det blir utvikling av en ny feature, så du kan henge med selv om du ikke har sett alle episodene. Se hvordan to typer som digger JavaScript angriper problemer og gjør koden testbar.

Mobile is the next big thing and your company needs to there. But what does there actually entail? Should you build a native app? On which platforms? Do you have the skills for that? What about the web? Can you deliver an awesome experience using nothing but a mobile web browser? This talk will help you navigate these treacherous waters. We'll discuss the pros and cons of the various approaches and give you a framework for choosing.
Mobile is the next big thing and your company needs to there. But what does there actually entail? Should you build a native app? On which platforms? Do you have the skills for that? What about the web? Can you deliver an awesome experience using nothing but a mobile web browser? This talk will help you navigate these treacherous waters. We'll discuss the pros and cons of the various approaches and give you a framework for choosing.

Eager to use key-value databases? Finding it difficult to use it correctly? This talk will describe the best patterns for organizing your data in a key-value store. The talk will also present good patterns for using more advanced key-value stores as Redis.
Etter hvert som nosql blir mer og mer populært blir behovet for gode patterns stort. Det er en fordel å organisere dataene sine så godt som mulig, slik at det blir enkelt å finne tilbake til dem senere. Dette kan være en utfordiring når man ikke har lite erfaring med key-value stores. Dersom man bruker gode patterns vil det føre til vakker kode, bedre ytelse og mer logisk organisering av dataene. Foredraget vil se på patterns som gjelder alle key-value stores, samt patterns for mer avanserte databaser som Redis.

Software craftsmen learn continuously to keep adding value to his current work and repertoire. Getting Things Done (GTD) workflow helps software craftsmen to get organized with their responsibilities as well as their professional and personal development in a stress free way.
As aspiring software craftsmen you learn continuously, catching up with the existing and new things that can add value to your current work and repertoire. Let’s say you read a tech article or listen to an episode of your favorite podcast and find yourselves with references that inspire you to check further. What do you do to make sure that you will give those ideas enough attention to decide effectively whether you want to act on it or not? Do you keep a mental “check-later” list and never actually check them because you simply forget it or too busy to get back to it? Getting Things Done (GTD) system presents a workflow that will help us get organized with our responsibilities as well as our professional and personal development, based on the natural way we deal with our work: we (1) "collect" things that command our attention; (2) "process" them to know what they mean and what to do about them; and (3) "organize" the results, which we (4) "review" as options for what we choose to (5) "do". One of the challenges to get organized in the conventional ways, like making list and schedules, is that we tend to do all the five phases at one time. Selecting too early will list out things we consider unimportant relative to other “critical” things on the list or simply because we don’t know how to act on it now. Leaving things open will take up energy and prevent us from having a totally effective, clear focus of what is important. Since the first time GTD was invented, tools have been created to make it easier to implement GTD as part of our daily life with the least interruption. We will have a look at some of the available tools in comparison.

ClojureScript is a dialect of Clojure built especially for rich front-end applications in the browser. What better application to show than an agent model of cows inside an electric fence? We'll take a good look at an exciting language and learn useful principles to help us keep the anxiety level of our herd as low as possible.
ClojureScript is a dialect of Clojure that compiles to JavaScript, and targets the JavaScript runtimes of the web as a deployment environment. It offers the unparalleled expressiveness of Lisp, the performance and space efficiency of the Google Closure Compiler, interoperability with the in-browser object model, and natural integration with server-side Clojure applications. In a time of proliferating JavaScript extensions and client-side development frameworks, this is a compelling vision of how client-side web development should be done. It's also a great language in which to write an agent model. In this talk, we'll dissect an entirely client-side simulation of a pen full of cows inside an electric fence. Each cow moves around randomly, and is sensitive to the stress level of the cows around it. When a cow wanders into the electric fence, we can explore simulation parameters that determine how stress moves through the herd. We'll learn how to write ClojureScript, and draw fascinating parallels to human behavior in real-life emotional systems.

Demonstrasjon: Foredragsholderen stiller et spørsmål og publikum svarer, hele publikum. Ved hjelp av en webapp på mobilen kan svarene vises direkte på slidene.
De fleste som hadde fjernsyn på nitti-tallet har hørt om Tande-P og "mentometerknappen". Hva om man kunne ha en "mentometerknapp" i en presentasjon, der publikum gir direkte tilbakemeldinger vha smarttelefonen sin? Ideen er ikke ny, men det er foreløpig ingen som har benyttet den på et så intelligent publikum (så møt opp)! Her får du en demonstrasjon av noen av de fantastiske mulighetene som ligger i dette!

Hvem av oss kan si at vi aldri har drømt om å ha superkrefter? Kommandolinjeninjakrefter! Slik at du kan bevege deg raskt og lydløst over tastaturet, ha et stort arsenal av effektive verktøy og ha muligheten til å gjøre de kjedelige rutineoppgavene om til noe som er gøy?
Blir du satt ut når noen knoter ned noen kryptiske kommandoer i konsollet? Tenker du - DET DER - DET vil jeg også lære? Har du lyst til å lære nye triks eller gjenoppdage lure kommandoer du har glemt? Kanskje du bare har lyst å bli mer effektiv, eller trenger et nytt samtaleemne til neste familiemiddag? Kom til live kommandolinjeninjashow og ta svart belte i kommandolinjetriks! Du kan også bidra og briljere med dine skills! Det blir noen små premier for bidrag fra salen og en overraskelse på slutten.

Want to program to iOS but don't want to deal with Objective-C? Don't want to buy a Mac just to build iPhone apps? Want to build Windows Phone apps but don't want to switch to Windows or port to C#? Java to the rescue! Make WORA real again for mobile programming thanks to the open source community.
Thanks to the open source community it is now entirely possible to use Java in order to build native applications for iOS, Android, RIM, Windows Phone etc. without the compromises that HTML5 imposes. The talk focuses on the open source Codename One project, which started its life within Sun Microsystems and eventually grew into a full grassroots project as its founders left Sun. As part of the talk we will build an application live on stage and demonstrate how it can be instantly deployed to devices. The talk is based on two highly attended talks that were given in Java One 2012 covering this very subject.

Like chocolate and peanut butter, Dart and Web Components go great together. Learn how to build structured, declarative apps with modern web platform features, and deploy them across the modern web today. Don't wait for all browsers to implement the great new Web Components specs, let Dart and its Web UI framework make it a reality today.
Like chocolate and peanut butter, Dart and Web Components go great together. Learn how to build structured, declarative apps with modern web platform features, and deploy them across the modern web today. Don't wait for all browsers to implement the great new Web Components specs, let Dart and its Web UI framework make it a reality today. Dart's language features such as classes, static types, and libraries brings order and scalability to the chaos. Web Components' features such as encapsulation, reusability, and declarative semantics helps you "say what you mean" and avoid soup. Web UI's declarative and dynamic two-way data binding efficiently wires up your app. Best part: it all compiles to vanilla HTML and JavaScript to bring you the best of the future web today so you can deploy access the modern web browsers.

The talk, split into two sections and drawing from a real implementation covers potential NoSQL architectures and the features they offer in the quest to reach the Holy Grail AKA linear scalability. Presentation will describe a real-world implementation delivered for a global on-line travel agency using Infinispan.
The talk, split into two sections and drawing from a real implementation covers potential NoSQL architectures and the features they offer in the quest to reach the Holy Grail AKA linear scalability. First we examine an existing traditional replicated cache running at full capacity and how replacement with a distributed solution allowed the application to scale dramatically with a performance improvement to boot. Secondly we look at one of the pitfalls of distributed caching and how, using an essential tool from the Data Grid functionality armory, namely grid-execution we can provide massive scale out and low latencies. Both parts describe a real-world implementation delivered for a global on-line travel agency using Infinispan.

Learn how to building modern, scalable, reactive and resilient applications, ready for the real-time web.
The skills of building Event-Driven, Highly Concurrent, Scalable & Resilient Systems are becoming increasingly important in our new world of Cloud Computing, multi-core processors, Big Data and Real-Time Web. Unfortunately, many people are still doing it wrong; using the wrong tools, techniques, habits and ideas. In this talk we will look at what it means to 'Go Reactive' and discuss some of the most common (and some not so common but superior) practices; what works - what doesn't work - and why.

Never ever experience schema validaition errors on startup again.
Numerous tools exists to help you deploy database schema change scripts, provided you've remembered to create them. To help you remember, we have employed unit tests that break the build immediately if you add new persistent fields without also writing a correct delta script. In this talk I'll show you how to make that fly.

Do you have a product manager? Maybe it's time to stop. Come explore the idea that we should do away with "Product Manager" as a defined role, and ask developers to be the masters of their own domain.
By now, we are all comfortable with the orthodoxy: the product owner discerns the needs of the customer and feeds them to developers in the form a prioritized backlog. Developers pull work from that backlog, always confident that they're working on the highest-priority feature at the moment, and never having to worry about how those priorities are allocated. This system is simple, efficient, and has helped many teams function better than they used to. It's also time for the system to die. A few revolutionary companies are experimenting with the idea that developers should be in charge not only of when they build new features, but _what_ features to build. Rather than mere code technicians following the will of a product and marketplace expert, developers themselves become experts in their product domain, building the tools users need—by conceiving of those tools themselves. Dispensing with the product owner creates an entirely new organizational tenor: one in which everyone is encouraged to master the business's domain, to organize their work in autonomous ways, and to take ownership of the purpose for which the organization exists.

I'll show you a fully functional web application built using java 8, without JPA/Hibernate or CDI/Spring. I hope you'll come away inspired by the realization that you have the power to create your own solutions, instead of blindly consuming other people's frameworks.
When it comes to storing data, we've gone from direct communication with relational databases, to standardized ORMs and now we seem to be moving on to No SQL storage solutions. While I fully understand the desire to get away from ORMs like hibernate (here's my rant on that subject from 2011: http://vimeo.com/28885655), I think we're moving in the wrong direction. Instead of moving away from RDBs we should be moving towards them. ORMs let you abstract yourself away from the database. But why would you want to do that? Relational databases are great! Much better for storing data than your typical object oriented domain model. I'm not going to show you the next big framework everybody should be using to communicate with databases, but I want to demonstrate how thinking differently about database access can lead to some pretty decent solutions. You can get a lot done, quite painlessly, with plain old java. And by writing things from scratch, for a particular application, you can get away with much simpler code than you could if you were writing a fancy generic framework. Most importantly though, you learn so much more and have tons more fun. I'll be showing you a fully functional application, and the code behind it. While the code will be freely accessible online, I hope nobody uses it, but instead feel inspired to go off and write their own solutions. It's by trying new things that the world moves forwards. I want us to become creators again, not simply consumers of other people's frameworks.

Lag gode commits, og ta kontroll over commit-historien. Gjennomgang av to kraftige verktøy for å hjelpe deg på veien.
Om du jobber med git til hverdags så er det enkelte operasjoner som gjøres veldig ofte: lage små gode commits, skaffe seg oversikt og manipulere commit-historien. Med kun kommandolinjen kan det være lett å miste oversikten, her finnes det nyttige verktøy som kan være til hjelp. Dette blir en praktisk gjennomgang av gitk og git gui som kan hjelpe deg med å bli tryggere og mer effektiv med disse oppgavene.

We'll question the initial architecture decisions in building large systems, and discuss how to approach design differently. Allow for diversity while maintaining integrity, and avoid falling into the trap of making technology choices with too much rigor.
In any system of significant size, the same problem occurs again and again: What starts out as a light-weight, modern, efficient development effort using the technology of the day – be it Java and Java EE or Spring, Microsoft .NET, Ruby on Rails or any other of the well-known development stacks – ends up as a hard to change, monolithic, maintenance-intensive behemoth that everybody wants to get away from. But what are the core reason for this recurring pattern? In this session, we will discuss how and why things always seem to end up this way, and what strategies we can use to avoid this from the start.

Worried about who's getting access to your app? Sprinkle in XACML and get access control that is both context-aware, externalized and dynamic.
Need to add more than basic access control to your application? Existing authorization frameworks including their pros and cons, but are typically quite limited. This talk will introduce XACML, the eXtensible Access Control Markup Language, an authorization standard from OASIS that defines fine-grained access control based on attributes. The XACML standard enables much more dynamic authorization that not only focuses on the user but also on resources, actions, and the context. XACML enables policy-based and attribute-based access control. The talk with then look at how XACML can be used to apply authorization business rules to any Java application and even beyond (.NET, Ruby...). This is known as “any-breadth authorization”. XACML also enables consistent authorization across multiple layers (presentation tier; web tier; business tier; and data tier). It becomes possible to apply the same authorization logic in a JSF page as in a jdbc connection. This is also known as “any-depth authorization” During the talk, we will look at live examples of applications using XACML. For instance, we will demonstrate the use of XACML and Java servlets, JAX-WS web services, and APIs as a whole. Attendees will also be able to write their own XACML policies, provided they download the ALFA plugin for Eclipse, an add-on for XACML policy authoring. In January 2013, XACML 3.0 was approved as a formal standard and there are several implementations available (open-source, free, and commercial) for developers to get started. The talk will illustrate how developers can leverage XACML to quickly apply authorization to new and existing applications. After this session, you will easily be able to add standards-based authorization to your application - and simplify your life!

Forvaltning av enterprisesystemer behøver ikke å bety kjipe verktøy og tungrodd prosess . En enkel arbeidsflyt som likner et Open Source-prosjekt, sammen med tett integrasjon mellom verktøyene i utviklingsmiljøet kan gjøre selv noe så kjedelig som obligatorisk code review før merge til en positiv ting.
Forvaltning av enterprisesystemer trenger ikke å bety kjipe verktøy og en tungrodd prosess som gjør alle involverte misfornøyde. I Oslo Kommunes integrasjonsprosjekt sjonglerer vi nesten 100 komponenter på en integrasjonsbuss, men organiserer arbeidet som om det skulle vært et vilkårlig github Open Source-prosjekt. Tett integrasjon mellom verktøyene i utviklingsmiljøet sentrert rundt Jira, Github og Jenkins har gjort selv noe så banalt som obligatorisk codereview før merge til en postitiv del av hverdagen som utvikler.

Do you want to communicate more effectively? Do you want create better maintainable software? If so, come and listen to this presentation to get some hands on tips on techniques and tools.
Visualization is an effective method of communication and there is more than UML. Peter will present methods and tools to visualize your system's architecture and design (or lack of it) and the theories behind. Using the methods and tools you will be able to prove a technical debt and to justify a refactoring for example. You will also be able to visualize how the data in the system looks like from different perspectives in order to detect "information debt" or how the system behaves in operation. The purpose of the presentation is to inspire you to use visualization as a technique to communicate better and to improve the quality of your software.

How can we apply the lessons of functional programming to the design of software systems? How can we make software more transparent to developers? Using examples in Clojure, this talk will discuss ways to think about data, processes, isolation, and visibility.
One reason programming is hard is because it is so difficult to observe what is happening when a program runs. Programming languages and libraries rely on abstractions which either hide important details or produce too much information to consume. Developers come to depend on ever-more-sophisticated tools to examine programs and diagnose failures. However, with a little care and design, it is possible to build systems which lend themselves to easier comprehension. This talk will introduce some general guidelines for designing systems which make their data and abstractions more transparent to developers, using code examples in Clojure.

Come and find out how the Java 8 StampedLock can be used to make your locking 1000x faster and how to use Phaser together with Fork/Join.
The Phaser is a Java 7 synchronizer used to coordinate repeated tasks between several threads. It is very flexible and the interface is easier to use than the older constructs such as CountDownLatch. The StampedLock is a Java 8 optimistic lock mechanism, which allows us to get much better throughput on the reading and even on the writing.

Null har ingen semantisk verdi, er ikke typesikkert, og årsaken til verdens vanligste Exception. Lær hvordan man kan erstatte Null med Option og sov bedre om natten.
Null er en mare og en pest og en plage i java. Null har ingen semantisk informasjon i seg selv, og er årsaken til verdens mest utbredte Exception. Dogmatisk og aggresiv fjerning av null i kildekoden skaper mer robuste applikasjoner som er lettere å vedlikeholde. Lyntalen viser korte eksempler på hvordan man kan gjøre dette i Java ved hjelp av functionalajava sin fj.data.Option.

Lyntalen gir ein introduksjon til søkeløsninga Elasticsearch og viser korleis du enkelt kan implementere det i ditt prosjekt.
Skal du innføre søk i løsninga di er det ofte to open source prosjekt som peiker seg ut. Dette er ein intro til det nyaste, og etter mi meining det beste alternativet, Elasticsearch.

Spock is a developer testing and specification framework for Java and Groovy applications. This talk will take you on a fast-paced, demo-driven tour covering Spock fundamentals, data-driven testing, stubbing and mocking, Spock extensions, and more. Fasten your seat belts, and enjoy the ride!
Spock is a developer testing and specification framework for Java and Groovy applications. Used by open-source projects such as Grails and Apache Tapestry, and companies such as BSkyB and Netflix, its fan base is growing inside and outside the Groovy community. This talk will take you on a fast-paced, demo-driven tour covering Spock fundamentals, data-driven testing, stubbing and mocking, Spock extensions, and more. Shortly before landing, we'll be serving the latest developments in Spock 1.0. Fasten your seat belts, and enjoy the ride!

Use Java(FX) on embedded devices like the Raspberry Pi or the BeagleBoard xM to do something useful with it like monitoring the temperature.
Usually Java developers do not create code for embedded devices because there was no good Java support on these devices. Oracle figured out that there is a huge market for embedded devices and decided to support Java and JavaFX on hardware like the very popular Raspberry Pi and the BeagleBoard xM. With Java technology available on these platforms it's very interesting to see what you can do with this. This session will give you a short overview on the available technologies and will explain the interaction between different technologies and where they make sense. As an example a temperature monitoring application will be shown using JavaFX on a Raspberry Pi, a BeagleBoard xM and on the Desktop. In addition a little HTML5 page for mobile will be presented too.

Er du redd for Scalaz? Har du hørt skrekkhistorier og fått velmenende råd om å holde deg unna? La meg stilne frykten og vise hvordan jeg som nybegynner tok tak i Scalaz, hvordan jeg utforsket funksjonell programmering og hva det gir meg i dag!
Få biblioteker er så myteomspunne som Scalaz. Det florerer med skrekkhistorier om uforståelige metodenavn med fylte og åpne stjerner, abstraksjoner som kun fungerer i en streng matematisk verden og strukturer du ikke finner igjen i kildekode. Sitater av typen "hold deg unna hvis du vil beholde fornuften". Jeg må innrømme det - jeg var livredd første gang jeg så på Scalaz. Samtidig hadde jeg hørt at "validering med Scalaz er fantastisk" og "bare man kommer over kneika" - og kjente nysgjerrigheten pirret. Dette måtte bare sjekkes ut! Spør meg i dag om det var verdt det! Gjett… La meg stilne frykten og vise hvordan jeg som nybegynner tok tak i Scalaz, hvordan jeg utforsket funksjonell programmering og hva det gir meg i dag!

This session will show different strategies for accessing off-heap memory and using the advantage of large RAM without paying the performance penalty.
Cheap RAM means we can use more memory than an average disk size was not that long time ago. It's very tempting to increase size of our JVM heap and store more data in-memory. As always, there is a trade-off: Large heaps lead to higher latencies due to Garbage Collector overhead. This session will show different strategies for accessing off-heap memory and using the advantage of large RAM without paying the performance penalty.

En utviklers sukk over udokumentert oppførsel og manglende standardisering på Android-plattformen, og hvilke problemer dette medfører.
Android-plattformen møter stadig nye utfordringer når det gjelder det å få applikasjoner og nettsider til å se og oppføre seg riktig på ulike devices og skjermstørrelser. Jeg ønsker å ta publikum på en kort tur gjennom egne erfaringer på området, vise hvor ille det kan bli, og fortelle litt om hva man kan gjøre for å få en litt lettere hverdag. Vendor-spesifikke tilpasninger og stygge hacks må ofte til for å få applikasjonen til å gjøre det man ønsker og framstå på ønsket måte for alle enheter. Disse problemene kan minne om nettleserproblematikken for ti-femten år siden, der varierende grad av støtte og ulike tolkninger av standarder gjorde livet vanskelig for web-utvikling.

In this talk Alf Thomas explains why FINN.no develop native mobile applications, what they learned from developing and maintaining their first apps and how they applied that knowledge when developing their next generation native apps.
FINN.no is Norway's biggest classifieds site and nearly half of all visits are from mobile devices. FINN develops native mobile apps for iOS and Android, mobile web and has adopted a mobile first strategy. This talk will explain why FINN has chosen to develop native mobile applications, and how their architecture enables them to roll out both minor and some major features to all users without requiring a client update.

Is Software Design dead? How does development differ between application development and library development? And how do you not alienate your users when they're actually other developers?
Agile methodologies have had us moving away from Big Up Front Design to evolutionary, emergent design. But how does that work in the real world? Using experiences gained when creating the new Java driver for MongoDB, Trisha takes us on a design journey, where the answer to every question is It Depends, the users of the system and their use cases are unknown, and lurking at the back of every decision is the question âbut will it be backwards compatible?â Weâve all been there, trying to work out how to implement requirements, but have we really thought about the process of design? Beware Monsters.

Vi har en Krevende Kaos-Kråke (KKK) på server-rommet. Den ble født der og vi er dens foreldre. Skal man levere sikre og stabile systemer så må man håndtere solskinnsdager like bra som Kråke-dager.
Vi har en Krevende Kaos-Kråke (KKK) på server-rommet. Den ble født der og vi er dens foreldre. Skal man levere sikre og stabile systemer så må man håndtere solskinnsdager like bra som Kråke-dager. Vi kjører systemene våre i miljøer der Kråka skrur klokken tilbake, fyller opp disker, minne og databasen. Den bytter encoding, gjerne midt i en fil, og gjerne flere encodinger flere ganger i samme fil. Kråka roter også til kundeutvekslingene - når den flyr så mottar vi duplikater, triplikater og kråkeskit. Vi har stor tro på fri kråkeoppdragelse - vi ønsker ikke å oppdra Kråka, men heller tilpasse verden slik at vi kan leve med en kråke i server-rommet.

Hva er mulighetene når trafikken og datamengden i Solr blir for mye å håndtere? SolrCloud lar deg distribuere søket så du får utnyttet hele clusteret ditt.
Søk har blitt et forventet interface til mange typer applikasjoner. Hva skjer når trafikken og datamengden blir vanskelig å håndtere? SolrCloud er samlebegrepet for de distribuerte mulighetene som ble introdusert i Solr 4. Vi ser på konseptene som utgjør SolrCloud og hvordan oppsettet gjøres i praksis. Vi går også gjennom resultatene av ytelsestester for å se hva man kan forvente.

Gjør en applikasjon dynamisk ved å integrere scriptspråket lua!
Lua er et elegant og kompakt scriptspråk som har blitt brukt til å skreddersy spill som Sim City og World of Warcraft. Hvorfor ikke gjøre det samme med Java-applikasjonen din? Å gi vertsskap til et scriptspråk gir uante muligheter til å lage fleksible og tilpasningsdyktige løsninger. I denne presentasjonen får du se hvor lett det er å komme igang med Lua-scripting av Java-applikasjoner. Gjennom praktiske og visuelle kodeeksempler får du se hvordan Lua kan gi dynamisk liv til et statisk Java-GUI ved å tilordne forretningsregler til grafiske komponenter. Reglene lar seg enkelt laste på nytt mens applikasjonen kjører; det er ingen grunn til å rekompilere og redeployere. Nye lag av funksjonalitet kan enkelt legges på etterhvert, for en stadig rikere applikasjon. Med Lua i verktøykassen blir GUI-programmering i Java morsomt igjen!

Via eksempel kode ser jeg på hvordan en webapplikasjon kan få redusert forsinkelse ved sidelasting med HTTP/2.0, SPDY Push og Jetty.
Uansett om du bygger webapplikasjonen din for 10 eller 10 millioner brukere, så er utfordringene med forsinkelse ved sidelasting den samme. HTTP/2.0 (tidligere kjent som SPDY) er laget for å gjøre lasting av sider raskere. Dette oppnås ved å bygge mer intelligens inn i måten man leverer ressurser på. Via eksempler vil jeg se på hvordan Jetty implementerer HTTP/2.0 på server- og klientside. Dette inkluderer: * Hvordan utføre enkel HTTP/2.0 kommunikasjon * Multipleksing av ressurser * Intelligent push av ressurser før de blir etterspurt. Lyntalen vil være nyttig for alle som er nysgjerrige på HTTP/2.0 , og ønsker å se hvordan det fungerer i praksis.

Man hører stadig om nye teknikker for å utnytte moderne flerkjerne-prosessorer og problemer knyttet til parallell programmering. Denne presentasjonen viser hvordan vi har løst en del slike problemer ved hjelp av grid-teknologi og viser hvordan noe av dette kunne vært løst på en bedre måte med å bruke Akka og actors.
Det siste året har vi jobbet med å bygge systemer basert på en egenutviklet prosessmotor som kjører på grid-produktet Hazelcast. Tanken er å kunne definere oversiktlige prosesser for mottak og prosessering av data på en distribuert data-grid. Parallellitet og asynkrone operasjoner løses med en kombinasjon av distribuerte jobb-kjøringer og distribuering av data på flere noder. Etterhvert som vi har implementert fler prosesser har vi støtt på et økende behov for mer fleksibilitet med tanke på å definere asynkrone prosesseringssteg og bedre utnyttelse av ressurser. Vi ønsker å bygge fleksible systemer som enkelt kan tilpasses ulike behov og som kan skaleres dynamisk for å maksimere ytelsen. Dette er grunnen til at vi har begynt å se på Akka som alternativ/supplement til Hazelcast der målet er å få bedre utnyttelse av ressurser kombinert med fleksibel feilhåndtering og skalering. Gjennom en rekke konkrete eksempel viser vi hvordan Akka kan gi stor verdi på Java-prosjekter som har behov for parallellitet på serversiden :)

Skeptisk mot e-valg? Da bør du i hvert fall vite hvilke sikkerhetstiltak som faktisk er på plass under årets e-valg, slik at du ikke bruker feil argument under neste diskusjon!
Hvordan kan du stole på at e-stemmene for Stortingsvalget blir talt opp riktig? Sammenlignet med andre land har nordmenn alltid hatt stor tillit til myndighetenes håndtering av valg, men ekstern verikasjon skader aldri. Hvordan vet du at e-stemmene ble håndtert riktig? Er det f.eks. mulig å sjekke om en melding ble dekryptert riktig, selv om du ikke har tilgang til den hemmelige nøkkelen? Ja, det er mulig! Er det mulig å sjekke om innholdet i to krypterte meldinger er det samme, selv om du ikke kan lese innholdet og de krypterte meldingene ikke er like? Ja, det er mulig! Og er det mulig å sjekke om to lister med krypterte meldinger inneholder det samme, uten å vite noe om innholdet eller hvilken krypterte melding som korresponderer til hvilken andre krypterte melding? Ja, også det er mulig! Alt dette høres kanskje ut som svart magi, men dette er faktisk byggeklossene brukt til å verifisere e-stemmene i årets Stortingsvalg. Men det er mer som skal til enn kryptografisk magi for å gjennomføre en slik verifikasjon. Verifikasjonen skal f.eks. kjøres live fra en vanlig laptop under valgnatten, så parallellisering og gode loggmeldinger er viktige for at det skal være mulig. Vi vil også belyse litt av arkitekturen til e-valgsystemet, og noen av de andre tiltak som ble utført for å sikre opptellingen.

Har du opplevd å sende modulen din til testing, og alt du får tilbake er teite meldinger om fontstørrelse, ordlyd, formulering og plassering på skjermen? I så fall er det på tide å begynne å programmere det som ikke har noen front-end! Bakgrunnsjobber, middleware, batch, mulighetene er endeløse og gledene er mange!
Hadde det ikke vært mer interessant å sette fokus på den delen av koden hvor hjernecellene faktisk får bryne seg på annet en formattering av tekstfelter og knapper? Denne lyntalen er en hyllest til kodeskrivingens mange gleder og til fryden over å kunne konstruere logikk rett fra hodet uten ytre distraksjoner. Man vil få en kjapp introduksjon til enkle metoder som kan hjelpe programmereren med å holde arbeidsdagen produktiv og gøy, samt en uhøytidelig "rant" over mengden langtekkelige og, i den store sammenhengen, uvesentlige småproblemer knyttet til å lage en front-end.

Testdrevet javascript med RequireJS og Jasmine med automatisk mocking av avhengigheter og stubbing i Mockito-stil.
Tester i javascript kan være vanskelig nok å sette opp og vedlikeholde. Et modulsystem som RequireJS gjør det betydelig enklere, men det kommer også med sine utfordringer. Denne lyntalen vil demonstrere hvordan man kan utnytte mulighetene i RequireJS ilag med et testverktøy som Jasmine til å skrive lettfattelige og vedlikeholdbare tester hvor man har fokus på hva koden skal gjøre uten innblanding fra omverdenen. Dette involverer isolering av modulen som testes med automatisk mocking av avhengigheter og stubbing i Mockito-stil.

Pushing a new release into production is always raising the stress-level of the developers. By using beta-users and implementing functional switches in the release we can isolate bugs or avoid exposing functionality without having to do a new release. Stress-level is down and quality is up.
Pushing a new release into production is always raising the stress-level of the developers. Sometimes functionality also has to be taken out of a release because of bugs, lack of time to test it, or a general uncertainty from the product owner if this actually is the right thing. Rolling back a release is not fun either. To keep our four-week release-cycles and avoid the overhead with last minute changes to the release, or building emergency patches, we introduced beta-users as a role in the system. We also started to add functional switches on all new complicated functionality or parts of the functionality. In this way we can expose new functionality or new layout only to a group of users, and we are able to partly put functionality into production or turn of buggy functionality without deploying the application. Our experiences with this is that it has become more used by the product owners to release new functionality according to their schedule, than by the DevOps-people to hold things back. We have also avoided both rollback and emergency-patching thanks to this.

BASE transactions are changing the way we have to develop applications dramatically - a lot more than most people think in the first place. This session not only explains why but also gives you a step by step introduction how to make your application BASE-ready based on real code examples. Let's get ready to survive in a BASE world!
NoSQL, Big Data and Scale-out in general are leaving the hype plateau and start to become enterprise reality. This usally means no more ACID tranactions, but BASE transactions instead. When confronted with BASE, many developers just shrug and think "Okay, no more SQL but that's basically it, isn't it?". They are terribly wrong! BASE transactions do not guarantee data consistency at all times anymore, which is a property we became so used to in the ACID years that we barely think about it anymore. But if we continue to design and implement our applications as if there still were ACID transactions, system crashes and corrupt data will become your daily company. This session gives a quick introduction into the challenges of BASE transactions and explains how to design and implement a BASE-aware application using real code examples. We start with a pure ACID application and transform it step by step into a BASE application. Additionally we extract some concrete idioms along the way in order to preserve the ideas in a concise way. Let's get ready to survive in a BASE world!

Patching representations in HTTP APIs can be hard, but no longer, JSON Patch is here.
Har du noen gang ønsket å kunne delvis oppdatere ressurser i et API? Da kan man bruke feks HTTP Patch metoden, som var lansert i RFC-5789 Problemet som skal løses er å oppdatere deler av en JSON representasjon. Dette kan gjøres via JSON-PATCH, nettopp lansert i RFC-6902. Jeg kommer til å bruke et Scala api som jeg har laget for dette.

When the wise, bearded men designed Java, there was one piece of the puzzle they just didn't get around to finishing: Modularity. This talk explains the benefits of modular architectures and shows you how to implement it for Java based applications.
Back when the Java language and platform was designed there was one piece of the puzzle that the wise bearded men just couldn't get around to finishing properly: Modularity. Modularity done right can be incredibly liberating for your team: Features can be developed, tested and deployed independently. The need for branching and merging evaporates. Dead code can be efficiently and safely removed from your codebase. Developers can innovate and experiment without risking their sleep. People outside your team are free to extend your software without having to ask. They don't even need to know you exist. So if modularity has all of these benefits, why don't we see a lot more of it? Because implementing modularity on you own is hard and tricky. OSGi was promising, but failed to deliver because it was too complex. This talk shows you how to efficiently add modularity code base today. We start by presenting modularity as an architectural pattern and describe a structured approach to designing modular APIs. We then dive into the technical implementation of developing, packaging, distributing and deploying modules on the Java platform. We finish off by showing some real life implementations of modular Java systems.

En introduksjon til Java Native Access (JNA), stormannsgalskap og hvordan man implementerer taskbar og desktop i Java.
Det var en vakker vinterkveld med upåklagelig skiføre, men jeg var syk og måtte derfor være inne og trøsteprogrammere. Jeg startet prosjektet "jna-example" med ingen annen ambisjon enn å bruke JNA (Java Native Access) til å kalle én stusselig nativefunksjon. Lite ante jeg at prosjektet i løpet av noen få timer skulle utarte til en fullt fungerende taskbar ... men jeg klarte ikke å stanse: Enkelheten, hastigheten og maktfølelsen var berusende. Snart var virtuelle desktoper i Windows en realitet og ikke lenge etter ble startmeny, batteriovervåking og andre widgets definert gjennom en pluginbasert arkitektur. Nå har jeg forstått at jeg trenger hjelp: Jeg trenger en sal med negative tilhørere! Noen må fortelle meg at det er galskap å implementere dette i Java... Vi ser på: - Alt du trenger for å starte ditt eget prosjekt med JNA. - Hvordan nativekall fra ren javakode er mulig. - Representasjon av structer, pekere og annet. - Morsomme anekdoter om Win32 og X. - Arkitekturerfaringer fra prosjektet. - Demo av hvor langt galskapen har brakt meg.

This is a story about how to scale better and faster by keeping it simple. Two prototypes, 0MQ vs HTTP, and one winner. The story is told through our marquee high performance Varnish Cache invalidation product, written in Java, that is capable of 45 thousand cache invalidations per second with ease using only basic HTTP. We aim to share some experience, lessons and fun along the way.
This is a story about how to scale better and faster by keeping it simple, told through our marquee high performance Varnish Cache invalidation product, written in Java. The cache invalidation product, known as the “Super Fast Purger”, is a RESTful API that is designed to deliver purge requests to multiple geographically distributed Varnish Cache installations. The current implementation is capable of receiving and distributing 45 000 thousand cache invalidation requests per second with ease. It is believed that the upper limit of the throughput is yet to be determined for the Super Fast Purger as the software implementation was limited to network and hardware capabilities during benchmarking. The Super Fast Purger was conceived as a plugin for the Varnish Administration Console. Prior to the commercial release of the cache invalidation product, two prototypes were developed internally. The first was a highly concurrent and sophisticated prototype with 0MQ, Protobuffer and Disruptor as key components. The second prototype was development without any external packages, APIs or frameworks. By utilising only native Java 1.6 SE, a subset of HTTP 1.1 protocol was implemented and a simple HTTP server was conceived as the RESTful platform to handle purge requests. With stark contrast in development approach and technology choices, the two prototypes were benchmarked, tested and compared. The findings is that the simple HTTP server as a RESTful platform out performed the highly sophisticated and concurrent prototype by a factor of 100. This presentation aims to share the findings, lessons, and the fun experience that was the Super Fast Purger.

This will be a brief talk about AngularJS - the MVW javascript framework from Google. After a brief introduction, we will cover topics such as data binding, directives, templating, filters, dependency injection and some points to keep in mind when developing angular applications.
You are a developer and have developed a lot of front end code in html & javascript. You've been reading about all of these new javascript frameworks (AngularJS, Ember, Batman) and are wondering what they're all about. This talk will be a quick introduction to AngularJS and why you should check it out. We will also offer some pointers for what to watch out for when diving in! Topics covered include - data binding, directives, templating, filters, dependency injection and some points to keep in mind when developing angular applications.

Good programming is not something that can be explained, it has to be experienced. In this talk, you will see pair programming, refactoring and test-driven development in action.
Good programming is not something that can be explained, it has to be experienced. In this talk, you will see pair programming and test-driven development in action. The talk will involve the audience and draw on your insight to show how programming can be more fun! If you want to understand how serious test-driven development looks, this talk is for you. As a programmer with over a decade of experience in test-driven development and refactoring, Johannes Brodwall likes to pair program with others to exchange experience, tips and tricks. In preparation for this talk, Johannes has been pair programming with local developers. During the talk, he will replay one of these sessions with a local developer. He will then discuss the practices, tricks, design ideas and interaction that they showed, showing concrete ideas for how you can become a better developer. Johannes is looking for local developers to pair program with for this talk. If you’re a Java developer with a few years experience who would like to some really cool tricks and gain some local credibility as a developer, please contact him at @jhannes on Twitter.

Har du opplevd at feilsøking er vanskelig, fordi loggen du leser er umulig å forstå? Eller at viktig informasjon rett og slett mangler? Eller bryr du deg ikke om loggene i det hele tatt? Da er du ikke alene, og jeg vil gjerne dele 5 enkle tips som kan spare deg timesvis av hodepine!
Har du opplevd at feilsøking er vanskelig, fordi loggen du leser er umulig å forstå? Eller at viktig informasjon rett og slett mangler? Har du irritert deg over debug-linjer som bare gir mening til utvikleren som skrev dem, og nå fremstår kryptiske? Eller bryr du deg ikke om loggene i det hele tatt, fordi de inneholder altfor mye informasjon? Da er du ikke alene, og jeg vil gjerne dele 5 enkle tips som kan spare deg timesvis av hodepine! Logging er applikasjonens interne grensesnitt!

Memory management, garbage collection and recommendations on different configuration options to control gc, and memory compartments
Tuning the JVM - focused on memory management, garbage collection and recommendations on different configuration options to control gc, and memory compartments

This talk is a practical experience report from removing all XML from a project's production code. Through code samples, it will show how your typical enterprise application changes.
First part; - What's wrong with XML ? - Webapp without web.xml; samples for Jetty - Spring without xml using javaconfig - Programmatic logging configuration Second part: - Implications on application design - Implications on application testability This second part will cover subtle changes to overall application composition that turn out to have significant impact on simplicity, and will show that this is the missing link in making "loose coupling" really shine. Third part: Migration strategies for current code

This speach examplifies ways of using default methods in Java. Contains examples on how to use and not to use default methods in Java.
Irriterer du deg over interfacer som krever implementasjon av en drøss metoder du ikke har noe forhold til ? Sløser du tid på å implementere kode som godt kunne vært skrevet en gang for alle ? Ønsker du å legge til metoder i API-et, men tør ikke fordi det knekker andres kode ? Java 8 introduserer default methods. Dette tillater implementasjonskode ikke bare i klasser, men også i interfacer. Samtidig beholdes bakoverkompatibilitet. Denne lyntalen viser eksempler på bruk av default-metoder. Eksemplene viser hvordan default-metoder - gir mulighet for miksin-klasser - kan kombineres med generiske typer - ikke bestandig er like lette å forstå - kan ødelegge bakoverkompatibilet Lyntalen viser at default-metoder er noe man tjener på å ha i sin verktøykasse, at de kan gi fleksible design men at de ikke passer for alt.

This talk will present the configuration system designed to manage run-time configuration for some of Yahoo!s serving systems; describing how this system, developed by a small development team in Trondheim, tackles some of the very real challenges when managing a large distributed system.
Managing a small system is simple. But as a system grows, more services are added, and data and computation needs to be distributed. All of a sudden, you find yourself in a configuration nightmare, where both the time needed to change the configuration and human errors made in the process increase. A large scale system typically involves thousands of hosts, and multiple processes running on each of those hosts. Cloud platforms such as Heroku and Amazon tries to simplify this by providing higher level abstractions of the services and how they are connected. This requires that they run some system management of the software running inside the cloud. In Yahoo!, we run large scale systems, and this talk will describe the configuration system developed by a small development team in Trondheim to manage run-time configuration for many of Yahoo!’s serving systems. The talk will present how our configuration system grew from a simple set of config files to a generic configuration system for the cloud. It will describe how it works, and what we used to build it.

Explore the disconnect between the dire outcomes for dynamic language programs predicted by advocates of static typing, versus the near absence of type errors in real world systems built in Python, Ruby and Clojure and the many successful systems built in dynamic languages.
Some programming language theorists would have us believe that the one true path to working systems lies in powerful and expressive type systems which allow us to encode rich constraints into programs at the time they are created. If these academic computer scientists would get out more, they would soon discover an increasing incidence of software developed in languages such a Python, Ruby and Clojure which use dynamic, albeit strong, type systems. They would probably be surprised to find that much of this software—in spite of their well-founded type-theoretic hubris—actually works, and is indeed reliable out of all proportion to their expectations. This talk—given by an experienced polyglot programmer who once implemented Hindley Milner static type inference for “fun”, but who now builds large and successful systems in Python—explores the disconnect between the dire outcomes predicted by advocates of static typing versus the near absence of type errors in real world systems built with dynamic languages: Does diligent unit testing more than make up for the lack of static typing? Does the nature of the type system have only a low-order effect on reliability compared to the functional or imperative programming paradigm in use? How often is the dynamism of the type system used anyway? How much type information can JITs exploit at runtime? Does the unwarranted success of dynamically typed languages get up the nose of people who write Haskell? For the answers to these important questions, and more, don’t miss this session.

Never change your data
If you are used to traditional databases, then to only append and never update your data may sound like a crazy idea. However, not only does this enable historical queries, but also enhances fault tolerance and scalability. In this presentation we briefly describe two immutable data stores (Rich Hickey's Datomic and Greg Young's EventStore) and compare their different data models using an example problem domain. Along the way we learn about CQRS, Aggregates, Projections and why you want your data to be immutable. EventStore is a data store for applications using event sourcing and time-series data. EventStore runs on .NET and Mono. Datomic is a database of time-based facts, with declarative queries and ACID transactions. Datomic is written in Clojure and runs on the JVM.

Noen enkle funksjoner gjør bash shellet ditt til en fryd å jobbe i. Det er mange å ta av, men her er noen av mine favoritter som benyttes daglig.
Fire enkle tips for å gjøre bash shellet ditt bedre å jobbe i: * Up up up * Jeg vet hvor du bor Git * Historikk slik den burde være * Tab-completion med kontekst

Making I/O programs compose Reactive programming
IO is usually quite hard to tackle in a functional way. The predominant paradigm for I/O is the cursor. A cursor is a data structure that holds the current state of an I/O resource and provides a function to retrieve the next data available from that resource. This approach lacks some very properties we functional programmers care about: - composability Writing explicit I/O loops makes to hard to compose - not functional Ideally we write functions that transform input to output but pull based I/O (where you read the chunks) makes it hard to write pure functions There are already libraries that provides some abstraction to overcome these shortcomings but somehow lacks in composability. In this presentation I will explore Enumeration based I/O with iteratee and how that makes I/O operations both functional and efficient. I will take some real world example use cases using Play framework where this approach has been used with success.

So your project is just getting started. Or maybe you're just about to embark on a new release. Or new members just joined the team. What now? The attention and enthusiasm in your project will never be higher than now. This talk shows how to get the most out of it.
So your project is just getting started. Or maybe you're just about to embark on a new release. Or new members just joined the team. What now? In either situation, your project will have a lot of energy and attention right now. But at the same time, there's probably a lot of uncertainty about what to do first. Many projects waste this valuable time without a clear plan or purpose. In Exilesoft, we have refined activities to deal with these problems, even with the additional constraint that the team may be distributed geographically. In this talk, I share a typical plan of what activities to do every day in the first weeks together with a set of activities which yeld tangible results in terms of team building, vision, architecture and a coherent working system in a minimum of time. Come to this talk if you want to kick start your project and get on the right track fast.

If you want to know what differentiates Backbone.js and Angular.js and get a better feel for which one you should use then feel free to head over.
I'd like to talk about the differences between two popular frontend Javascript frameworks that I've had experience with over the last 1,5 years. I'll give a short introduction to what they are and how they work before I dive into the differences between them, my experience from using them in customer projects and what I consider the pros and cons. This lightning talk does not aim to teach you how to use either one of those frameworks, but may be of interest if you're using one or are planning to. If you're not familiar with either of them you'll still get a quick fly-by on how they'll affect your frontend code and perhaps be in a better position to choose between them. The talk will be held in Norwegian.

Why are we still creating software with so many security-related problems?
What are the most common mistakes made during the software development process that leads to security problems in the finished product? In this talk, Peter af Geijerstam will present the top 10 issues leading to insecure software systems. This talk is NOT about the technical aspects of buffer overflows, shell code or use-after-free vulnerabilities. It is about language- and OS-independent security-aspects such as design decisions, concepts, mistakes and bad luck.

Gjør code-review til en lek med pull-requests.
Lei av å måtte lete rundt i commit-loggen for å finne de relevante commitene til en endring? Lei av å ikke se det store bildet i havet av endringer? Samle nye features i pull-requests og få oversikt med en gang slik at du kan gjøre code-review kjappere og bedre enn før.

Once you realise the true enemy of software development is complexity, not waterfalls, you can start rethinking how we write our software. Come learn why modern languages like Scala and Clojure lead to fundamentally better software systems than any of yesterday's tricks.
Have you noticed that in spite of all our oft repeated Best Practices, those bugs don't seem to stop coming back no matter how many tests we write, that pile of technical debt still seems to keep growing no matter how much we refactor, and we keep missing those deadlines no matter how we organise our scrum board? Perhaps it's time to stop listening to those who shout the loudest and start applying actual reason to the problem for a change. The programming paradigms that served us so well through the 80s and 90s are no longer adequate for developing software in the modern world. Building systems the way we're used to building them always seems to end in the inevitable death march towards exponential complexity. But once you start asking the right question—"what's causing all this complexity?"—the answers turn out to be obvious. Debugging is only hard when you can't reason about your code. Concurrency is only hard when you can't predict the state of your code. Reusability is only hard when your components aren't naturally composable. These problems are what the modern generation of functional programming languages—Scala, Erlang, Clojure—have been designed from the ground up to overcome. This is what the really smart people in our field have been up to lately, and it's really time you put down those Post-Its and come let me show you why it's a really, really big deal.

In this session you will learn how to write Java code in a functional way without using Java 8.
You’ve probably heard the buzz about functional programming and you may have glanced at the new Lambda features in Java 8. What is less known is that it's actually possible to leverage some of the functional-style techniques even in older Java versions. This means that you can program in a functional style, even if your organization has not yet updated to Java 8. In this session, you’ll learn about real-world experiences with functional frameworks such as LambdaJ, Functional Java and Guava. What should you consider before adopting them? How do they compare against one another? If you are stuck with a legacy Java version and want to be prepared for the functional future of Java 8, make sure to attend this session.

Learn about a slew of obscure but powerful Java libraries that you just cannot do without once you know they exist. Attention usually focus on the big projects, but there are tons of great gems that solve their little problem so well. We'll learn about more then thirty of those, that you can start using immediately!
Open source library and technology stories tend to be focused around big, famous and established projects. Enough of Spring, Akka and Hadoop: there is much more than just the big guys! The long tail treasure trove is full of hidden gems, libraries, utilities and snippets that make developers' lives easier and provide important functionality. This talk is all about the small stuff that shaves so many hours off of development time and improves productivity by orders of magnitude. We'll learn how off some of the most interesting small itches that got scratched by providing tools you just can't do without once you get to know them. We will present no less than 30 (thirty!) Java Open Source projects, providing code examples and small demos for each one of them. By no means is this intended as a comprehensive view on everything that's in the Long Tail: our expectation is to make attendees aware of the existence, and able to locate more, of a plethora of readily available open source software, while providing a few hints about what are, in our experience, some of the best hidden gems in the “small yet beautiful” landscape.

Git is powerful. It can change the way you interact with your team members when you know what's possible. You will learn Git workflows and direct integrations with ALM tools. Git your team productive and awesome!
Git is not just a version control system. Git can change the way you interact with your team members. Lot's of teams don't think about reflecting their development workflow in Git and just use it out-of-the-box. Git, however, can be much more powerful, giving your team a boost in productivity, protecting your delivery pipeline and helping you to work better together. In this session we will start with a central workflow that is used by a lot of Subversion teams. You will learn how to practically integrate ALM solutions like continuous deployment, code reviews, change tracking and much more into your individual workflow. You will find out how to protect your master branch from accidental commits, broken builds and unreviewed code. This presentation will help you discover the best way to work together as a team - whether you're yet to migrate to Git or even an experienced Git user.

After a successful proof-of-concept in 2012, we present the pitfalls from implementing grid computing at the most important project in Tax Norway.
Etter en vellykket proof of concept i 2012 har Skatteetaten innført grid computing det viktige prosjektet for Modernisering Av Grunnlagsdata (MAG). Denne sesjonen presenterer erfaringene fra implementasjonen, med fokus på fallgruvene vi møtte underveis. Dette inkluderer kostnaden av redundans og flytting av data, kjøring av distribuerte jobber, kompakt representasjon av objekter, produksjons- og driftsarkitektur samt testing av tekniske krav og robusthet. Vi tar til slutt en en titt på alternative plattformer og teknologier til grid-teknologi.

Learn how to build & code a wireless missile-launcher style deployment button with enterprise-grade security for your product manager or team using a Raspberry Pi and some easily-available components.
Continuous Delivery is great, automating the whole build pipeline from commit to QA. However, that final stage of "Deploy release to production" is often still manual, especially in enterprise environments. The Product Manager will give the order, but it's still up to the ops team to perform the actual deployment process when they get the sign-off email. This talk shows you how to build and code a physical deployment box to eliminate that last manual step. Using a Raspberry Pi, some cheap components and a bit of time you can do it for about â¬100. The product manager can now perform the deployment herself by selecting the build number, arming the device with a key, and lifting the missile switch cover to press the deploy button. Outside of performing deployments, the box even works as a build monitor showing the current build with a red or green background to show the build status. You will learn how easy it is to build a Raspberry Pi-based gadget, how to keep its software updated using Chef, and how to securely store enterprise credentials on it.

I denne lyntalen ser vi på hvordan 2-faktor autentisering faktisk virker, hvor sikkert det er og hvordan man kan angripe metoden. I tillegg ser vi på hvilke begrensninger 2-faktor autorisering har, samt hvor kost-effektivt det er.
2-faktor autentisering blir mer og mer vanlig i dagens samfunn. Det brukes til alt fra innlogging i nettbank til mobile applikasjoner og spill. 2-faktor autentisering krever at en bruker benytter seg av to av tre faktorer for å identifisere seg selv; Noe brukeren vet Noe brukeren har Noe brukeren er De fleste har hørt om 2-faktor autentisering, men hva er det egentlig som foregår? Hvor sikre kan vi være på en angriper ikke klarer modifisere informasjon vi sender og kan vi stole på at informasjon vi mottar er fra den som påstår å ha sendt det? I denne lyntalen ser vi på hvordan 2-faktor autentisering faktisk virker, hvor sikkert det er og hvordan man kan angripe metoden. I tillegg ser vi på hvilke begrensninger 2-faktor autorisering har, samt hvor kostnads-effektivt det er. Hva skal til for å hacke deg inn i nettbanken? Hvordan kan du få tak i selvangivelsen til sjefen? Hvor lett er det å hacke Steam kontoen til kompisen? Kom og finn det ut!

Chef for developers - what you need to get started with coding your infrastructure
There's a reason Heroku is so popular. As developers we often prefer to focus on coding (and sometimes providing business value) over setting up and maintaining servers and infrastructure. Setting up a full stack with e.g. apache/nginx, containers/wrappers, permissions, monitoring, alerts etc. can be a daunting task if you have not experienced it before. Even more terrifying is the thought of having to do it all again (from memory, or some patchy notes) if the server crashes or you need to scale out horizontally. From a developer's perspective I'll show you how "easily" you can setup your own servers with Chef.

Learn how to provide a powerful command line interface to your JVM with CRaSH the shell for the Java Platform.
CRaSH is an open source shell for extending and monitoring a Java Virtual Machine. The shell can be accessed by various means, either remotely using network protocols such as SSH or locally by attaching a shell to a running virtual machine. Commands are written in the Groovy language and can be developed live making the extensibility of the shell easy with quick development cycles. CRaSH comes with a bunch of commands such as thread management, log management, database access and JMX. The session will begin with an introduction to the shell, showing basic CRaSH features like auto completion and basic commands. The main part of the quickie will focus on showing how to develop CRaSH commands with several examples, showing how easy and powerful the development of a command can be. The target audience is pretty much anyone using a JVM. Attendees will learn how to install CRaSH, connect to an instance and develop a CRaSH command to interact with virtual machine resources or services.

Bruker applikasjonen din log4j? Vurderer du å bytte til logback, men er usikker på de faktiske gevinstene? Frykter du at det tar mye tid å skrive om applikasjonen? I denne lyntalen viser jeg hvorfor og ikke minst hvordan du skriver om applikasjonen din til å bruke logback.
Bruker applikasjonen din log4j? Vurderer du å bytte til logback, men er usikker på de faktiske gevinstene? Frykter du at det tar mye tid å skrive om applikasjonen? I denne lyntalen vil jeg gå gjennom de viktigste fordelene med logback sammenlignet med log4j. I tillegg vil jeg vise hvordan man går frem for å skrive om en applikasjon som bruker log4j til å bruke logback, og hvilke utfordringer man kan støte på og hvordan disse kan løses.

This isn't another JavaFX presentation by a technology evangelist at Oracle. This presentation is about the experiences from using JavaFX in a big commercial project -- the things you don't get by reading the manual.
This session shares the experiences from the development of LoadUI, a large JavaFX-based open source project. The following topics are discussed: • Using JavaFX Scene Builder as a bridge between designers and developers. • GuavaFX – an in-house developed functional library for JavaFX’s ObservableLists. Why the functional paradigm fits JavaFX perfect. • Migrating from 30 000 lines of JavaFX 1. • Automated GUI testing – a simple approach. • Combining MigLayoutFX2 and GroovyFX in a domain specific language. Along the way, you will also see how key JavaFX features, such as real-time charts, custom controls, the WebView, drag-n-drop, animations and effects are being used in LoadUI to make the user interface a competitive advantage.

Søkemotorer kan løse langt fler utfordringer enn en søkeboks gir. Du har kanskje et søkeproblem uten å være klar over det?
Elasticsearch, en open source søkemotor bygd på Lucene, får stadig mer oppmerksomhet - ikke bare fordi den er glimrende til å løse typiske søkeproblemer, men også fordi den kan brukes til analyse- og "big data"-utfordringer. Foredraget gir en oversikt over hva søkemotorer er gode på, relaterte problemer du kommer over, hvordan Elasticsearch kan bidra – samt hvordan den passer inn i teknologistacken din. Det er ingen tutorial, men med et relativt høyt tempo og eksempler med realistisk kompleksitet gis en oversikt over hva som er mulig. Vi runder av med hvordan Elasticsearch kan klassifiseres i mylderet av "NoSQL"-databaser.

Many of the modern web services are RESTful and use hypertext as an interface. But how to assure they are both safe and accessible? OAuth comes in and makes itself comfortable here. This short introductory will walk you through some good practices in hypertext driven interfaces and then will put some light on OAuth 2.0 - standard used even by the biggest players - and its application into our web service.
Many of the modern web services are RESTful and use hypertext as an interface. But how to assure they are both safe and accessible? OAuth comes in and makes itself comfortable here. This short introductory will walk you through some good practices in hypertext driven interfaces and then will put some light on OAuth 2.0 - standard used even by the biggest players - and its application into our web service. When you design RESTful hypertext driven API focus on usability, make it that clear that your users don't need any manual. Make it in the purest way so that it will be accessible for the broadest audience possible. Then, if you will also use OAuth you will spread it even further to be usable out of the box by clients that already use this standard. I will present briefly to participants flow of the authorization and authentication of the protocol and its security aspects. The most important thing is how we can benefit from applying it to our web service? I will point some key areas. For example the resources you want to serve can be and should be divided into logical and consistent parts - each of them require different level of access, which ideally suits to OAuth scopes. But how the whole system could look like? The diagram will show how example system can be composed of and will point out technologies that can be used to build it.

You probably know that you can transmit arbitrary data from point A to B using the internet. But how does this actually work?
You know that the internet lets you send data from A to B, and that it's a global network. But how does this actually happen? Which bits and bytes are transmitted on the copper cables from your computer to the WiFi access point or the plug in the wall, and beyond? What happens when you ping another computer? Why doesn't ping care about port numbers? How can you get an IP address from your router at home, without being a catch 22? How does the router know how to talk to your machine before your machine has an IP address? Why exactly is HTTPS secure? What does the internet lack that requires HTTPS for security?

Writing well behaved http applications is hard. Very hard. But it shouldn't be that way... Unfiltered Directives is a library aiming to solve that problem
Writing well behaved http applications is hard. Very hard. But it shouldn't be that way... Unfiltered Directives is the latest addition to Unfiltered - a Scala toolkit for servicing http requests. Directives is an attempt at making it simpler to write readable and well behaved web applications. By leveraging ideas from monadic parser-combinators, Unfiltered-Directives is a breath of fresh air in a world of ignorant web frameworks. The presentation will demonstrate why http is hard to do right, before diving into a discussion of http, parsing, functional programming, monads and how it all comes together to form a simple and usable library.

Noen ganger trengt en backend til mobil-idèen din? Helios kan hjelpe deg! Helios er enkel og rask mobilbackend som dekker de fleste behov!
Mange app-prosjekter strander fordi man trenger en form for sentral server for å knytte sammen klientene sine. Ideen din trenger kanskje sentral lagring i skyen, push-meldinger, konfigurasjon eller brukerhåndtering? La meg introdusere Helios! Fra mannen bak rammeverket AFNetworking og IOS-bloggen NSHipster, Matt Thompson, kommer Helios. Kort fortalt er helios en app-backend basert på ruby, sinatra og postgres som er skreddersydd for å deploye til heroku. Helios spiser din CoreData-modell og gir deg et rest-api for lagring i skyen, den gir deg også push-services og brukerhåndtering. Det beste med Helios er ledsagerbibliotekene til iOS, dette er biblioteker som (relativt) sømløst lar deg koble appen din til den heroku-hostede backenden.

Lær hvordan Angular.js kan brukes til å lage nestegenerasjons applikasjoner i nettleseren.
Hvordan AngularJS enkelt lar deg lage en moderne webapplikasjon, selv med kjente og trauste Spring og Hibernate på serversiden. Dersom du lager webapplikasjoner og brukeropplevelse er noe du bryr deg om, så burde Angular være av interesse for deg. Angular oppgraderer nettleseren og lar den gjøre ting du knapt trodde den var i stand til. For et drøyt år siden satte vi oss som mål å lage landets første brukervennlige regnskapssystem. På fritiden. Spring og Hibernate kjente vi godt nok til å vite at de ikke ville stå i veien. På klientsiden stod det verre til, det eneste vi egentlig var sikre på var hva vi ikke ville bruke (ExtJs, GWT...). Vi trengte noe med superkrefter. Vi trengte AngularJS.

Hvordan gjøre hobbyprosjekter som ender opp i ingenting om til prosjekter som gjør at du utvikler deg selv som programmerer og får mer selvtillit i den daglige utviklingsjobben.
Har du noengang programmert natt og dag på et hobbyprosjekt, for så å plutselig arkivere det for evig tid uferdig i nærmeste versjonskontrollsystem? Har du 50 uferdige prosjekter på GitHub og føler at du ikke får nok igjen for all tiden du bruker på det? Jeg vil i denne talken presentere tips for å få mest mulig ut av hobbyprosjekt; både for egen mestringsfølelse, og karrieremessig.

A lot of people have heard of Event Sourcing, but few has really understood the strength of it. All the discussions you hear about data storage mainly focus on what type of storage you should use, but few discussions focus on what to store. I will in this presentation give a short introduction to event sourcing and why I think it is a good way to store your data.
A lot of people have heard of Event Sourcing, but few has really understood the strength of it. All the discussions you hear about data storage mainly focus on what type of storage mechanism you should use, but few discussions focus on what to store. I will in this presentation give a short introduction to event sourcing and why I think it is a good way to store your data. My goal with this talk is to give you the basic understanding in how to use event sourcing and why you should use it. I will also show you how event sourcing could guide you building better software focusing on what the business really need instead of just storing data.

Groovy er et uttrykkskraftig programmeringsspråk med mange bruksområder. Presentasjonen viser hvordan man kan bruke Groovy for å skrive bedre og mer lesbare enhetstester i Java.
Hvordan skrive bedre og mer lesbare enhetstester? Groovy er svaret. Groovy er et enkelt og uttrykkskraftig programmeringsspråk for javaplattformen. Med sin enkle og smidige syntaks, rike bibliotek og ikke minst, muligheten for å integrere med vanlig javakode, fremstår Groovy som et kraftfullt språk med mange bruksområder. Et av disse er enhetstesting. Ved å kombinere Groovy og JUnit så har man praktisk talt alt man trenger for å skrive en fullverdig enhetstest. Groovy har nemlig innebygd støtte for både mocking og stubbing og i tillegg så har man tilgang på enkle API som gjør det superenkelt å verifisere resultater. Presentasjonen gir en introduksjon til hvordan man kan bruke Groovy for å teste javakode.

Ruby on Rails er nok ikke det første folk tenker på når man har ett enterprise økosystem bygd opp rundt Java. Denne lyntalen vil beskrive hvordan det er mulig å faktisk kjøre Ruby on Rails applikasjoner selv om man er bundet til Java tung enterprise arkitektur.
Ruby on Rails er nok ikke det åpenbare teknologivalget når man sitter dypt i enterprise Java verden, men i vinter implementerte Oslo Kommune 2 nye fagsystemer i (J)Ruby on Rails. Applikasjonene måtte oppfylle krav om å kunne releases, deployes, og kjøres på Java miljøet som allerede fantes på Oslo Kommunes platform. I lyntalen vil jeg gå igjennom hvilke teknologier vi brukte, hvilke problemer vi støtte på, og hvordan vi integrerte Ruby on Rails for å sømløst kunne bygge og deploye applikasjonene på platformen, som om de var en helt vanlig Java applikasjon.

Tetris er et klassiskt spill hvor mye av utfordringen ligger i å holde kompleksiteten nede. For å lykkes med det, kan det være lurt å tenke litt fremover, og ikke bare neste brikke. Noen ganger kan det også være lurt å ta en pause, for å ta tilbake kontrollen. Mye av dette kan også relateres til softwareutvikling.
En gjenganger i mange prosjekter er kompleksitet. Den vokser gjerne naturlig etterhvert som prosjektet går fremover. Men ofte opplever jeg også at mye av kompleksiteten kunne vært unngått dersom vi hadde gjort en bedre designjobb. Nå som alle skal være smidige, er det mange som har sluttet med design. Vi starter bare å kode, og forsøker å endre oss når vi får tilbakemeldinger. Men det er ikke alle endringer som er like lette å gjøre i etterkant.

How do you know what to build of your customer wants a "secure solution with a good amount of flexibility and user friendliness"? You don't! Force the customer to be more specific!
Maximizing customer value is one of the most important guiding principles in agile development practices. After some years with experience with agile practices, we now see that an exclusive focus on value expressed as functionality can seriously undermine the quality of the software product. This manifests itself as bad usability, poor performance or unchangeable software. This has led to a slightly stronger focus on code quality and software architecture to solve these issues. But in all project environments resources; time and money, are limited and the owners of the project initiative want value for money. Quality is also perceived as a technical or architectural issue not something the product owner should care (or know something) about. It is much more difficult to measure quality compared to time, cost or functionality, so it's hard to know if you're delivering software with sufficient quality or not. And if you can't measure quality it's difficult to challenge your development team on it. This is where measurable quality requirements come to the rescue. In this talk I will suggest how you handle and formulate quality requirements in a way that lets the customer - prioritize between different quality attributes - prioritize between quality and cost - measure if acceptable quality is delivered I will also explain the clear distinction between two types of non-functional requirements, constraints (technology, design, architecture) and quality requirements.

Managing Asynchronicity in JavaScript with RQ
Turn based servers such as Nodejs are now joining turn based browsers in providing race-free and deadlock-free interactivity. The event-driven model has long been popular in UI systems, but the nature of work in servers presents some new challenges. Functional programming provides solutions, including monads, arrows, promises, and various flavors of FRP. This is another such solution, targeted specifically to the challenges of high performance web applications.

Se for deg en ideell verden hvor utviklingsmiljøene dine for store, tunge enterprise-prosjekter settes opp out-of-the-box, og kan reverteres til en ryddig og feilfri tilstand hvis noe skjærer seg. Drøm eller virkelighet - virtuelt utviklingsmiljø er begge deler!
Se for deg en ideell verden hvor utviklingsmiljøene dine for store, tunge enterprise-prosjekter settes opp out-of-the-box, og kan reverteres til en ryddig og feilfri tilstand hvis noe skjærer seg. Drøm eller virkelighet - virtuelt utviklingsmiljø¸ er begge deler!

Jeg kan fortelle hvorfor drift bør elske cloud og PaaS. Men det er ikke sikkert utviklere vil like grunnene.
Noen ganger føles det som om drift bare holder igjen, helst vil unngå applikasjoner, oppdateringer og utviklere. Hvorfor kan vi ikke gjøre noe spennende? Det er trist å fortsatt holde på med relasjonsdatabaser når alle snakker om NoSQL. Det er kjipt å måtte bruke JSF når alle snakker om rike klienter i HTML5 og JavaScript. Hvis man bare fikk bestemme selv. Litt self service på cloud? Som Heroku? Så kunne man blitt mye mer effektiv og hatt det morsommere på jobb. Fett! Nå er det mange grunner til at man ikke kan ta i bruk Heroku i organisasjoner. Men hva hvis man kan gjøre det samme på sine egne servere? En egen Platform-as-a-Service? Da vil faktisk mange av hindringene forsvinne, vi må bare overbevise drift først... Jeg kan fortelle hvorfor drift bør elske cloud og PaaS. Men det er ikke sikkert utviklere vil like grunnene. Jeg vil gi en kjapp oversikt over hva som finnes på markedet for Platform-as-a-Service in-house, og noen betraktninger om hva som du må se etter. Vi har gjort oss noen efaringer, og har noen midlertidige resultater.

Every statement in your system is a potential defect. How can know for sure that your test suite will catch these bugs? By using mutation testing tools you will be able to run your tests on an automatically mutated version of your codebase and actually verify that not only has your code been run in your tests. They discover the bugs that may or may not be introduced.
Are you sure your coverage-report can be trusted? Yes, you run 75 percent of your code during unit testing, but will these tests actually catch if you introduce a bug? By using a mutation testing-tool like Pitest you will be able to identify weak spots and you get an overview of how much of your code is actually asserted. This lightning talk will explain mutation testing, and it will demonstrate how to quickly get up and running with Pitest using maven.

After a quick overview of the upcoming lambda expressions in Java8, the main purpose of this talk is to show, with practical examples, how to use them effectively and how they can help to develop more concise and readable code.
Finally also Java, with its 8th major release, will have lambda expressions and then will allow to employ some functional techniques into its strongly object oriented paradigm. But why this decision has been taken, what will be its consequences, how will it change the way we write Java and, most important, how can we leverage it to develop more expressive, readable, reusable and effective software? After a quick introduction to the syntax of the new lambda expressions, the main purpose of this talk is to answer these questions, showing how functional programming can make us better Java developer and help to avoid or limit some bad habits inherited from our OOP backgroud, like the abuse of side effects, null references and exceptions in our code.

Lær hvordan man implementerer og tar i bruk tofaktor autentisering ved hjelp av Google Authenticator.
Har du brukere som benytter «JavaZone2013» som passord? Har nettstedet ditt data som bør sikres bedre? Eller ønsker du rett og slett å tilby brukerne dine en sikrere innloggingsvariant? De fleste av oss går i dag rundt med en mobiltelefon i lomma. Mobiltelefonen kan enkelt benyttes i en tofaktor autentiseringsløsning ved hjelp av Google Authenticator. Google har utviklet mobilapplikasjonen. Det som gjenstår for deg er å ta dette i bruk på nettstedet ditt. I løpet av denne lyntalen vil du lære hvordan man implementerer støtte for tofaktor autentisering ved hjelp av Google Authenticator.

Get a taste of the Ceylon language and see how Ceylon's powerful type system and built-in modularity enables sophisticated tooling.
Ceylon is a new programming language designed for writing large programs in teams. The language emphasizes readability, modularity, typesafety, and tooling. Ceylon programs execute on Java and JavaScript virtual machines. In this session, Gavin King will demonstrate some interesting features of Ceylon's type system by writing code in Ceylon IDE.

Lyntalen går gjennom 10 praktiske eksempler på bruk av Guava biblioteket og ser på hvordan det passer sammen med Java 8.
I dagens hverdag med blant annet Maven er det veldig lett å legg til og fjerne artefakter fra applikasjonen vår. I denne lyntalen kommer det 10 grunner til at du skal legge Guava biblioteket til på classpathen. Til slutt ser vi på hvordan vi kan bruke Guava sammen med Java 8.

Ren XML kan transformeres til hva du vil: HTML, JSON, iCal - Kun fantasien setter grenser. Lær hvordan med et kræsjkurs i XSLT og XPath.
XML er noe man møter i mange sammenhenger, enten man vil eller ikke. Ønsker du å velge ut et spesifikt subsett av data fra en XML-kilde, med kun en setning? Ønsker du å transformere XML til HTML, tekst eller JSON? Xpath og XSLT er kraftige verktøy for å manipulere og transformere XML, som det kan være nyttig for enhver programmerer å kjenne til. Lær de viktigste konseptene, se de i bruk på konkrete eksempler og plukk opp noen tips på veien fra en som bruker det til daglig.

A real Oracle SQL hacking session. No foils. Just the audience, the speaker, Java and an Oracle database. Learn how understanding Oracle internals can really make your application scale. We'll look at topics like joins, fetchsize, lobs, logical vs physical IO, clustering factor etc.
Lately you have heard a lot about NoSQL databases. But let me tell you a secret: the RDBMS databases are not dead - yet. So why not learn what's all about? This is a Oracle SQL hacking session, where you'll see how Oracle really works. You might have written a lot of SQLs, without knowing what's going on inside of Oracle.

How to use TDD to create a thread-safe, lock-free, high-performance cache by using knowledge of how modern processors are designed.
How to use TDD to create a thread-safe, lock-free, high-performance cache by using knowledge of how modern processors are designed.

10M events per second into HDFS, Under a sec query per 20GB of HDFS data. . . All of this and more will be demonstrated live during this talk
This talk will explore the area of real-time data ingest into Hadoop and present the architectural trade-offs as well as demonstrate alternative implementations that strike the appropriate balance across the following common challenges: * Decentralized writes (multiple data centers and collectors) * Continuous Availability, High Reliability * No loss of data * Elasticity of introducing more writers * Bursts in Speed per syslog emitter * Continuous, real-time collection * Flexible Write Targets (local FS, HDFS etc.)

Of course, any Java programmer knows how to write a method. But is that really the case? Many programmers find they code more by habit — habits picked up from frameworks, IDE defaults and a random selection of blogs — than by reason. This talk tries to dissect some common habits with reason to reveal, well, how to write a method.
We all know how to write a method. We all know how to write a class. We all understand how to name a field. We all understand the practices we use, their deep rationale and their implications. We are perfectly rational, reasoned and unbiased about how we code and the practices we employ. Then again... perhaps not. It turns out that we pick up habits and practices without being aware of them, retrospectively creating justification and rationale for what we do, whether it is naming conventions, indentation, control flow, use of language features, commenting, class layout, etc. All too often many things that have been considered good practice are discouraged because of IDE defaults or memes and habits emerging from vocal developers. This session tries to take a more rational approach that allows you to evaluate and improve how you write methods. There is a good chance you won't agree with everything as many common Java habits are questioned and subjected to merciless reasoning.

How can JSF still be relevant in a world where Vaadin and Thin Server Architecture is on the rise? This presentation shows how new features in JSF 2.2 keep it relevant for a certain class of application that still dominates in the enterprise.
Now that JSF 2.2 has completed, this session will demonstrate the most important features in the context of a self-contained sample application. The features covered include: * HTML5 Friendly Markup * Faces Flows * Resource Library Contracts The attendee of this session will learn how JSF is still relevant in today's enterprise software stack. Specifically, they will learn why one would want to upgrade to JSF 2.2 rather than opting for a different architecture entirely.

Regular expression matching using callbacks. Efficient data structures. Benchmarking.
(note: this abstract is in even though I intend to make the talk itself in norwegian) This is about a toy project I have called "rmatch" https://github.com/la3lma/rmatch. It's probably useful for something, but mostly it's just something I had to write It's also a very nice regular expression matching library that makes it possible to look for many matching expression in the same input, each of the expressions are connected to their own callback function. This implementation is way more efficient than sequential matching for each of the regular expressions. Sequential matching will use time proportional to O(N) where N is the number of expressions being matched, but rmatch will use time proporsional to O(log N) which is obviously much better, in particular for large Ns. For both of these cases the time spent on running the callbacks will proportional to O(M) where M is the number of matches found. Rmatch is based on callbacks: You submit a trigger that gets called when some input is processed by the matcher. You can have any number of regular expressions in the single matcher (up to limits given by physical memory). During everyday testing several tens of thousand regular expressions are added and matched against. The matcher will match all the expressions in parallel and when a match is found for any given expression, it will try to make that match as long as possible before terminating the match and calling the callback. The underlying deterministic/nondeterministic automata implementation was a lot of fun to figure out, in fact it was so much fun to figure out that I became obsessed with making an implementation. In a nutshell it is all quite efficient since only the parts of the deterministic automata necessary to match for the actual input is created. If for instance the input contains no "a" characters, then there will be no "a" edges anywhere in the deterministic automata. Also, there is actually only one deterministic automaton that matches the union of all the regular expressions. These two tricks ensure that no more than one deterministic automaton is made, and no more nodes or edges are added to it than strictly necessary for matching the input actually given to it. The matching then becomes a simple matter of traversing a deterministic automaton, and since that is quite simple it's also very fast. I have some tests backing this claim up. In a nutshell: For very simple cases (matching a single but complex regular expression and then adding a single counter) rmatch is faster than awk for, but slower than java regular expressions. For more complex tasks involving different things happening for different regular expressions, e.g. incrementing a different counter for each regular expression, then rmatch compares favourably even with java regexps which btw are wicked fast.

Å skrive sitt eget programmeringsspråk er en deilig opplevelse. Vi skal lære å skrive en interpreter for et enkelt lisp-språk, ved hjelp av Groovy, på under 50 minutter.
Lær Lisp, Groovy, og hvordan interpretere virker ... på under en time. Vi bruker forskjellige programmeringsspråk hver dag. Mange av oss er innom Java og JavaScript, kanskje php, eller Clojure, eller Groovy eller Ruby... og vi tar disse språkene egentlig for gitt. Men ... hvordan er de laget? Hvilke bevegelige biter har de? Hva gjør de forskjellige bitene? Hvordan kan jeg lage mitt eget programmeringsspråk, om jeg vil? Den store hemmeligheten er at dette egentlig ikke er så vanskelig. Hvis vi bare bruker litt tid på hver bit, for seg selv, og peprer den med tester, forsvinner magien, og bare kode står igjen. Deilig, deilig kode. (PS. Du trenger ikke kunne Groovy for å følge med her, jeg har valgt Groovy nettopp fordi konseptene blir så klare, språket står ikke i veien.)

Ever wanted to turn your heating on from your phone, monitor the temperature in your greenhouse maybe even control a water pump in your solar water heating system? I plan to share with you some simple but fun projects that will get you started with using an Arduino micro controller and kickstart your automated life style.
Ever wanted to turn your heating on from your phone, monitor the temperature in your greenhouse maybe even control a water pump in your solar water heating system? You can achieve all of this with one simple circuit board and a small amount of object oriented programing knowledge. I plan to share with you some simple but fun projects that will get you started with using an Arduino micro controller and kickstart your automated life style.

Vi ser på avgjørelser relatert til prosjektgjennomføring, organisasjon, arkitektur og teknologi. Var det noen som tenkte på forvaltning av applikasjonen når prosjektet hadde fullt trykk?
Det er i dag mye oppmerksomhet rundt effektivisering av prosjekter. Man snakker om metodikker, teknologier og rammeverk. Ofte fokuseres det på rammeverk og teknologier man raskt kan komme i gang med, mens andre ganger snakker man om ansvarlighet og tar sikte på "velprøvde" teknologier og standarder. Dette foredraget tar sikte på å bevisstgjøre hvordan avgjørelser som gjøres i prosjekt og organisasjon påvirker forvaltningen av produktet i årene som kommer. Gjennom eksempler fra virkeligheten forsøker vi å belyse hvordan avgjørelser, både små og store, påvirker effektiviteten i forvaltning. Vi ser på avgjørelser relatert til prosjektgjennomføring, organisasjon, arkitektur og teknologi. Var det noen som tenkte på forvaltning av applikasjonen når prosjektet hadde fullt trykk? Er organisasjonen rigget for å håndtere forvaltning av selvbetjeningsapplikasjoner? Er det alltid like lurt å sikte på felleskomponenter og gjenbruk?

Java 8 will finally deliver us to the promised land of functional programming! We'll look at what new powers the new features such as Lambdas and Default Methods give us, and also where Java is still lacking compared to e.g. Scala and Clojure.
Java 8 will finally deliver us to the promised land of functional programming! So can we stop worrying now about learning Scala and Clojure and the other new kids on the block? We'll look at what new powers the new features such as Lambdas, Default Methods and Streams give us, as well as what Java is still lacking compared to other functional languages on the JVM.

Learn how to perform large refactorings safely and without the need of branching.
When implementing a Build Pipeline based on the principles of Continuous Delivery a conflict often arises between those in favor of feature branches and those who regards branching as evil. This session will go through a few techniques and design guidelines that will help keep the build pipeline intact and take away the need for excessive branching.

New features in Cassandra 2.0 including lightweight transactions, virtual nodes, CQL (the Cassandra query language), as well as an updated look at performance.
Many people still think of Cassandra as a "key value store" or a "map of maps." Cassandra is a fast moving project, with over three years of intense development since it was contributed to Apache, and these early descriptions no longer do justice to Cassandra. This talk will cover new features in Cassandra 2.0 including lightweight transactions, virtual nodes, CQL (the Cassandra query language), as well as an updated look at performance.

“Clever code” can often be difficult for novices and people without the same skill-level as the person who wrote it. Can the code be a strong negative contributor to future use of time when maintaining the code? What does this say about the consistency of the group and how we work?
I en artikkel fokusert på teknisk gjeld, kommer Ward Cunningham med en interessant uttalelse. "Når et team jobber mot et mål ved å skrive kode, kan vi måle produktiviteten som forholdet mellom fokus på målet og fokus på koden. Vi kan si at koden har høy kvalitet, når produktiviteten forblir høy selv ved forandringer i team og mål". Sett at du jobber i et team med ganske forskjellige kvalifikasjoner. Og la oss si at den mest erfarne utvikleren lager kode som krever dyp forståelse av språket. Vil denne koden være et positivt eller negativt bidrag til fremtidig tidsbruk når koden skal forandres senere? Har dette noe å si for ønsket sammensetting av team og arbeidsmåte? Er det gjort bevisste valg hvorfor man trenger å ta opp teknisk gjeld og når den skal betales? Er nye språk som Scala eller paradigmer som funksjonell programmering et skjult kjempelån?

Med din eksisterende kunnskap om webteknologier kan du både lage native applikasjoner for Firefox OS, og lage webapplikasjoner som utnytter mobil hardware på flere plattformer.
De som har vært med siden 90-tallet vil kanskje huske en softwaregigants frykt for at Netscape skulle gjøre operativsystemet overflødig. Nettleseren har ikke bare gjort operativsystemet overflødig, nå er den operativsystemet. I Firefox OS kan du skrive "native" applikasjoner til en mobil plattform med HTML, CSS og JavaScript. Med litt omtanke kan du også få applikasjonene til å virke godt på andre mobile plattformer. De første mobiltelefonene med Firefox OS har dukket opp, og prosjektet støttes av flere tunge aktører (pluss vår egen Telenor). Dette kan bli en plattform å følge med på i kampen for et alternativ til Android og IOS, og API'ene som blir standardisert gjennom Firefox OS kan også viske ut skillet mellom nativ og web på andre plattformer.

Erfaringer fra utvikling av Ruters billettapplikasjon med spesiell fokus på hvorfor den ble utviklet som tre native-applikasjoner.
I løpet av en kort høst ble Ruters billett applikasjon for Android, iOS og windows phone utviklet. Dette foredraget forteller historien om hvorfor vi valgte å implementere løsniningen som tre native applikasjoner heller enn å gå for en multiplatformløsning. Innledningsvis vil multiplatform vs native bli diskutert før både gode og dårlige erfaringer fra prosjektetgjennomføringen vil bli delt.

Det er vanskelig å sette opp et søk som gir gode resultater med norsk innhold. Jeg vil gi deg en kjapp innføring i hvordan en søkeindeks ser ut og hvordan du får et kvalitetssøk.
Sliter brukerne med lite relevante resultater når de bruker søkeløsningen din for norsk innhold? Gir «autocomplete» overflødige forslag for det samme ordet? Får du null treff hvis ikke søkeordet skrives nøyaktig som i dokumentet? Denne lyntalen forteller deg hvorfor det er slik og hva du kan gjøre for å skape en bedre søkeopplevelse. Jeg tar utgangspunkt i søk med Solr og gir deg en kjapp innføring i hvordan en søkeindeks er bygd opp, hva som er spesielt for søk på norsk, og hvordan du får et kvalitetssøk med norsk innhold.

Denne lyntalen gir ein kort innføring i Websockets og viser korleis du kan bruke av Atmosphere-rammeverket til å støtte "push" av meldingar frå server til nettleser.
I webapplikasjonar no til dags har ein ofte behov for å pushe hendingar fra serveren og ut til nettleseren så fort dei oppstår. HTTP egnar seg dårlig til denne typen interaksjon, men opp gjennom tida har ein brukt ulike skitne triks for å få det til likevel. Nye protokollar og initiativ slik som Websockets og HTML 5 Server Side Events gjer dette mykje enklare og betre, men då må ein forholde seg til ein jungel av implementasjonar og API-er. Denne lyntalen dreier seg om korleis ein kan la Atmosphere-rammeverket skjule denne kompleksiteten og lage push-applikasjonar utan å måtte uroe seg så mykje over teknologien som ligg bak.

This talk is about how the role and responsibility of a programmer will change. For software development not applicable for outsourcing, the future will require programmers that have the skill and the will to understand “The Big Picture”, being more like product developers and thinking customer development.
The computer can do much of what your logical and mathematical brain can do, but much faster. Programmers in Asia and Eastern-Europe can do much of what you can do, but at a much lower cost. Don´t worry, you won´t lose your job just yet. With the rapidly increasing number of fast growing new companies challenging existing companies, changing marketplaces and decreasing the lifespan of products and services, large organizations will need to reinvent it self more often. This kind of disruptive innovation contains no mathematical formulas for the computer to solve. No requirement specifications to be outsourced to Asia or Eastern-Europe. No way to predict, or buy, success. Lean Startup and other similar methods for new product development, will be the rescue for such large organizations when facing a potential “Kodak Moment”. Business decisions will become more data-driven, and we will need your help to capture data needed and to read it. Design decisions will be made by A/B-testing and other impact-oriented testing techniques, rather than some UX-expert or graphical designer dictating the best solution. This talk is about how the role and responsibility of a programmer will change. For software development not applicable for outsourcing, the future will require programmers that have the skill and the will to understand “The Big Picture”, being more like product developers and thinking customer development. During the 2008 Presidential campaign Obama was able to collect 70.000.000$ more funds as a result of programmers A/B-testing every new experiment.

JavaScript has come a long way in few years. As we no longer need to battle DOM differences we can focus on building our applications instead. Now, however, as more and more application logic move from the server to the client our main problem is that we need to unlearn our earlier DOM-centric approach to JavaScript. Tools such as Backbone and Angular help, but before we are able to use the effectively we have to change some of our neural pathways. In this talk I will look at a couple of patterns that will help you move away from jQuery spaghetti and get you started on a foundation for building large-scale JavaScript applications.
In recent years a number of libraries for building large JavaScript applications has appeared. As we no longer need to battle DOM differences between browsers we can finally focus on building highly interactive front-end applications instead. But before we can do a good job with these new libraries we need unlearn our previous DOM-centric approach to building JavaScript applications. In this presentation will take a look at what that means, and how we can build modular, testable and reusable code. We will also look at some of the key concepts in libraries such as Backbone.js and AngularJS, including two-way binding, dependency injection and templating. The ultimate goal is, in my mind, that we should treat our Javascript application as we treat our Java application. After this presentation you will have a much better idea of ​​what that means.

Har du noensinne irritert deg over spam i loggen og ønsket å kunne fjerne det der og da? Er det opplysninger som skjules i loggen som du gjerne skulle fått frem? Har du noensinne ønsket å logge innholdet i én type SOAP-melding, men uten å måtte logge alle SOAP-meldinger til enhver tid? Da vil denne lyntalen vise deg hvordan!
Å kunne gjøre tilpasninger til en kjørende applikasjon kan gi bedre kontroll i et produksjonsmiljø og gi færre utrullinger og kortere rundtur ved test og utvikling. Logging er en standardfunksjon i de fleste applikasjoner, og det kan gi mange fordeler å gjøre det mulig å endre logg-oppsettet dynamisk. I denne lyntalen vil jeg vise hvordan ulike SOAP-meldinger kan logges uavhengig av hverandre, og vise hvordan man enkelt kan legge til dynamisk kontroll av hva som skal logges.

This lightning talk will go through why I think we tend to implement processes and structures that kill our creativity and takes the fun out of programming.
We keep organizing our programming into processes and structures that ensures that the fun is left out of the programming experience. In my opinion, programming SHOULD be fun, it should be opinionated and it should be a creative process. We need to stop optimizing for predictability and get back to the roots of what programming really is: Solving problems and issues in an innovative and engaging way!

Come steal several easy but effective workplace ideas from GitHub: a software company that defines success as a union of employee happiness and sustainable profits.
GitHub is an extremely unique software development organization, both in how it has evolved, how it functions, what it builds, and what it aspires to do for humankind at work. Learn how employee happiness and profits can and have gone hand in hand, and how the seeds of that are sown by having Hubot the robot do the dirty work, and having that dirty work done hundreds of times per day. I'll share some of the most useful culture secrets of work at GitHub, including live demonstrations of some of our open source and not-yet-open-sourced internal tools, continuous development practices, and skill-improvement vectors such as the successful rotating King of Developers role. All of the culture, process, daily work, and policies will be framed in the perspective of how they can be replicated at your place of employment for greater job satisfaction and more-successful-than-ever outcomes for your employer. We'll conclude with a brief ask-me-anything segment, with past experiences having touched on hiring, vacation, project direction, the explicit absence of managers, and employee trust.

Apache Pig er en plattform for å analysere store datamengder med Hadoop. I denne lyntalen gir jeg en kort gjennomgang av Apache Pig, og viser hvordan det kan brukes til å prosessere terabyte av data ved å skrive et halvt dusin linjer i konsollet.
Apache Pig er en plattform for å analysere store datamengder med Hadoop. Pig tilbyr et skriptspråk, Pig Latin, og en kompilator som produserer sekvenser av MapReduce-jobber. Pig Latin er et tekstlig, høynivå skriptspråk som gjør MapReduce en hel del lettere å jobbe med. I denne lyntalen gir jeg en kort gjennomgang av Apache Pig. Jeg vil plassere Pig i økosystemet rundt Hadoop og se på hvordan Pig blir benyttet i den virkelige verden. Jeg vil gå gjennom Pig's filosofi, syntaks og kjøretidsmiljø, og vise hvordan man går frem for å komme i gang med å analysere store datamengder med Apache Pig.

The Smalltalk programming language demonstrates the power of object orientation and lambda expressions. How can this be applied in Java?
You have probably noticed the excitement regarding functional programming and the new lambda expression in Java 8. But did you know that this also brings Java back to its object-oriented roots? The Smalltalk programming language shows how virtually any task can be achieved through good old object orientation. Everything is built with the basic ingredients of objects, messages and blocks (lambda). Smalltalk uses lambda expressions for conditional processing, iteration and exception handling. We will look at some fascinating examples, and discuss if and how to apply them in Java. We Java programmers now find ourselves with a brand new lambda tool in our toolbox. Lets take the time to learn from the past about the power of object orientation and lambdas.

Learn how to test your web site styling and prevent unintentional layout changes.
Automated functional UI tests assert HTML markup and not the actual web page rendering. If a font-size or margin changes in your CSS unintentionally, or something else breaks visually, functional tests will still pass because the rendered HTML may still be the same. However, the web site may be rendered entirely differently. Join this session for an intro on how to automatically test website styling and detect unintentional layout changes with various tools and techniques. Learn how to use these tools to refactor your CSS safely.

"Finn rytmen med Agile utvikling!" sa jeg i 2004. Fant du den?
På JavaZone 2004 holdt jeg presentasjonen "Finn rytmen med Agile utvikling". Min påstand den gang var at "Agile utviklingsteknikker som test-drevet utvikling, kontinuerlig integrasjon, daglige stand-up møter og ukentlige iterasjoner skaper en rytme i prosjektet som er veldig behagelig og effektiv å jobbe i, både for utviklere og prosjektet som helhet." Etter 10 år og en rekke smidige prosjekter -- i inn- og utland, i offentlig og privat sektor, med samlokaliserte team og team spredt på ulike kontinenter -- vil jeg oppsummere hva som har vist seg å fungere, hva som ikke har fungert, og på hvilke områder jeg opplever det er størst forbedringspotensiale. Foredraget er basert på egne erfaringer, forskning og sure innspill fra gode kollegaer.

Demonstrasjon av Dropwizard for en solid, RESTful, Java backend-tjeneste med kun time proven, solide og etablerte standarder, bibliotek og rammeverk.
Demonstrasjon av Dropwizard for en solid, RESTful, Java backend-tjeneste med kun time proven, solide og etablerte standarder, bibliotek og rammeverk.

Experience report of using Clojure in a (almost) real word project.
Når Submitit systemet (som brukes til å registrere forslag til foredrag på Javazone) skulle byttes ut ble fristelsen til å skrive en web server med Clojure for stor. I denne lyntalen vil jeg oppsummere mine erfaringer med å bruke Clojure i et økosystem hvor det skal fungere i en webserver, kunne kommunisere med et baksystem og kunne deployes som en war. I tillegg er det implementert mailutsending og Captcha. Jeg vil gå gjennom noe som fungerte bra og noen tabber som kostet tid og krefter.

Skriv mer forvaltbare og mindre skjøre javascript-tester med page objects.
Testing er vanskelig. Testing i frontend er enda vanskeligere. Å skrive gode javascript-tester krever disiplin og en stødig hånd. Hvis ikke, ender du fort opp med en uforvaltbar smørje der mange tester feiler hver gang du endrer et klassenavn eller flytter på et inputfelt. Skal du i tillegg teste en arbeidsflyt i en single-page app må du også tenke på mocking av ajax-kall. Til sammen blir dette fort vondt å teste og testene fort uleslige. For å rydde opp i kompleksiteten kan vi pakke interaksjonen med viewene inn i page objects.

Macros are a brand new feature of Scala 2.10. In the presentation I would like to explain why were they added to the language, show step by step how to write your own simple macro and show some libraries, which already use macros to implement functionalities, which were not possible before.
Macros [1] are one of the new features in Scala 2.10. So far they are marked as experimental, but I think nobody has doubts that they will stay there for good. Introducing macros was quite controversial, as Scala isn't a "lean" language already, but I think it was worth it. Macro is simply a Scala program, executed at compile-time, which manipulates the AST of our program. While we probably will mostly write macros when creating a library of a framework, rather than in day-to-day work (hopefully!), for sure it is good to know what are the mechanisms behind them. In the presentation, I would firstly like to show step-by-step how to write a simple macro and how does it work. In the second part I will present libraries, which already use macros (but without implementation details), such as ScalaMock [2], Expecty [3], Slick [4] or my own, MacWire [5]. [1] http://scalamacros.org/ [2] http://scalamock.org/ [3] https://github.com/pniederw/expecty [4] http://slick.typesafe.com/ [5] https://github.com/adamw/macwire

Hvordan man enkelt kan lese og manipulere XML-filer i Clojure ved hjelp av Clojures implementasjon av Zipperdatastrukturen.
XML er ikke alltid enkelt å prosessere, spesielt ved ulogiske strukturer og manglende skjemadefinisjoner. I overgangen fra Java til Clojure må man fortsatt behandle mye XML. Jeg skal vise hvordan man enkelt kan lese og manipulere XML-filer i Clojure ved hjelp av Clojures implementasjon av Zipperdatastrukturen. Ved bruk av disse metodene vil behandling av XML data gå lekende lett.

This is a talk for those frustrated by monolithic software products and describes a set of tools and techniques that you can use to break up your products based on the Unix Philosophy of small and simple.
Write programs that do one thing and do it well. Write programs to work together” was accepted 40 years ago yet we have spent the last decade building monolithic applications, communicating via bloated middleware and with our fingers crossed that Moore’s Law keeps helping us out. There is a better way. Micro services. In this talk we will discover a consistent and reinforcing set of tools and practices rooted in the the Unix Philosophy of small and simple. Tiny applications, communicating via the web’s uniform interface with single responsibilities and installed as well behaved operating system services. So, are you sick of wading through tens of thousands of lines of code to make a simple one line change? Of all that XML? Come along and check out what the cools kids are up to (and the cooler grey beards). This is a talk about building micro-services using simple java tools

Database schema evolution is often performed ad-hoc: a quick statement here, a little script there. The result: confusion and uncertainty. Has this update already been applied on this instance? Should we apply this other script first? Is our application going to run against this database? No more! This is where database migration tools come to the rescue! We'll look at a popular open-source choice called Flyway. By the end of the session, you'll have a solid understanding of what it does, how it works and how to effectively integrate it into your project.
Database schema evolution is often performed ad-hoc: a quick statement here, a little script there. The result: confusion and uncertainty. Has this update already been applied on this instance? Should we apply this other script first? Is our application going to run against this database? No more! This is where database migration tools come to the rescue! We'll look at a popular open-source choice called Flyway. By the end of the session, you'll have a solid understanding of what it does, how it works and how to effectively integrate it into your project.

Erfaringsforedraget beskriver utviklerens hverdag i et stort integrasjonsprosjekt og hvordan prosjektet i praksis håndteres med bruk av metoder som feature branching, pull requests, DevOps, kontinuerlige leveranser innenfor ITIL, og teknologi som github, puppet, nagios og release/deployment med rubyscripts.
En av Norges største bedrifter, Oslo kommune, har utviklet en omfattende integrasjonsplattform basert på åpne biblioteker og standarder, best practice for deployment, lastbalansering, konfigurering, overvåkning og organisering av tjenester. Denne vedlikeholdes til enhver tid av et 20-talls utviklere på oppdrag fra 40-50 forskjellige interessenter med sine egne krav, planer og leveranseløp. Alt sammen muliggjøres ved delegering av ansvar til de enkelte utviklerne, som også drifter plattformen. Erfaringsforedraget beskriver utviklerens hverdag og hvordan prosjektet i praksis håndteres med bruk av metoder som feature branching, pull requests, DevOps, kontinuerlige leveranser innenfor ITIL, og teknologi som github, puppet, nagios og release/deployment med rubyscripts.

Learn how to think like an Erlang expert and design highly available long running systems.
Many people have heard of Erlang, but very few have actually used it on production systems. In this talk I will be presenting Erlang/OTP in depth, and what makes this ecosystem interesting for building highly scalable fault-tolerant software.

With so many JavaScript MVC libraries out there, how does a time constrained developer make a smart choice? In this survey, we'll compare and contrast some of today's most popular libraries.
Developers are flocking to client side frameworks and, as a result, there are more and more JavaScript libraries attempting to solve the rich internet application problem. In a space where new libraries seem to spring up weekly, what framework should you choose for your next project? While there is consensus around basic ideas like Model View Whatever, there are some strong philosophical differences amongst the various libraries. In this talk, we'll look at the similarities and the differences of some emerging JavaScript libraries discussing why you need to be aware of this rapidly evolving aspect of software development.

Lyntalen vil ta for seg hvordan konseptene fra Rulespeak er brukt med norsk språk i et stort offentlig utviklingsprosjekt. Det vil vises hvordan forretningsregler er høstet og dokumentert på en strukturert måte på norsk. Rulespeak består av ett sett av nøkkelord som brukes for å beskrive forretningsregler med norske setninger, samt et sett av "Dos and Don'ts".
Har du noen gang lurt på hvordan du best kan samle inn alle forretningsreglene i systemet du skal lage? Opplever du ofte at kravspesifikasjonen ikke er så tydelig som man du skulle ønske? Da er det kanskje fordi du eller kravstiller ikke har vært presise nok i formuleringene, og ikke skiller godt nok mellom forretningsregler og kravspesifikasjon. Rulespeak er et sett av "best practices" på hvordan man skriver forretningsregler i naturlig språk (Engelsk). I denne presentasjonen får du et glimt av hvordan konseptene i Rulespeak også kan brukes på norsk og hvordan de har vært brukt i et stort offentlig utviklingsprosjekt.

Practical guidance for creating a robust graph database data model that can be easily evolved as your application evolves.
Graph databases provide powerful data modelling and querying capabilities for complex domains. In this session I'll describe a structured process for designing and implementing a data model for a graph database application. With a focus on test-driven, incremental and iterative development, I'll show how to build a flexible and expressive graph model and related queries that map closely to your domain needs, and which can be evolved as your application evolves.

Traditional concurrent development on the Java Platform requires in depth knowledge of threads, locks, and queues. Fortunately, new languages and frameworks that run on the Java Platform, such as Akka, have made concurrent programming easier.
In this session, I will demonstrate several concurrent processing techniques including Fire and Forget, Fork-Join, and Asynchronous Web Services using the Java Concurrency Library, the Akka Framework and the Spring Framework.

Traditional web development frameworks are changing. With an increase in popular frameworks for client-side web development such as Backbone, Ember or AngularJS, the role of the backed is limited to data processing and serving information. And that's exactly where it should be. In this session we're going to combine the power of concise JVM languages such as Kotlin, with front-end frameworks to create powerful and rich web applications. We'll see how we can drastically reduce the amount of code required and create a maintainable system.
Traditional web development frameworks are changing. With an increase in popular frameworks for client-side web development such as Backbone, Ember or AngularJS, the role of the backed is limited to data processing and serving information. And that's exactly where it should be. In this session we're going to combine the power of concise JVM languages such as Kotlin, with front-end frameworks to create powerful and rich web applications. We'll see how we can drastically reduce the amount of code required and create a maintainable system.

Did you know that you can access and modify the complete AST of a Java program through the Pluggable Annotation Processing API? In this session, I hope to provide some inspiration by describing how this is done and by sharing lessons learned from building a generator feature (think yield) for Java.
Did you know that you can access and modify the complete AST of a Java program through the Pluggable Annotation Processing API? There are numerous projects that leverage this to add various interesting language features, such as implicitly typed variables. In this session, I will describe how this is done and share lessons learned from building a generator feature (think yield) for Java. I will touch upon subjects such as constraints imposed by compiler phases, AST rewriting, coding in unsupported API land and AST changes between Java versions, integration testing across Java versions, javac versus other compilers and IDE support. The purpose of the session is to inspire some fun Java hacking, and a fair amount of Java knowledge is assumed.

How to stop using iFrame hacks to upload files with AJAX.
Uploading files with AJAX used to require you to use iFrames to avoid a page refresh. A pretty big hack right? However, two new technologies have made it better; WebSockets and XHR2. I will show you how bad the iframe hack was, how to use the new and better ways, and which browsers support them.

Clojure og Scala er to av de mest fremtredende funksjonelle språkene som kjører på JVMen. Ingen av språkleirene har mangel på verken høye ambisjoner, sylskarpe retorikkere og religøse følgere. Krydrer man det hele med den gode gamle "statisk vs dynamisk" debatten så er alt lagt til rette for en språklig hanekamp ingen har sett maken til på denne siden av tusenårsskifte.
Clojure og Scala er to av de mest fremtredende funksjonelle språkene som kjører på JVMen. Ingen av språkleirene har mangel på verken høye ambisjoner, sylskarpe retorikkere eller religøse følgere. Krydrer man det hele med den gode gamle "statisk vs dynamisk" debatten så er alt lagt til rette for en språklig hanekamp ingen har sett maken til på denne siden av tusenårsskifte. I denne presentasjonen skal vi se på både likheter og ulikheter mellom de to språkene. Med fokus på de funksjonelle egenskapene skal vi se på hvordan Clojure med sitt mål om å etablere en LISP i JVMen er fundamentalt forskjellig fra Scala som forsøker å forene objekt-orientert og funksjonell programmering. Vi vil diskutere deres sterke og svake sider og vise eksempler på hvor hvert språk virkelig viser seg fra sin beste side.

The edge of the Netflix network is responsible for 1/3 of all internet bandwidth usage in the US. It is staffed by ten thousand EC2 servers and tens of thousands of CDN cache endpoints. During this session, you'll learn about how we manage and control the outer edge, including our new open source java project: Denominator.
Life on the edge is innovating a system that is ultimately responsible for 1/3 of all internet bandwidth usage in the US. Even wonder how Netflix does it? This talk will overview a combination of services and open source projects that comprise the edge network, including Netflix Denominator. Discussions will include how we deal with DNS, distributed load balancing as well discovery of mid-tier services. You'll understand which service components are involved with edge traffic management. When you leave, you'll have enough context to create your own life on the Edge with NetflixOSS!

If it isn't worth maintaining, it isn't worth writing.
The process of software maintenance starts just after the very first bits of code have been written. Lets face it very few of us enjoy chasing bugs, reading tagliatelle code, finding inconsistencies in how things are built, fixing the same bug in 50 different places due to copy-paste-coding, not feeling confident in our own modifications due to sub-par tests and having none or broken documentation. As a software project grows, and time passes, it is very common for bugs to be harder to find, changes to be harder to make, and new features harder to integrate. Sounds painfully familiar? Don't worry, in this talk we'll explore ways of dealing with these issue before they even become a problem.

Bugs in production systems are typically communicated in stack traces. But why don't we communicate in unit tests?
This presentation discuss a concrete open source Java framework that allows production systems to communicate bugs as test cases. It will produce deterministic, sandboxable test cases having identical execution paths as the original run. Using the framework correctly will even make multi-threaded scenarios re-playable.

Keen på å lære hvordan man lager en web-applikason som yter stabilt? Lyst til å lære mer om hvordan man skal tolke thread dumps og memory heap dumps? Da er denne presentasjonen for deg!
Presentasjonen gir en rask introduksjon til hva man skal tenke på når man skal lage en web-applikasjon som skal levere stabil ytelse over tid. Følgende teamer blir sentrale i presentasjonen: - Hvordan håndtere kostbare operasjoner - Hvordan unngå ressursmangel Det vil også bli kjørt en demo hvor vi genererer last mot en webapplikasjon med lastverktøyet Gatling (scala), monitorerer med JMX og analyserer thread dumps og heap dumps for å finne årsaken til problemer.

Lyntalen tar for seg hvordan PowerMock kan benyttes til å teste kode som ikke lar seg teste ved hjelp av mock-rammeverk som Mockito og JMock. Videre presenteres det hvordan PowerMock ble tatt i bruk for å teste en 10 år gammel EJB-basert J2EE applikasjon uten eksisterende tester.
Mockito og JMock er eksempler på mock-rammeverk som benyttes i test-drevet utvikling. Men i en del situasjoner kommer disse rammeverkene til kort, f. eks. ved testing av gammel legacy kode og kode som benytter finurlige 3. parts biblioteker. Hvordan enhetstester man "utestbar kode" når man ikke ønsker eller ikke kan endre selve koden? Lyntalen tar for seg hvordan man kan løse slike vanskelige testsituasjoner med PowerMock, for eksempel mocking av statiske metoder, mocking av final klasser og mocking av hardkodede avhengigheter. Videre presenteres det hvordan PowerMock ble tatt i bruk for å skrive de første testene av en 10 år gammel EJB-basert J2EE applikasjon.

One line of code that changed the Web forever, and how to take advantage of it to build new and exciting solutions.
I have more than once been asked what I believe the impact of the emerging WebSocket standard would have on the Web, assuming we continue down the path that has already been laid out. The impact could be the same, or even more profound, as when we were first introduced to HTTP as a means to share static documents. Today, 6 years after inception, this new standard is rapidly maturing as the preferred choice deploying interactive live Web solutions. It is changing how we think about Web architecture and design, and how we can leverage this phenomenal communication fabric for new exciting solutions. In this session we will discuss the progress of the WebSocket standard, how to architect, build, and deploy real-world solutions, and what new exciting solutions we see at the horizon that is leveraging this new Web standard.

By taking a look at industry trends and standards with proven track records, developers and architects will gain insight on how to improve their ability to add value within an organization.
Developers are used to thinking in terms of code. Architects are used to thinking in terms of systems. By learning to think about information, both groups can build more and better value. Software is but a means to an end. We will learn from where the Web has been and where it is going. We will see that tools like REST, Machine Learning and Big Data are all interesting, but insufficient.

Learn how to more efficiently interact and develop with components of a service-oriented architecture and how to build a stable and scalable system that can grow with ever changing requirements using open source frameworks.
In this session attendees will learn about the different levels of concern within SOA and where to implement different frameworks within enterprise architectures. Tips and tricks that can only be learn through the school of hard knocks are presented here to give the attendee a big leap ahead in architected their systems. It will also point out commons trouble spots often encountered in large-scale systems. These are advanced system integration concepts with a focus on high availability using open source frameworks in a service-orientated architecture. It will cover best practice tips for implementing/architecting ESB, mediation router, and messaging in infrastructures needing large scale, high transaction capabilities

Hvorfor vi er til, hva du kan lære bort til barn og hva vi gjør. Så litt om hvordan vi jobber med skoler, og hva skolene trenger hjelp til. Så forteller vi deg hva bedrifter kan gjøre, og hva du kan hjelpe til med.
Lær Kidsa Koding! har flere hundre medlemmer og lokale grupper i mange byer. Her gir vi litt bakgrunn og viser retningen videre. Hvor kommer digital kompetanse fra? Hvorfor skal du bry deg? Hvorfor bryr de seg i utlandet? Hva kan vi forvente å lære bort til barn i forskjellige aldersgrupper? Hvilke ferdige kursopplegg finnes? Hvem kan du snakke med for å hjelpe til? Hva gjør vi videre?

How to build an automatically scaled processing pipeline with Java, Amazon EC2 and S3.
Cloud computing vastly simplifies the process of launching new servers with various configurations. This presentation tells the story of how we at Comoyo used Amazon Web Services (EC2 and S3) to create our own Frankenstein monster, a video processing pipeline that splits the tasks across a mix of various operating systems and components. Processing nodes are launched automatically when needed, and shut themselves down when there's nothing to do, providing a system that easily handles large workloads, while requiring very little up-front investments and little to no costs when activity is low. While we used this for video processing, the approach presented can be used for any long-running tasks that require many different software components. Our architecture is based on plain Java and some Bash scripting, with coordination over JAX-RS interfaces in straight-forward HTTP.

Eclipse er mye mer enn en IDE (og en av Twilight-filmene...). Eclipse er et OpenSource-miljø de fleste vet for lite om!
For to år siden trodde jeg - i likhet med alt for mange Java-utviklere - at Eclipse kun er en IDE. Etter det har jeg jobbet på et prosjekt hvor vi har bygget vår programvare på toppen av mange forskjellige Eclipse-rammeverk. Jeg har selv erfart at Eclipse-økosystemet er en skjult skatt, og etter å i tillegg ha deltatt på fire Eclipse-konferanser, ønsker jeg å spre det glade budskap: Finn ut mer om hva Eclipse kan tilføre ditt neste prosjekt!

Git is unsocial and destroys the team experience. Don't use it.
Are you using Subversion or CVS? That's great, whatever you do, don't migrate to Git! Git makes you work overtime, confuses developers with too many options, destroys the social interaction with your co-workers and much more. Git has unnecessary features like offline commits and cherry picking that nobody needs at his day job. Your code is the most important thing for your software development and you should use a mature technology for storing it. Let the kids play around with Git. In this ironic lightning talk I will give you 5 reasons, why you shouldn't use Git always with a twinkle in the eye. So create a new branch in SVN and come to my session while you checkout the branch.

Sammenslåing av kildefiler, minifisering, optimalisering av bilder, erstatning av variabler brukt under utvikling, og selvfølgelig kjøring av tester og kodeanalyser. Grunt er et byggeverktøy skrevet i JavaScript basert på en fornuftig plugin-arkitektur som løser ethvert problem du måtte kaste på den.
En moderne nettside, nesten uansett hvor enkel den måtte være, må igjennom en rekke steg før den er klar for verdensveven. Sammenslåing av kildefiler, minifisering, optimalisering av bilder, erstatning av variabler brukt under utvikling, og selvfølgelig kjøring av tester og kodeanalyser. Grunt er et byggeverktøy skrevet i JavaScript basert på en fornuftig plugin-arkitektur som løser ethvert problem du måtte kaste på den. I tillegg er den ekstremt enkel å utvide. Basert på erfaringer fra flere prosjekter vil jeg demonstrere noe av det Grunt kan gjøre for deg.

Har du noen gang hatt behov for å strukturere eller filtrere store mengder tekst? Denne presentasjonen vil fortelle deg om hva slags muligheter som ligger i Unix-verktøykassen og når det passer å bruke den.
Moderne programmeringsspråk er kraftige saker; de kjemper om å overgå hverandre med høyere og hæere abstraksjonsnivåer. Men av og til kan den korteste veien til målet befinne seg i verktøy som ble laget før internett ble oppfunnet. Ofte gjelder det når man skal behandle store mengder tekst. Denne lyntalen vil gi en oversikt over Unix-verktøy for å strukturere og filtrere tekst.

In this presentation, the data will do most of the talk. Show up if you want to know why choosing Java is a business risk, or why the most important reason for choosing Scala or Clojure is non-technical.
For software companies in a tight employment market like the one in Norway, most technical advantages are dwarfed by one concern: Access to good developers. It clearly doesn't matter what kinds of technical advantages a new language can bring, if you can't hire any developers to work with it. On the flip side, if you can bring great developers to your project, you're probably in good shape no matter what language you have chosen. Starting with a list of the 23 most popular programming languages, I have investigated the job market and surveyed more than 100 developers in Norway. Based on this insight, my analysis seeks to answer important questions about developer preferences and their accordance with available positions in the market. For instance, it turns out that although Java is the most widely known language, it is a risky choice for businesses. On the other hand, organisations that base their projects on Scala or Clojure should be optimistic about their future. If businesses took this advice to heart, the science of software development would progress, and developers and managers everywhere would be happier.

How we used BackboneJS and other Javascript tools to create a single page Javascript frontend against a Spring/Java backend for the new National Health Portal. Presentation will be held in norwegian.
Javascript libraries and client-side MV* frameworks like BackboneJS are very popular and much discussed these days, but Java is not usually the typical choice of backend platform for web-applications that employ these tools. In this talk I will share our experiences after integrating a modern frontend-stack with a Java-backend, shining light on what the challenges were and how we resolved them. Kjernejournal is a new initiative by the Norwegian Directorate of Health to gather important health information from all (non-reserving) citizens in a common health-record system to which all authorized health personell has access - anywhere, anytime, with the ultimate goal to save lives through increased information sharing. The product is a web portal, and naturally the demands of security, but also of responsiveness and usability are very high.

Learn how to build and run a system that gets smarter over time by learning from data. If you already took a class in machine learning this talk will show you how to translate those skills into a working system. If you don’t know any machine learning you will get a gentle introduction and gain a better understanding for how the data-driven sausage is made.
This talk will teach you what goes into building and running a machine learning system, as seen from a Java developer’s perspective. This will prepare you for the next phase of Big Data, where data is used not just for informing decisions but to drive system behavior. Instead of going into the details of algorithms we will discuss the overall system and project lifecycle (modeling, training, serving, re-training). Along the way you will get practical tips and advice about useful tools, some that you already know and some you probably haven’t heard of. Lastly you will get some tips for how can start playing around with this stuff even if nobody is paying you for it.

Se Christian og Magnar parprogrammere på nettspill med Clojure og ClojureScript.
Så du ZombieTDD for et par år siden? Magnar og Christian er tilbake med ZombieCLJ - en norsk videoserie med Clojure og ClojureScript. De setter seg ned med emacsen og parprogrammerer en ny episode foran publikum. Det blir utvikling av en ny feature, så du kan henge med selv om du ikke har sett alle episodene. Se hvordan to typer som digger funksjonell programmering angriper problemer og skriver tester.

Oslo kommune har en arkitektur med nesten 150 mikrotjenester (micro services). Lyntalen lister opp fordeler og ulemper med å ha en såpass løst koblet arkitektur, og viser hva en slik arkitektur muliggjør.
Denne lyntalen viser oppsummerte erfaringer fra et stort enterpriseprosjekt med kontinuerlige leveranser, der utviklerne jobber også med drift (DevOps). Alt dette er muliggjort ved hjelp av en ekstremt løst koblet heterogen arkitektur, der alle tjenestene er mest mulig uavhengig av hverandre. Arkitekturen har tjenester implementert i forskjellige språk (Ruby, Scala, Java, .NET).

En demonstrasjon av nye, kule ting i ES6-standarden, og hvordan du kan ta dette i bruk i dag.
Klasser og moduler, proxy- og generatorfunksjoner, nye operatører som spread og rest. Listen av nye ES6-features fortsetter å vokse, og front-end-utviklere gnir seg varme og klamme i hendene. Mange av disse nye egenskapene ved JavaScript vil ikke bli bredt støttet av nettleserne før om flere år, men det er allikevel håp. Ved å bruke en kombinasjon av såkalte shims og transpilere kan vi dra nytte av alt dette i dag, og samtidig støtte eldre nettlesere. Jeg vil først demonstrere endel eksempler på hva som er mulig med ES6, før jeg viser hvordan dette kan finne veien ut til dine brukeres nettlesere i dag. Du vil sannsynligvis ende opp som mer nysgjerrig enn opplyst.

Distributed Consensus is everywhere! Even if not obvious at first, most apps nowadays are distributed systems, and these sometimes have to "agree on a value", this is where consensus algorithms come in. In this session we'll look at the general problem and solve a few example cases using the RAFT algorithm implemented using Akka's Actor and Cluster modules.
The world of programming is leaning more and more towards distributed apps. Even if think you're not knowingly developing "an distributed app", in fact you probably are - because of external dependencies on other providers services. In the world of Distributed Programming the problem of making sure that multiple servers "see the same value" has been known for a long time, and there are quite a few ways to solve it. In this session we'll talk why you should care about consensus, where to apply it (or where it is applied for you by a database or middleware!) and how one would go about implementing a distributed consensus protocol by looking at the RAFT consensus algorithm and implement it using Akka Clustering.

They are everywhere, they are magical and their knowledge can help you stand out from the crowd. They are also fast and can save time. Lots of time. Do you want to understand and learn to use them properly?
Want to slay the monsters that leave [stack-] traces in your log files or to tackle the naming conventions in your code? Maybe you just want to understand better the charms that has been written (cast) by others? In this talk, we will be taking a deeper dive into regular expressions, their use, and practical examples. We will start with a short intro to the mysterious world of regular expressions and brush up on our knowledge before continuing on to more advanced topics like groups, greed, and backtracking. It will be an interactive presentation with lots of demos. Fear not, your awesomeness will also be rewarded! After the last year's success, the command line ninja is back in town again! Do not miss your chance to pick up some new, awesome skills.

Bruker du Apache Maven, og gjør andre ting enn å kompilere koden din under bygging? Det kan hende du kan tjene på å definere deler av byggeprosessen din i et plugin, og kanskje kode egne steg i tillegg til dem andre plugins definerer. Jeg viser deg hvor lite som skal til for å definere et eget plugin og sette samme andre plugins for et tilpasset bygg.
Som javautvikler bruker du nok Apache Maven, og er klar over at det er mulig å bruke plugins til å påvirke byggeprosessen i Maven. Et plugin kan gjerne være veldig lite og gjøre kun én ting, så det skal lite til for at det er gunstig å laget et eget. Du trenger ikke ha spesielle steg i bygget for å ha nytte av at plugin. Dersom du har andre plugins du alltid bruker i prosjektene kan det være en god idé å lage et plugin for å samle disse. Da minsker du både antallet linjer i pom.xml og mengden som kopieres mellom prosjekter. I denne workshoppen går jeg gjennom det som er nødvendig å vite for å lage et plugin, hvordan du finner dokumentasjon og hvordan du får plugget det inn på riktig sted i bygget ditt.

Denne lyntalen handlar om korleis bruk av JavaBean-mønsteret stikk kjeppar i hjula for draumen om ein rik domenemodell.
Javakode er ofte full av javabønner og bønneliknande klasser. Vi har blitt så vant med å bruke dette mønsteret at vi ofte ikkje tenker over at vi bruker det, og IDE-en oppretter gjerne getter- og setter-metoder for oss automatisk. Mange populære bibliotek og rammeverk, slik som Dozer og Spring, forventar også å kunne jobbe med bønner. Men det er likevel ikkje slik at alle klasser vi skriv bør kunne vere bønner. I denne lyntalen ser vi på korleis domeneobjekta mister evnen til å ha kontroll på eigen tilstand dersom dei også skal vere bønner, og kva konsekvensar dette har.

Serverne som kjører JavaZone sine systemer er provisjonert med Ansible. I denne erfaringsrapporten forteller vi hvordan vi har automatisert konfigureringen av miljøene, hva dette har gitt oss, og hvilke problemer vi har støtt på.
Det siste året har JavaZone sine systemer blitt flyttet opp i "ze cloud". Vi kan nå, med få tastetrykk, sette opp en brand spanking new server klar til å hoste systemene JavaZone avhenger av. Tiden da vi måtte holde orden på ssh-nøkler og konfigurasjonsfiler og "apt-get" ting for hånd er forbi. Ingen flere manuelle steg! Vi vil presentere hvordan Ansible har hjulpet oss, og si noe om hvilke problemer vi har møtt på veien. Hvilken verdi gir det å provisjonere? Hvordan er Ansible sammenlignet med andre provisjoneringsverktøy? Hvilke ting kan det være greit å være klar over når en tar i bruk Ansible? Vi sitter ikke med alle svarene. Vi er godt fornøyd med hva vi har fått til så langt, men har fortsatt mye vi ønsker å forbedre. Vi ranter, ehm, deler våre erfaringer, og kommer med noen tips som har hjulpet oss på veien.

Learn about the benefits of adopting functional programming principles in your software development projects. We'll touch on issues such as reuse, reduced complexity, testing, performance and more!
There's a lot of buzz about Functional Programming. Even Java has gotten support with the release of Java 8! Why should we as developers, architects or project managers care? Come learn about some of the benefits you can get by incorporating aspects of functional programming in your project. We'll touch on issues such as reuse, reduced complexity, improved testability, expressiveness, bugs, performance and more!

The first thing you learn in programmer's kindergarten: "Don't reinvent the wheel". The second thing you learn is: "Make wheels for your friends". In this talk we examine when this is good advice and when it is bad and how to get the most bang for your reuse buck.
If need the same functionality in two projects, you should reuse code between them, right? Or should you? For as long as there has been a profession of software engineering, we have tried to achieve more reuse. But reuse has both a benefit and a cost. Too often, the cost is forgotten. In this talk, I examine the economics of reuse. True story: One of the earliest projects to embrace object-oriented programming in the 1990s did so with the goal of maximizing reuse. The team responsible for creating the company wide framework used the following formula for calculating the value of their work: [Value of reuse] = [numbers of uses of framework] * [value of the framework to reusers] – [cost of developing the framework] This formula is obviously correct, but this is where they went horribly wrong: The organization said [value of framework to reusers] = [cost of developing framework]. In other words: The more expensive it was to create, the more valuable it was to use. In this talk, I will expand on the formula for the value of reuse, I will examine the difference between tactical and strategic reuse and I will point to factors that will make reuse harder or easier.

Vegvesenet er i ferd med å bygge et nytt system for innsamling av trafikkdata i sanntid basert på Akka, Elasticsearch og OPC-UA. Her får du en gjennomgang av prosjektet, arkitekturen, erfaringer som er gjort i forhold til de valgte komponentene, clustering, skalerbarhet og ytelse og noen løsninger på utfordringer vi har møtt underveis.
Vegvesenet har tusenvis av trafikkmålestasjoner over hele landet med sensorer som kan måle en mengde data om kjøretøyene som passerer, for eksempel hastighet, lengde og vekt. Nå skal disse passeringsdataene samles inn, analyseres og arkiveres i sanntid. Til dette formålet utvikles en helt ny arkitektur i Vegvesenet basert på Akka, Elasticsearch og OPC-UA. Systemet må kunne håndtere de store samtidige datamengdene som kommer inn fra alle målestasjonene og skal gi grunnlag for ulike sanntidstjenester for trafikksentralene og publikum samt lagre dataene for senere statistisk analyse - et perfekt case for horisontal skalerbarhet med Akka og Elasticsearch? Denne presentasjonen vil ta for seg arkitekturen som ble valgt og vise styrker og svakheter ved de ulike komponentene, erfaringene vi har gjort oss i forhold til clustering, skalerbarhet og ytelse og hvordan vi har kommet oss rundt en del av utfordringene vi har møtt.

Sjakk Programmering er en veldig sær hobby! Hva får programmerings entusiaster over hele verden til å bruke store deler av fritiden på å lage sjakk motorer? I et internasjonalt miljø konkurrerer de om å lage den beste sjakk motoren med høyest rating og så la sjakkmotorene duellere mot hverandre i en online arena? Litt historie rundt miljøet og litt forklaring til hvordan man lager en femmenalt god sjakk motor. Litt råd og erfaringer. Er du interessert til å delta i et miljø for utvikling av sjakk motorer? Vil du bli med å starte et sjakkprogrammeringsmiljø i Norge, Oslo?
Sjakk programmering startet på begynnelsen av 1950 tallet og Alan Turing lagde det første fungerende sjakk program i 1953. Siden den gang har programmerings teknikker utviklet seg og maskinvare blitt tusenvis ganger raskere. I dette århundret klarer ikke lenger de aller beste å slå en data maskin i sjakk. Ved siden av sjakk har det også utviklet seg et miljø rundt programmering av sjakk computere, der programmerere lar sine sjakk motorer konkurrere med turneringer og rating lister. Hva er dagens beste sjakk program? Vi skal se litt på historien til sjakk programmering og deretter se litt på sjakk programmerings teknikker. En sjakk computer regner ut lovlige trekk, evaluerer stillingene og itererer over mot-trekk. Vi skal se litt på trekk generering, brett representasjoner og standarder slik som FEN, ZobristKey, Polyglot og test-teknikker som Perft/Divide som enkelt kan sjekke at man genererer riktige trekk. Et sjakk program evaluerer en stilling på grunnlag av brikke og posisjons verdier og noen få posisjoner i forhold til andre brikker slik som dobbel eller alene bonde. Iterering over stillinger skjer iterativt dypere med de beste trekkene. Itereringsteknikker slik som minimax forbedres med alphabeta og PVS pruning. Når kan man gi et riktig bilde av stillingens verdi, selvsagt ikke i midten av en brikke utveksling derfor itererer man videre til der ikke lenger er mulige utvekslinger (Quiescence). Der er caching teknikker slik som Transposition tabeller med double-key og cuckoo-hashing. Man spesial programmerer sortering av trekk med merge/insertion sort og killer-move slots. Til slutt tester man sitt program og får en ELO rating og kanskje deltar på CCRL sin arena. Hvordan har jeg tenkt å komme til topps på CCRL sin rating liste? Hvordan forbedrer man ytelsen med multi-threading? Hvordan er Java i forhold til C og Assembly? Er der interesse nok for at du ønsker å delta videre i et sjakk programmerings miljø i feks Oslo?

Have you ever wondered how your Java code turns into byte codes? Lets have a look under the hood of the OpenJDK java compiler! You will find that it is surprisingly easy to understand and even make modifications. As an exercise we will add support for goto statements in Java: we will show you how to write, compile and debug Java code with goto statements! Finally, we demonstrate how a small modification would allow you to compile lambda statements for older JVMs. For the daring: goto presentation;
As Java developers we can learn a lot by studying the compiler. It is very interesting to see what happens to our code on the way to become byte codes. Contrary to what you may believe, the compiler is in fact surprisingly easy to understand. The compilation process is intuitive, with clearly defined stages: lexing, parsing, attribution, flow analysis, desugaring and finally byte code generation. Each step will be presented with familiar examples that Java developers experience in their everyday work. Adding goto syntax follows the same step-by-step process, hooking into the relevant stages along the way. The changes can be done incrementally with supporting unit tests to assert the sanity of the compiler. The example is particularly attractive and educational, as all the required components are readily part of the language: reserved goto word, labeled statements and byte code. A radical change to the language can therefore be achieved with only a tiny effort. This shows how extensible the Java language and virtual machine can be. Compilation of lambda statements is a particularly interesting new feature. We will look into how this is solved by the compiler, and play with a small naive change to also target earlier releases of the JVM. Let us demystify the compiler and in a playful manner see what we can do with it!

Hvilke fordeler får vi ved å bytte til en moderne web teknologistack for "Min Bedrift" i Telenor?
Når vi skal modernisere en applikasjon kan vi enten gjøre dette gradvis, eller vi kan bytte den ut. Webapplikasjonen "Min Bedrift" i Telenor får nå et stort ansiktsløft. Med brukeropplevelse i fokus, bytter vi ut hele frontenden med en moderne stack basert på teknologier som Less, Grunt, HTML5, AngularJS, Git, og et REST basert grensesnitt mot backend. Vi fokuserer på hvorfor vi har valgt å bytte ut frontend, men i stor grad beholde eksiterende backend. Og forteller om hvilke muligheter de nye teknologiene gir for et prosjekt med 15-20 utviklere og distribuerte team på tvers av landegrenser.

Are you afraid? Worried the service you're calling will be down? Or too slow? Or return the wrong value? You should be. But that's no reason to make your own code more complex and less stable. Fear, as we all know, leads to the dark side, but it also leads to large and complex enterprise systems. We need to keep calm and solve the right problem.
It's no secret that there is a lot of shitty code out there. Lots of the services we rely on for our applications are unstable or buggy or both. So how should we handle this? We don't want our applications to fail. It is tempting to try to fix the bad situation in our own code. By creating our own services to act as intermediaries, by adding asynchronous queues, and try catches galore. What is the result? Not only do we rely on an external service that is unstable, now OUR code is far more complex and therefore more unstable as well. Some times we have no choice in the matter, but often we do. More often than you'd think. We need to solve the right problem - fix the service that is unstable in the first place. There are many things we can do to help. Although it might mean interaction with other human beings. I know. It sucks, but we can do it. It's the right thing to do.

Vaadin is the shortest way for pure Java programmers with few front-end skills to quickly create nice-looking and robust web applications running on the JVM.
Today is all about those fancy client frameworks and stuff. However, this means that you and your team have as many front-end skills as back-end skills, or that there are two different teams that need to integrate their code together. The first case is rare, the second costly. Come discover Vaadin, the no-fluff just-stuff Java web framework. You code only in Java, compile to bytecode and thus can integrate easily with Spring, CDI, JDBC, JPA, ... Plus you get true Object Oriented Programming, Singe-Page paradigm, an Event-Driven abstraction over the HTTP request response model, Server Push and much much more. If you don't know about Vaadin, now is the time! Important: the allocated time is limited, so that in order to be as efficient as possible, attendees are expected to prepare their environment for the workshop in advance. First, get Java (preferably 8), Maven and your IDE of choice (Eclipse, IntelliJ or NetBeans). There's a dedicated Github project page: https://github.com/nfrankel/vaadin7-workshop/. Clone the repository and checkout tag v7.2-1. Then, import the project into your IDE, run mvn package and you should be set.

Små touchbaserte enheter er fine for å konsumere innhold. Input er derimot ikke fullt så bekvemt. Jeg tar utgangspunkt i de siste prosjektene jeg har vært med på og ser på hvordan vi har løst disse utfordringene her.
Man oppnår mye med riktig bruk av html. Hvis man i tillegg til standard webskjema legger på en tilpasset brukeropplevelse basert på Javascript kan man oppnå mye. For å sikre at alle får en funksjonell løsning er det viktig å bygge spesialløsninger basert på prinsipper rundt feature detection og progressive enhancement. Forskjellige nettlesere har også hver sine måter de prøver å hjelpe brukeren på. Det er ikke alltid det er fornuftig med autokorrektur, eller at alle verdier du noen sinne har tastet inn i et felt skal huskes. Dette kan styres på feltnivå. Hvordan kan man gjøre det så enkelt så mulig å dytte inn den informasjon som trengs, og samtidig gjøre dette på en måte som fungerer på tvers av alle mulige typer enheter, nettlesere og skjermstørrelser?

Does setting up servers and deploying Java Apps have to be this complex? What if you could start over and radically simplify all this? What if, within seconds, and with a single command, you could wrap your application into the bare minimal machine required to run it? This talk challenges the status quo and proposes a radical rethinking of Java App deployment. It takes Continuous Delivery and the Cloud up to 11.
Java App deployment is a complex and time-consuming process. It requires OS installers, package management tools, configuration recipes, install and deployment scripts, server tuning, hardening and more. But... Is this really necessary? Are we trapped in a mindset of doing things this way just because that's how they've always done? What if you could start over and radically simplify all this? What if, within seconds, and with a single command, you could wrap your application into the bare minimal machine required to run it? What if this machine could then run unchanged on your workstation and in the cloud? This talk challenges the status quo and proposes a radical rethinking of Java App deployment. If you believe in simplicity and efficiency over complexity and brute force; if you aren't afraid to look forward with fresh thinking, buckle up: this talk is for you. It takes Continuous Delivery and the Cloud up to 11. Live demo included.

Erfaringsrapport om iterative endringer fra én stor applikasjon til et skalerbart, distribuert system. Pantemaskinene er det spesielle med dette systemet. De sender fra seg ulike typer data og har forskjellig hardware, embedded software, konfigurasjon og nettverk. Sentrale egenskaper: Skalerbarhet, robusthet, driftbarhet og krav om å aldri miste data.
I 2007 utviklet Tomra en tre-lags web-applikasjon for å overvåke, administrere, og rapportere på et hundretalls stasjoner for å samle inn tomflasker og annet resirkulerbart materiale. Applikasjonen ble godt mottatt, og demonstrerte for Tomra en ny måte å samle inn data på. Da Tomra ønsket å videreutvikle denne applikasjonen for alle sine returpunkter, dukket det stadig opp nye behov, og endringer ble iverksatt. Etter noen få år hadde et tyvetalls utviklere jobbet på applikasjonen, og vi endte opp med alle de klassiske problemene som ofte plager tre-lags databasesentriske monolitiske applikasjoner. I dette foredraget vil vi presentere konkrete erfaringer gjort i det vi har radikalt endret arkitektur for det som var en stor, monolitisk og databasesentrisk web-applikasjon. Systemet er nå distribuert i mange kodebaser og applikasjoner. Vi vil beskrive utfordringene med å gjøre disse endringene, og gevinstene vi oppnådde, samt hvilke nye utfordringer som dukket opp. Stikkord: Integrasjon med pantemaskiner, eventdrevet arkitektur, skalering, moderne teknologi (Neo4j, MongoDB, Http-endepunkter), pull-deployment, teknikker for å gjøre store, men trygge endringer.

Datomic, Clojure, Paredit, Facebook React. I denne presentasjonen skal vi snakke om å drive med data, i stedet for å drive med objekter og andre muterbare ulumskheter.
Webappene våre tar imot data, putter data i databaser, og returnerer data tilbake til brukerne. Kode er data. Når du skriver Lisp er dette åpenbart, men kode er data i alle programmeringsspråk. Brukergrensesnitt er data. Ofte enkodet i en objekt-graf, men likefullt data. Dette er en presentasjon om data-drevet programmering. Du vil lære hvorfor alt er immutable i Clojure. Du vil lære hvorfor Facebook React gjør det lett å drive med data i nettleseren. Du vil lære hvorfor du er pokka nødt til å lære deg Paredit. Du vil også lære at databaser ikke nødvendigvis trenger å være global muterbar state, den kan også være bare ren data (som aldri endrer seg), tro det eller ei.

Reviews are a powerful tool for building quality software, but it can sometimes be difficult to convince your team to use them. In this presentation we’ll look at the research behind reviews, the benefits they can provide, and some best practices for using them effectively. Armed with this knowledge, you’ll be able to make informed decisions about - and strong arguments for - using reviews on your projects.
Software development is a young (some would say immature) profession, and a lot of what we do as software developers is guided by anecdotes, intuition, and received wisdom. The topic of reviews, however, is a bit different, and we’ve actually got a substantial body of research that tells us something important: reviews improve quality, reduce delivery time, and save money without slowing development teams down. Given what we know about the efficacy of reviews, it would be surprising to still find development organizations today that don’t use them. Yet we do. In this talk I’ll present some of what we know about reviews. We’ll look at questions like: How long should a review be? What kinds of artifacts can be usefully reviewed? How is the time spent in reviews accounted for in terms of quality or ROI? Some of the answers to these questions can be very eye-opening! Along with the “harder” economic and software-oriented benefits of reviews, I’ll also spend some time looking at some of the social and team-oriented improvements they can provide. All of these elements build upon one another, of course, so it’s useful to have high-level or holistic sense of what reviews can do for your organization. Ultimately, my goal is to convince you that reviews probably should be part of your everyday development practices and to help you find the best ways to use them.

This session looks at the popular application servers—including Tomcat, TomEE, GlassFish, Jetty, IBM WebSphere, Oracle WebLogic Server, Liberty Profile, and JBoss/WildFly—and analyzes them from the point of view of a developer. It focuses on performance, config management, open source compliance, feature richness, tooling, and developer productivity, among others.
There are many application servers on the market today, but which are right for you as a developer? This session looks at the popular application servers—including Tomcat, TomEE, GlassFish, Jetty, IBM WebSphere, Oracle WebLogic Server, Liberty Profile, and JBoss/WildFly—and analyzes them from the point of view of a developer. It focuses on performance, config management, open source compliance, feature richness, tooling, and developer productivity, among others. Come to this session to learn about the main differences between the application servers on the market today and understand which might be best for your needs.

Virtuelle utviklingsmiljøer har blitt et de facto verktøy, men ytelse er fortsatt et ankepunkt. Med disse enkle (dog obskure) grepene kan vi snu problemet på hodet og få både høy fleksibilitet og høy ytelse på utviklerplattformen.
Gitt et "enterprise" standalone utviklingsmiljø med tung appserver, database, esb mm går det gjerne ikke så raskt om man kjører det på en laptop, og desto verre om det er inni en virtuell maskin. Imaget som utviklingsmiljøet ligger på kan like gjerne skrives til disk, og bootes "native". Driftsavdelingener benytter seg ofte av dette for å "tanke" maskiner, men det i seg selv gir ingen fleksibilitet. Med VirtualBox kan man fjerne skillet mellom virtuelt og native. Det virtuelle imaget kan konverteres til et disk-image, som skrives rett til en partisjon. Da kan man boote native på et eller flere slike images. I hvert image kan man lage "virtuelle" pekere til fysiske partisjoner, slik at man igjen kan boote disse i virtualbox. Man oppnår da at et utvalg utviklingsmiljøer til enhver tid er tilgjengelig både native og virtuelt.

A walk through of the G1 garbage collector in HotSpot. Discussing how it works and how it compares to other garbage collectors.
The G1 collector takes a slightly different approach to garbage collection than the other collectors in HotSpot. At the same time it plays along with many of the concept introduced by the other garbage collectors. This talk will give a quick overview of the most commonly used garbage collectors in HotSpot and then go into detail about the G1 collector. The more flexible architecture of G1 provides opportunities for dynamic adoption as well as tuning that the other GCs do not support. We will learn what is common among the GCs, what is different with G1 and some insights into how to tune G1.

How many times have been told how functional programming is so much better than imperative, and then being presented with a functional approach to calculating a fibonacci sequence, leaving you wondering how that can be even remotely useful when working in real world applications? Yep, we’ve all been there. It seems that every time someone wants to explain functional programming to us, it’s around how to solve some mathematical problem. But how does that provide us value? How do we deal with things like grouping functionality, loose coupling and consequently dependency injection? Join this journey where we’ll look at code we usually write when developing business applications and how to refactor this using functional paradigms, and more importantly, see if these provide us with any value.
How many times have been told how functional programming is so much better than imperative, and then being presented with a functional approach to calculating a fibonacci sequence, leaving you wondering how that can be even remotely useful when working in real world applications? Yep, we’ve all been there. It seems that every time someone wants to explain functional programming to us, it’s around how to solve some mathematical problem. But how does that provide us value? How do we deal with things like grouping functionality, loose coupling and consequently dependency injection? Join this journey where we’ll look at code we usually write when developing business applications and how to refactor this using functional paradigms, and more importantly, see if these provide us with any value.

Hystrix is a great library that helps you to write resilient applications. This session will give you a head start into integrating Hystrix into your own application.
Availability is the alpha and omega in production, preferable 24x7, as few outages as possible. But to get there, it is not sufficient to rely solely on the fault tolerance mechanisms built into the infrastructure level. Instead you explicitly need to code the required resilience into your application. An especially tricky challenge is to make sure that a component does not get blocked due to another non-responsive component. We all know it just too well: the web server stands still because the database does not respond - and alike. Exactly this problem gets addressed by Hystrix, an OpenSource library by Netflix. In this session you will understand, what Hystrix does, and based on concrete code examples you will learn how to make your application more resilient easily using Hystrix - no more non-responsive applications!

Oppsummerer svakheter ved hvordan vi vanligvis anslår usikkerhet i estimater og foreslår en bedre metode. Det vil bli kåret en norgesmester i estimering.
Estimater av utviklingskostnader er usikre. Studier viser at vi er enda dårligere til å angi usikkerhet enn vi er til å estimere. Vi trenger derfor bedre metoder for å angi usikkerheten. I presentasjonen oppsummerer vi resultater fra flere undersøkelser om svakheter i hvordan vi kommuniserer og håndterer usikkerhet. Undersøkelsene viser et stort behov for å klargjøre hva vi mener med estimater og hvor usikre disse er. De viser også at manglende kunnskap om hvordan man adderer usikre estimater trolig er dette en viktig kilde til overskridelser og at usikkerhetsintervaller (minimum-maksimum intervaller) stort sett er alt for smale. Selv når vi sier at vi er ”svært sikre” på å ikke gå over et maksimum-estimat så er det likevel ofte 30-40% sannsynlighet til å faktisk overskride maksimum. Vi har utviklet en metode som gir mer realistiske usikkerhetsestimater og presenterer erfaringer med denne. Metoden beskriver usikkerheten til et prosjekt basert på faktiske utfall i en referanseklasse av prosjekter likt det som estimeres. En kritisk suksessfaktor for metoden er tilgang på gode erfaringstall, og vi komme inn på hvordan man kan fremskaffe dette. I siste del av presentasjonen vil vi avholde NM i estimering, der den med best kunnskap om estimering i IT-prosjekter vil få tittelen norgesmester i estimering, en pokal og et gavekort på en bedre restaurantmiddag.

The Java Management Extensions (JMX) are old but omnipresent in every JVM. Unfortunately it is surprisingly hard to access the exposed information remotely, especially for non-Java clients. Jolokia is an open source HTTP bridge which translates JMX calls to JSON and vice versa.
After pointing out the problems with JMX, we will see how Jolokia can solve these. Additional features like bulk requests or fine grained security policies are explained. The ecosystem around Jolokia like client libraries and tooling are presented as well as the various Jolokia agents available. At the end of the talk you will have a good understanding what Jolokia is and which problems it solves.

A fast-paced view of how graph data (and Neo4j) can supercharge data analytics.
In this talk we'll explore powerful analytic techniques for graph data. Firstly we'll discover some of the innate properties of (social) graphs from fields like anthropology and sociology. By understanding the forces and tensions within the graph structure and applying some graph theory, we'll be able to predict how the graph will evolve over time. To test just how powerful and accurate graph theory is, we'll also be able to (retrospectively) predict World War 1 based on a social graph and a few simple mechanical rules.Then we'll see how graph matching can be used to extract online business intelligence (for powerful retail recommendations). In turn we'll apply these powerful techniques to modelling domains in Neo4j (a graph database) and show how Neo4j can be used to drive business intelligence. Don't worry, there won't be much maths :-)

It's awkward to perform science experiments on developers, so let's simulate them instead!
In 1968 Melvin Conway pointed out a seemingly inevitable symmetry between organisations and the software systems they construct. Organisations today are more fluid than 40 years ago, with short developer tenure, and frequent migration of individuals between projects and employers. In this slot we’ll examine - and perhaps collect - data on the tenure and productivity of programmers and use this to gain insight into codebases, by simulating their growth with simple stochastic models. From such models, we can make important predictions about the maintainability and long-term viability of software systems, with implications for how we approach software design, documentation and how we assemble teams.

There are many mechanisms for storing and processing a collection of data sets so large and complex that we collectively refer to it as Big Data. Using live demos and code we'll show you how simple yet well-known and very powerful techniques can help you optimize data Capture, Storage and Access.
There are many mechanisms for storing and processing a collection of data sets so large and complex that we collectively refer to it as Big Data. From No SQL data stores to the Distributed File Systems and Computation engines to columnar stores to flat files - its all about capture, storage, analysis, searches etc. We want it all and we want it fast and traditional data processing applications can no longer support our demands. And while technologies such as Hadoop and its ecosystem derivatives paved an initial path to solving Big Data problems the approaches and assumptions they are built on starting to show its limitations one could only overcome by radically changing the way we think about storing and accessing data in general. In the end it’s all about I/O and how to make it more efficient. The following is the small sub-set of questions that will help set the scope and drive this presentation. - How to deal with capturing high data volumes (1+ million events per/sec). - How to store and organize the data? Unstructured doesn't mean un-organized - Compress, encode or pack? What are the differences, pros and cons? - Data-Type patterns. What does it mean? How to spot them during data capture and what are the benefits? - Loss of analytical data available (for free) during the capture. What, Why, the implications and how to deal with them? - Is disk speed the limit for how fast the data can be captured/accessed? - Role of CPU/RAM in I/O intensive environments and can they play a role? In the end using live demos and code we'll show you how simple yet well known and very powerful techniques can help you optimize: - CAPTURE of data in high volumes environments (1+ million events per/sec) - STORAGE of captured data, making it much smaller (10:1 to 20:1), thus more efficient for general read/write. - ACCESS of stored data based on optimization techniques used during its capture and storage, further increasing I/O read speeds when accessing such data (e.g., search 1B records in just few seconds - single laptop).

You have probably heard about the now infamous digital currency Bitcoin. Involved in crime and major heists of millions of dollars. Are these currencies just a ponzi scheme? Is it as unsafe to use as it seems in the media? This talk will look at how two very different kinds of crypto currencies and payment systems work: Bitcoin and Ripple.
Bitcoin was created by the mysterious Satoshi Nakamoto just 6 years ago. The market value of all bitcoins today is over 10 billion dollars. It is not just a geek curiosity anymore. This talk will not deal with investing or using bitcoins but about how distributed digital currencies work. Concepts explored include bitcoin transactions, the block chain, ripple trust lines etc.

Denne lyntalen er myntet på deg som enten nettopp har startet å bruke git, eller som har brukt det en stund men uten gjøre noe særlig mer enn å pulle, committe og pushe. Bruker du sjelden eller aldri komandolinja, men skulle ønske du kom deg over terskelen for å gjøre det? Eller kanskje du begynner å bli lei av å bruke musa? Da kan disse 10 minuttene være akkurat den drahjelpen du trenger. Her blir det i hovedsak live "koding" med eksempler på git kommandoer du kan risikere å bli avhengig av!
Git blir stadig mer utbredt. Det de aller fleste har til felles er at de har gått fra et versjonshåndteringssystem til et annet. For min egen del så gikk jeg over fra svn til git for ca 5 år siden, og jeg syntes overgangen var stor. Plutselig hadde man et hav av muligheter, noe som i starten føltes litt skremmende. De senere årene har verktøystøtten blitt veldig mye bedre, og man kan gjøre det meste uten å røre kommandolinja. Jeg er redd dette også fører til at stadig flere bruker mindre av den funksjonaliteten som finnes i git. Målet med lyntalen er å vise når og hvordan man kan og bør bruke både kommandolinja, ide'en (i mitt tilfelle Intellij IDEA) og SourceTree på en fornuftig måte. Jeg vil også vise hvilke git kommandoer jeg bruker i det daglige, og eksempler på hvordan du kan lage enkle script for å gjøre flere git kommandoer i sekvens.

Search algorithms mimicking various natural phenomena provide an elegant solution to the optimization problems in software engineering. Based on our experience of applying search algorithms in several industries, this task will present results, experiences, and lessons learnt while applying search algorithms to various industrial problems including optimal requirements allocation, optimal test data generation, and test optimization/selection.
Search-based Software Engineering (SBSE) is an emerging field that has brought excellent results in the recent years for solving complex industrial problems requiring optimization. At the core of the SBSE are the search algorithms (e.g., Genetic Algorithms mimicking natural selection process) that can efficiently find optimal solutions to the problems that have large complex search spaces. Typical examples of such problems in software engineering include: optimal allocation of requirements, optimal architecture design, test case generation, and test optimization. The talk will provide our experience of using search algorithms for solving the following problems in several companies in the last several years: 1) Optimal test case/test data generation; 2) Optimal requirements allocation; 3) Test optimization. The results will be presented in addition to a set of guidelines for the practitioners to apply search algorithms in their particular context.

Offentlige instansfelt! Er det EN TING vi har lært, så er det at offentlige instansfelt IKKE ER LOV. Og DTO-er? Sånt går bare ikke an lenger. Hva skjer om vi med kaldt overlegger gir blaffen i begge deler, og kjører på? Advarsel: Denne lyntalen handler om Java.
DTO-er er fy-fy, iallefall er de blitt det nå, og innen JavaZone 2014 åpner dørene er de antagelig blitt straffbare. Offentlige instansvariable har vært fy lenge, og i land som bare er litt strengere enn her hjemme kunne man antagelig innført fingerkapping for udåden. Så hva om vi slår sammen disse praksisene og lar dem systematisk gjennomsyre hele serverside-arkitekturen? Da får vi neste generasjon DTO 2.0, eller D2O! Der alle felt er offentlige! Hva skjer da? Jo, vi som er på serversiden får et naturlig grensesnitt mot utenomverdenen. Der ute snakker de ofte JSON, eller andre lignende strukturer. Vi får et gjennomsiktig serialiserbart dataformat, som kan tjene som meldingsformater, eller som super-enkel speiling av databasen din. Vi får nye måter å manipulere, validere, sammenligne og simpelthen bare se på dataene våre. Typene våre kan flyte sammen, uten at vi mister kompilatorens vaktsomme blikk, og vi får objekter som gjør én ting og bare én ting: Beskriver og dokumenterer et API. Vi får, kort sagt, tilbake det våre forfedre kjente som data, og elektronisk databehandling, og det uten å måtte lære opp alle i Clojure. EDB – idag staves det IKT, imorgen staves det D2O, og uttales Dee Two Oh! (På engelsk iallefall.)

Elm er et funksjonelt språk som kompilerer til HTML, CSS og JavaScript. Designet for Functional Reactive Programming har språket som mål å gjøre utvikling av interaktive web-applikasjoner til en lek. Kom og se hva du kan (og ikke kan) gjøre med Elm.
Elm er et funksjonelt programmeringsspråk for weben som kompilerer til HTML, CSS og JavaScript. Målet er å gjøre det enklere å utvikle interaktive brukergrensesnitt på weben, da språket fjerner mye detaljer for utvikleren som man må forholde seg til i tradisjonelle språk som Javascript. Elm er skrevet i Haskell og er designet for såkalt Functional Reactive Programming (FRP), et paradigme som egner seg utrolig godt til å skrive svært interaktive web-applikasjoner med en deklarativ programmeringsstil. I denne lyntalen vil jeg gi en introduksjon til Elm, hvorfor det ble laget, og hvilke problemer språket prøver å løse. Videre vil jeg gi en intro til hva FRP er, og spesielt hvordan dette er implementert i Elm gjennom såkalte signaler. Til slutt vil jeg vise eksempler i Elm som forhåpentligvis gjør at du også får lyst til å teste ut Elm. Denne lyntalen garanterer livekoding og masse visuelle eksempler. Kom og se hva du kan (og ikke kan) gjøre med Elm.

Vi skal ta en reise gjennom de største hendelsene gjennom tidene, hvordan du ble til og hvordan du kan være en gentleman.
Hendelser og hendelseshåndtering er i vinden som aldri før. Men hva er det egentlig? Er det farlig? Eller en helt naturlig måte å kommunisere og forstå historien? Vi tar eksempel fra Java-verdenen, og tar en titt på et hendelsesdrevet alternativ.

Writing clean, testable JavaScript can be a daunting task for front-end developers. Many find it difficult to get into and thus discard it. Test automation is an essential part of modern web applications, especially when it comes to maintainability. In this talk, I show how easy and straightforward testable JavaScript code can be written.
Very often we see untested front-end code going into production, merely depending on manual human testing. The problem is, the human error factor plays a role here, and as humans we often tend to make mistakes. Bearing that in mind, not having test automation on JavaScript code can lead to trouble. Test automation is an essential part of modern web applications, especially when it comes to maintainability. In this talk, I show how easy and straightforward testable JavaScript code can be written. Practicing test driven development and combining the power of AngularJS and TypeScript. With the use of tools such as Jasmine, Karma test runner and code coverage. And finally automating the whole process with TeamCity. After the talk, you'll know how to: - Practice test driven development with JavaScript - Combine AngularJS with TypeScript - Use AngularJS' test design capabilities - Use JavaScript testing tools; Jasmine and Karma - Automate testing with TeamCity

Må javaløsninger være store, tunge og vanskelige å deploye og drifte? Neida, selv en omfattende webløsning med Java, HTML5 og JavaScript kan være lekende lett å håndtere. Jeg viser deg en lettvektsløsning som lever 100% i skyen. Den kjører på en PaaS, skalerer bra og kan deployes på kort tid uten at brukerne legger merke til det.
Jeg deler erfaringer rundt utvikling og drift av en moderne javaløsning som kjører på en PaaS med Java som backend og HTML5 og JavaScript som frontend. Løsningen er omfattende med betraktelig kompleksitet; likevel er den holdt enkel og lettvekts, skalerer bra og kan deployes med en git push uten at brukerne legger merke til det. Jeg introduserer løsningen og arkitekturen som består av en Spring MVC og REST backend på en embedded Jetty. Datalagring er i MongoDB. Frontend består av Backbone.js, Require.js, Mustache templates, HTML 5, CSS 3 og LESS. Fra første dag i utviklingen har alt utelukkende levd i skyen: kildekode på GitHib, bygget av Jenkins på CloudBees, alle miljøer på Heroku, all data fordelt på MongoLab, WebSolr og Amazon S3, og er overvåket med New Relic, Loggly og Logentries. Jeg forteller om noen av de fordeler vi har av skydriften og de verktøyer som ofte følger med for f.eks. logging, provisjonering, overvåking og backup. Underveis vil jeg komme inn på hvordan vi har bygget inn prinsipper fra "The Twelve-Factor App" (http://www.12factor.net). Dette er viktige prinsipper for at en applikasjon kan kjøre i skyen, og handler bl.a. om eksterne services som add-ons, stateless applikasjoner, share-nothing arkitektur og horisontal skalering. Etter foredraget vil du ha sett at det går an å lage en omfattende, men likevel lettvekts javaløsning, hvor alt kjører 100% skybasert. Hvor lett og ofte vi kan deploye til produksjon og opprette feature miljøer. Og ikke minst, hvordan Inatur med dagens løsning klarer presset ved klokkeslettbaserte tilbudsåpninger, som var en av hovedutfordringene tidligere.

Many applications are built with the same architectural style: a layered architecture with (more often than not) an anaemic domain model. While easy to set up, this architectural style doesn't help us deal with growing complexity or heavy non-functional requirements. In this presentation, Allard will introduce CQRS (Command-Query Responsibility Segregation) and Axon Framework. CQRS is an architectural pattern that helps build scalable and maintainable software, by applying a few very simple, yet powerful, principles. Axon is a framework that simplifies the implementation of CQRS based architectures on the JVM.
The web has changed drastically the last few years. The browser is becoming the de-facto application platform for online cooperation. To accommodate this, applications need to be able to scale up and down dynamically as the number of users fluctuates. While a few years ago planned downtime was acceptable, nowadays most applications need close-to-100% uptime. Furthermore, the continuous need to innovate stresses the importance of extensibility and maintainability of applications. In this presentation, Allard will show how CQRS promotes the decoupling of components that change an application's state (the commands) from the components that provide information about the current state (the queries). This architectural approach makes it easier to handle increasing complexity and ensure the application's ability to scale. You will also see how CQRS can help build high performance applications and provide business value by storing valuable information about the application's history. Finally, we will cover how the Event Driven aspect of CQRS allows for decoupling of components, keeping applications extensible without compromising maintainability. The presentation covers the theoretical background of CQRS, but will mostly focus on the practical aspects, including code. You will learn how your applications can benefit by applying some very simple principles to your architecture.

A large change is afoot in software development. Baby steps have lead the way noted by continuous delivery efforts, virtual machines and service oriented architecture. Leading a cloud R&D team, It is clear the next steps in cloud development are through virtualized applications and application containers (not virtual machines). This movement has already started and is being used at Docker, Inc., twitter, foursquare, AirBnb and Baidu just to name a few.
This session will cover the future of cloud development using docker and mesos and how it will create a commoditized cloud solution and how it will change software development moving forward. DevOps and the whole continuous delivery pipeline will be affected from the commit stage forward. LXC and containerization is the secret ingredient to Linux added by Google in 2008. LXC have been difficult and tedious to configure until Docker arrived on the scene last year. Docker simplifies the containerization of applications and provides git-like capabilities at the service level of the CD pipeline. The remaining missing ingredient to a distributed software solution is a distributed operating system, which is solved by Apache Mesos. Mesos provides management and fault tolerance to big data solutions such as Hadoop and application services such as running Tomcat web service.

Dette er en workshop hvor vi fokuserer på de største og viktigste nyhetene i Java 8: Lambdauttrykk, Collections og det nye Stream-APIet. Workshopen er tre-delt hvor hver del består av en presentasjon av et tema etterfulgt av programmeringsoppgaver som deltakerne skal løse.
I workshopen starter vi med å lære lambda-syntaksen og hvordan lambdauttrykk passer sammen med funksjonelle interface og Single Abstract Method. Del to vil gå inn på funksjonelle begreper som filter, map og reduce og hvordan de brukes i det nye Stream-APIet og bruk av Optional. Siste del tar for seg andre nyttige metoder i Stream-APIet, parallelle- og uendelige strømmer og mer avansert Collectors-metoder. Etter workshopen vil deltakerne være kjent med lambda-syntaksen, vite litt om funksjonelle begreper som filter, map og reduce og kjenne til det viktigste i Stream-APIet. Det forutsettes ikke forkunnskaper i Java 8, men alle må ha med PC med Java 8 installert og en IDE med Java 8-støtte.

En stegvis gjennomgang av et forslag til integrasjonsarkitektur. Vi begynner med blanke ark, og legger til ett og ett element, inntil vi har en komplett integrasjonsløsning. For hvert steg bruker vi konkrete eksempler for å se hva vi oppnår ved å legge til elementet.
Hvorfor er integrasjons så vanskelig? Hvorfor kan jeg ikke bare kjøpe en ferdig integrasjonsløsning? Hvor skal jeg begynne? Hva trenger jeg? Hva trenger jeg ikke? Hvor komplisert må en integrasjonsløsning være? Hvordan strukturere jeg en integrasjonsløsning? Denne lyntalen går igjennom et forslag til integrasjonsarkitektur, som har vært utgangspunkt for mange integrasjonsløsninger. Disse løsningene har vært av varierende størrelse, implementert med forskjellig teknologi, og laget for å løse forskjellige integrasjonsbehov. Gjennomgang vil kort, konsistent og konkret se på: Hvilke elementer en integrasjonsarkitektur kan bestå av. Hvilken nytte og hvilke utfordringer hvert element kan gi oss, og i hvilke situasjoner de gir en særlig verdi. Hvilke elementer som bør inkluderes fra første dag, og hvilke som kan legges til ved behov. Samt hvilke implementasjonsmuligheter som finnes for hvert enkelt element.

How do you design an open web programming language that is modern, productive, fast, and that can be translated to efficient JavaScript? That were the challenges we faced when starting the Dart project.
The design of a programming language is often bound by several factors: legacy, simplicity, backwards compatibility, and performance. This talk will discuss some of the tough language design choices we made long with the explanations how we ended up with the current design. At the end, I hope the audience will agree that we make the right design decisions.

Releasing an open source project while maintaining a shipping product is hard! Different behaviors, attitudes and actions can help or hinder your cause; and they are not always obvious.
The Blueflood distributed metrics engine was released as open source software by Rackspace in August 2012. In the succeeding months the team had to strike a manageable balance between the challenges of growing a community, being good open source stewards, and maintaining a shipping product for Rackspace. Find out what worked, what did not work, and the lessons that can be applied as you endeavor to take your project out into the open. In this presentation you will learn about strategies for releasing open source products, pitfalls to avoid, and the potential benefits of moving more of your development out in the open. We have also made a few realizations about the community growing up around metrics. It is still young, and there are problems that come with that youth. I'll talk about some things we can do to make a better software ecosystem.

En workshop som gir en introduksjon til hva Docker er, og hva det kan brukes til. Vi kommer til å la deltagerene prøve ut de forskjellige delene av Docker, samtidig som vi forklarer hva de kan brukes til.
Workshoppen kommer til å gå igjennom en kort introduksjon til Docker, før vi går over på alle stegene som trengs for å produksjonssette en Java-applikasjon ved hjelp av Docker. Deltageren får prodsette en enkel applikasjon som kommuniserer med en database, som hver kjører i sin egen Docker-container. Krever installasjon av Vagrant og nedlasting av en virtuell maskin på forhånd. Dette er en halv-dags workshop.

Take a deep dive into distributed real-time stream processing and be inspired by a technology which allows a new set of applications
Dominated by batch oriented Hadoop-based Map/Reduce implementations for 3 to 5 years, lately we saw a switch towards real-time stream processing in Big Data. Frameworks like Spark Streaming, Shark and Samza allowed a huge step forward into a more ad hoc based future of data analytics. Developed to serve true problems in specific environments these frameworks are not fully sufficient for our problem domain. Therefore we decided to design and implement our own framework with bonds from existing projects. At its core heart we designed the architecture to serve ad hoc requests like timed sample data extraction, pattern recognition or data enrichment without the need to deploy heavyweight artifacts right before process execution. This talk will present the architecture specification, discuss the requirements imposed by our (non-)technical departments that led to design decisions, describe the differences towards existing frameworks, give a forecast on our roadmap and show you the code base along with a short (live coding) example implementing & running a simple service. Although we are currently based on akka.io (for message/stream processing), Kafka (for message passing) and Zookeeper (for component configuration) knowledge towards these frameworks is not required to follow this talk. As we believe in the community, we plan to release project results and go open source. So, drop by and be inspired what's in store.

Let's play with elasticsearch and Kibana
We will install elasticsearch, Kibana and Marvel and will use that tools to: * index/update/get/delete documents * search * compute * build dashboards to make sense of marketing data * snapshot your data and restore them

En nyutdannet informatiker forteller om hvordan det er å jobbe som DevOps-utvikler på et stort integrasjonsprosjekt for Oslo Kommune. I dette prosjektet er det vanlig å prodsette kode allerede første dag på jobb.
Integrasjonsprosjektet i Oslo Kommune består av en plattform med mikrotjenester. Dette gjør at det er lett å drive utvikling uten å nødvendigvis ha innsikt i alle tjenestene. Pull requests mot en lokal Github-instans legger grunnlaget for effektiv QA av all kode som skal ut i produksjon. Deployment uten nedetid gjør at komponenter kan prodsettes når som helst. I denne lyntalen fortelles det om hverdagen for en fersk utvikler i et slikt prosjekt.

Erfaringer, råd og anekdoter fra et av norges eldste Scala-prosjekter.
De siste fem årene har et team hos Knowit benyttet Scala som hovedprogrammeringsspråk. Teamet har utviklet et tosifret antall løsninger, fra enkle web-portaler og saksbehandlingsløsninger til autentiseringsløsninger og relativt kompliserte styringssystemer. Teamet har variert i størrelse fra 2 til 6 personer, og totalt har 15 utviklere vært innom teamet til nå. Foredraget vil gi verdifull innsikt i et av norges eldste Scala-prosjekter og tilhørerene vil få erfaringsbaserte råd de kan ta med hjem til egne prosjekter. Foredraget gir en oversikt over hvordan vi benytter Scala og noen få open-source rammeverk til å lage smidige og vedlikeholdbare systemer. Vi vil se på hvilke fordeler vi mener å ha oppnådd sammenlignet med tilsvarende Java-utvikling, som for eksempel bedret vedlikeholdbarhet og færre bugs. Men vi tar også opp baksiden av medaljen, problemstillinger vi kanskje ikke ville hatt i java. Til sist snakker vi om hvordan det har vært å benytte et programmeringsspråk som var lite kjent i organisasjonen da vi startet, og forklarer hvordan vi har løst utfordringer knyttet til opplæring av nye team-medlemmer, valg av rammeverk og byggeverktøy, etc.

Larger and more complex systems calls for new solutions. Splitting the larger systems into smaller modules helps us reason about them in isolation, but leads to cross-module dependencies both for services and shared data. Managing these dependencies, in particular in a development environment, is hard, and gets harder by the number of modules. Virtualization and automation has taken us part of the way but it was Docker that finally helped us with some of the last wrinkles. This talk will show how the use of Docker can help streamline your development, versioning components and data, setting up dependencies and deployment to production.
The systems we develop at growing larger by the day, and the problems we solve keep getting more complex. One way we deal with both size and complexity is to divide our systems into smaller modules or components that we can reason about independently and develop in relative isolation. However, this comes at the cost of dependencies between these components when they interact, using data or services provided by another component. Setting up a streamlined development environment in this setting has become a major challenge. One solution is to use virtualization and tools like Puppet and Vagrant to automatically set up new virtual machines as needed. Virtualization comes with its own set of challenges, and only get you part of the way. The last year, Docker (http://docker.io) has joined the field as a fresh breath, putting focus on lightweight containerization and true portability instead of virtualization. This talk will showcase using Docker to iron out the some of the wrinkles in our environment using modules and partly shared data as an example, and how we use Docker in our day-to-day development cycle.

But how much reason supports the rituals and mantras often repeated as coding guidelines? It turns out that the advice often fails, even for the novices they are intended to guide. Let's reason through these rather than accept them as unquestioned habits.
How many asserts should a test case have or not have? How much work should a constructor (not) do? What mantra guides test-first programming? How do you name your classes and other identifiers? How do you lay out your code? These questions and others have standard answers based on received and repeated mantras, practices that are communicated in good faith to be passed on as habits. But how much reason supports these assertions? It turns out that the advice often fails, even for the novices they are intended to guide. This talk has little respect for ritual and tradition and takes no prisoners: What actually makes sense and what doesn't when it comes to matters of practice? What guidelines offer the greatest effect and the greatest learning?

Luksusfellen har blitt benyttet som en metafor for teknisk gjeld ved flere anledninger tidligere. Men da som oftest knyttet opp mot gjeld/kredittkort og ubetalte regninger. I denne lyntalen har jeg valgt en litt annen vinkling, og spør hva vi som foreldre/tech-lead kan gjøre?
Lyntalen er inspirert av en episode fra Luksusfellen på tv3 hvor moren gjør sønnen en bjørnetjeneste ved å hjelpe sønnen med den stadig voksende gjelden. I episoden får sønnen hjelp til å ta ansvar for egen økonomi og gjeld, og ikke løpe til mamma hver gang det dukker opp et nytt problem. Jeg ønsker med denne lyntalen og rette fokus på tech-leadens rolle, og hva denne personen kan gjøre for å begrense den tekniske gjelden i teamet/prosjektet. Tech-leadens viktigste oppgave er å være et forbilde og en foregangsmodell som de andre ønsker å følge. Han eller hun skal ikke nødvendigvis være utførende på alle oppgaver, men coache de andre deltagerne.

"Single Page Applications", or AngularJS in particular, aren't always the answer. Avoid the technology trap - choose the right tools for the job by thoroughly considering *what* the product you are making should be doing, and *not how*.
We've got so many choices to make when deciding how to build our solutions. We already have an extensive repertoire of tools and technologies that we've been using for years. And on the other hand, the web development industry is moving so fast it seems that every year, there is a new kid on the block that promises fulfill all our architecture wishes. The pace of the industry and the breadth of options make these choices non-trivial. Getting them right requires thorough understanding of (i.e. experience with) the pros and cons of the different options, and an educated guess is often the best we can hope for due to time and money constraints. Case in point: Frontend solutions for webapps. What's in it for you? Some hard-earned advice on what to keep in mind when planning new projects Some up-to-date insight into the frontend architecture options This talk is about avoiding the "hammer first"-principle and how to choose tools & technologies when making architectural decisions, with a focus on web apps.

Solving problems only 2% of population can solve made easy.
Ever heard of Zebra Puzzles? Those logical puzzles that are claimed to be invented by Albert Einstein as a little boy? Those that are based on simple logical facts and go something like this: “The Brit lives in the Red house. The Swede keeps dogs as pets. The Dane drinks tea… Who owns the zebra?” Some claim that only 2% of the population can solve it. However, with the help of semantic technologies we can solve it in (almost) no time. Of course you have to know RDF, OWL, Jena, reasoning, inference... The good news are that we want to teach you all that in this session. We will start with introducing the puzzle and the toolbox for solving it. We will build a semantic representation of the puzzle (basically, a graph!), programmatically add some inferred facts and reason and solve the puzzle. Suddenly solving puzzles is a piece of cake for the other 98%. p.s. Come with your “We are the 98%” banners ready. :-) p.p.s. This is a hands-on workshop, so bring along your super computer. Preferably with Git, Maven, Java, and your favorite IDE installed and ready.

The famous "Java Puzzlers" made it clear that there are quite a few cases when it’s rather difficult to answer the question "what does this code do?" (our intuition deceives us). In this talk we are going to rewrite some of the code snippets to Kotlin and discuss what can be fixed in a new JVM language, what cannot be fixed and whether it really matters =).
The famous "Java Puzzlers" book (as well as series of talks) revealed several cases when it's quite a challenge to guess correctly the behaviour of the code. While some are JVM-related, most of those cases have roots in Java language and libraries design. For each puzzler it's interesting whether it could be fixed in "an ideal world" (without backward compatibility constraints). In some ways a new JVM language provides an opportunity to study it. In this talk we are going to look at several traditional Java "puzzlers" and try to rewrite them to Kotlin.

What is it that makes some programmers more productive than others? As programmers, our professional work is that of solving puzzles. We may be solving different problems, but in my experience, the only way to solve a problem is to through feedback. In this talk, I will examine how to accelerate your feedback loop. I will show practical examples of how to solve both theoretical and practical problems by starting with a small system that solves part of the problem and expanding from there.
"A complex system designed from scratch never works and cannot be patched up to make work" "A complex system that works is invariably found to have evolved from a simple system that worked" To become more effective, you must find a smaller problem to solve _and_ maintain your ability to change the system to stay flexible and good while solving the full problem. I will show how to solve three problems with this philosophy: * A simple and theoretical problem, solved with pure, old-school test-driven development * A demanding user interface problem, solved with outside-in solution approach * A technically demanding problem, solved with a "shallow, then deep" solution approach All these approaches have in common that I quickly solve _something_ and then evolve my solution through safe steps.

Ved å følge prinsippene for progressive enhancement får vi mulighet til å bruke det siste innen HTML5, CSS3 og Javascript samtidig som vi er garantert at nettsiden vår fungerer på eldre nettlesere. I denne lyntalen skal vi se nærmere på hvordan vi kan bruke Node.js til å parallelt tilby brukeren en ren HTML versjon og en JS støttet versjon av web-siden vår.
Er du lei av å bruke tid på å støtte eldre IE versjoner på nettsiden din? Ønsker du å benytte deg av de siste web-teknologiene, samtidig som du gir en god brukeropplevelse for alle? Vil du at brukeren skal kunne interagere med nettsiden med det samme den er lastet fra server, uten å måtte vente på at et hav av JS biblioteker laster? Progressive enhancement er en web-designstrategi som etterstreber å utvikle web-sider som fungerer på alle typer enheter, men som også gir deg mulighet til å benytte deg av de siste teknologiene på enheter som støtter disse. Ofte blir progressive enhancement web-sider delt inn i tre ulike lag: ett innholdslag i HTML, ett presentasjonslag i CSS og ett skript lag i Javascript. I denne lyntalen skal vi se hvordan man ved hjelp av Node.js enkelt kan konvertere en single page Javascript applikasjon, som er avhengig av Javascript støtte i nettleseren, til en applikasjon underlagt prinsippene for progressive enhancement. Vi skal gjøre dette med minimale endringer i koden og med en dramatisk reduksjon i lastetid for alle brukere.

Det finnes så mange roller i et IT-prosjekt. Det bemannes opp med prosjekteiere, prosjektledere, arkitekter, testere, Scrum-mastere, driftere, dba-er, programmerere – og ofte enda flere. Hver eneste en av disse bidrar til at prosjektene mislykkes, eller at de er unødvendig lite effektive. Bli kvitt dem. I ruinene etter apokalypsen sitter en fyr uten noe annet enn en laptop og full tilgang i produksjon. Det er han som skal sørge for at IT-prosjektene lykkes fra nå av. Han er "The Ultimate Developer".
Har du noen gang irritert deg over at en person med en annen rolle enn din egen har bestemt noe som er i strid med hvordan du selv mener jobben bør gjøres? For eksempel en arkitekt, en prosjektleder, en produkteier, en Scrum-master, en programmerer eller en driftsansvarlig. Har du noen gang tenkt at "om jeg fikk bestemme så...". Har du slått deg til ro med at "sånn er det bare" eller "siden alle mener det så har vel de rett"? Hva om alle andre tok feil og du hadde rett? Jeg vil kontemplere over hvorfor det store antallet roller er mer en hemsko enn et vellykket forsøk på ansvarsdelegering og utnyttelse av spisskompetanse. I foredraget vil jeg forsøke å vise hvorfor det er en hemsko, og også hvorfor vi har levd med den så lenge, og fortsatt lever med den. Jeg vil argumentere for at de eneste rollene som behøves for å få til vellykkede IT-prosjekter er den som skal tjene penger på det som lages, brukerne og "The Ultimate Developer".

På Java-siden har vi de siste årene sett et skifte mot forenkling - og ikke minst skepsis til etablerte rammeverk som Spring, Hibernate osv. Hvorfor trekke inn Spring bare for å instansiere objekter og få enkle transaksjoner til å funke? Samtidig har vi blitt tutet ørene fulle av Backbone, Angular, Ember og hva de nå heter - de ene JavaScript-rammeverket mer fantastisk enn det neste.
Eivind tar et skeptisk blikk på noen JavaScript-rammeverk han har vært borti - og viser hvor lett det er å skrive en del greier selv. Sammenligningen med Java og Spring og slående :)

The tight platform coupling found in most common web publishing systems is a potential bottleneck for enterprise level availability requirements in large web properties. Using a separated publishing architecture with an enterprise CMS decoupled from its web servers can provide a range of advantages including the potential for extremely high availability and scalability.
While your business might have a non-religious attitude to technology platforms in general, many common web CMSes will limit you to using their preferred platform throughout your publishing architecture, and while it might be a good tool for the editorial staff this platform might not be the best choice for your organization overall or to provide the needed flexibility in regards to availability or scalability. Using a loosely coupled CMS with a multi-platform architecture allows you to avoid such problems however. One option is the enterprise experience manager SDL Tridion which has a .NET based CMS for content editors but allow for publishing the dynamic web pages created through an application server of choice. This architecture provide many advantages such as the independent availability of the CMS and the web properties it handles, as well as being able to use open source java solutions for clustering while having an easy-to-use .NET-based user interface for content editors. This talk will give an overview of some benefits gained by such a combination of technology platforms by detailing the systems architecture for a major Norwegian web property as an example.

Lambdas and streams are more than just a more elegant way to express the same functionality. One of the major enhancements is that the underlying implementation of the stream API may process streams in parallel. This enables developers to use modern multi core processors efficiently with very little programming overhead. This talk shows how to use parallel streams to improve performance of a classical JEE server application.
Lambda expressions and streams are among the most important new features in Java 8. In many cases, lambda expressions enable the developer to write more concise and expressive code than with previous Java versions. Streams are a new API for applying lambda expressions to traditional data structures, like ArrayList and HashMap. However, the combination of lambdas and streams is more than just an elegant way to express the same functionality. One of the major enhancements is the ability to process streams in parallel. Parallel stream processing enables developers to use modern multi core processors efficiently with very little programming overhead. This talk presents Java 8 lambdas and streams, with a special focus on the parallelization features: * How can we use the parallelization features of the new standard library? * How can we implement our own data structures to support parallel processing? * What are the use cases for parallel stream processing, and when is parallel processing not feasible? * What are the technologies supporting parallel stream processing under the hood? These topics will be exemplified in a classical JEE server application.

The Java EE 7 platform has four new components (WebSocket, JSON-P, batch, and concurrency), three that are significantly updated (JAX-RS, JMS, and EL), and several others that bring significant changes to the platform. As you can imagine, a lot of new functionality has been introduced in the platform. In this fast-paced session, you will learn about 50 new features introduced in the Java EE 7 platform. @ClientEndpoint, chunk-style batch processing, @FlowScoped, @AroundConstruct, @JMSDestinationDefinition, and @Transactional are some of features the presentation covers. It explains each feature with a code snippet and provides details on where and how you can use it in your applications.
The Java EE 7 platform has four new components (WebSocket, JSON-P, batch, and concurrency), three that are significantly updated (JAX-RS, JMS, and EL), and several others that bring significant changes to the platform. As you can imagine, a lot of new functionality has been introduced in the platform. In this fast-paced session, you will learn about 50 new features introduced in the Java EE 7 platform. @ClientEndpoint, chunk-style batch processing, @FlowScoped, @AroundConstruct, @JMSDestinationDefinition, and @Transactional are some of features the presentation covers. It explains each feature with a code snippet and provides details on where and how you can use it in your applications.

WebRTC (web real-time communication) is one of the hottest buzzwords this year and have been hyped as the future standard of communication services. But few have yet gotten experience with actually working with it. This talk will give you an introduction to what WebRTC is, the history behind it, what you can use it for, and current challenges with it.
The talk will look into the different use cases for WebRTC, in addition to walking through setting up your first WebRTC call in the browser. The team at appear.in has gotten extensive experience with WebRTC, the quirks you need to work around, and the best use cases for it right now.

Hvordan FINN bruker SOLR, Elasticsearch, Cassandra og Kafka til å matche 10 millioner koblinger pr dag mellom brukerenes lagrede søk og annonser som legges inn. Tidligere fikk du en epost om morgenen, nå kan du få varsel på din telefon sekunder etter at annonsen legges inn.
På FINN har brukerne lenge hatt muligheten for å lagre søkene sine til senere bruk, samt få daglig e-postvarsling på dette. Med inntog av nye enheter med mulighet push-varslinger ser vi at daglig varsling tilhører fortiden og har laget et system for å varsle brukerne mer eller mindre øyeblikkelig. Prospective search, alert, percolate, lagrede søk. Kjært barn har mange navn, men få implementasjoner. I vår søken fant vi veldig få referanser til hvordan dette kan gjøres med SOLR-indekser. Vi bestemte oss tidlig for at Elasticsearch' implementasjon (percolate) hadde mye bra ved seg, men det var ingen opsjon å bytte ut vårt primære SOLR-søk med Elasticsearch. Videre var det nødvendig med mange tilpasninger for å få systemet til å yte de volumene FINN har, spesielt på antall lagrede søk. Vi har laget en hybridløsning hvor oversetter mellom SOLR, FINN's eget søkeformat og ElasticSearch. Systemet lytter kontinuerlig til annonsetilgangen på hele FINN, og matcher dette opp mot alle brukernes totalt ca 600.000 lagrede søk. Treff pushes videre til FINN-strømmen, mobile enheter og epost. Presentasjonen vil gå gjennom løsningen i detalj, fra initielle betraktninger, via arkitekturen og implementasjonen, til testimplementasjoner og en betraktning av hva vi synes er bra og mangelfullt ved løsningen.

Working as a penetration tester specializing in Web-application security I have seen secure code and insecure code. I have worked with developers with specific implementation problems, project managers on building security into applications and company managers regarding information security strategy. These collective experiences and some of the most important and common areas in web-applications where vulnerabilities arise will be the main focus of this talk.
The growing focus on securing our critical infrastructure and business critical applications has thrust the field of penetration testing into the limelight. Being more than one-time testing, it has now become an integral part of many organizations quality assurance programs, internal audits, strategic planning and among the key selling points in new and existing applications. This has put the security consultant and penetration tester in a role as the information security conduit between the development team as well as the board of directors and management. Constantly switching focus between code- and implementation level advice for developers up to security strategy and development lifecycle at the managerial level. This has provided a unique view of organizations fighting to maintain focus on information security all the while doing business in a tough marketplace. We will present experiences from working in the field of penetration testing, from encountering suppliers and clients to working with management and developers that are trying to provide the safest possible solution. All while fighting to maintain budget, tight deadlines and their own fear of security breaches. We want to show developers what vulnerabilities that are commonly found in key features of their web-application, some of the biggest security concerns that are usually forgotten when implementing Authentication and Session handling and discuss how to build inn security features from the beginning. There will be focus on the processes, code examples, functionality examples and how to detect these types of vulnerabilities in your own application. We will give an insight into the questions and overall strategies that we have encountered during our careers.

Estimates, we're bad at it. Really bad. Yet we continue to do it. Why don't we accept the fact that it's hard to predict anything, especially the future, and deal with it? #NoEstimates is a way to do deal with it: don't estimate, just count the number of work items on your list. Sounds simple, but does it work in real life?
The #NoEstimates movement claims that it can give better predictions on the time of completion of a project by not doing any estimates, but rather counting and tracking the number of work items on your list. This talk will give you a short introduction to how that works in practice, and some of its advantages. But be cautious: #NoEstimates doesn't solve everything, and has some drawbacks that we'll discuss too.

How to get the most bang for your buck when designing systems for the cloud.
Now that more and more systems are moving into the cloud, running on platforms such as Amazon Web Services (AWS), Google App Engine, or Microsoft Azure, many architects and developers find themselves stumbling into a new landscape where resources are charged by usage. This presentation gives some pointers on how to design your systems to make the most of your budget and avoiding unnecessary costs from your cloud services. You'll learn about the commonly available services on the most popular cloud platforms and how picking the right service for the job can save you large amounts of money. Among other topics, you'll hear about automatic scaling, storage services, content delivery networks, spot pricing, crowdsourcing, and when it makes more sense to run your own physical servers. There will also be advice on how platform-as-a-service and moving tools like build servers and automatic testing into the cloud can save you precious developer time.

A full-day tutorial for developers interested in learning graph data and Neo4j by doing.
This intensive, highly practical Neo4j tutorial will provide you with the skills required to become effective with graphs and productive with Neo4j. Join this course to learn Neo4j's awesome Cypher query language and how you can use the world's leading graph database to manage and query sophisticated connected data. You'll learn how to model rich domains as labelled property graphs and perform sophisticated queries over them simply by drawing (ascii-art) patterns! While we will touch on the theoretical foundations from graph theory, the focus of this Neo4j course is most definitely practice: you will gain a thorough understanding of how to use Neo4j to best advantage across a myriad of domains (time series, social network, logistics, telecoms, etc). After completing the course, you'll be confident to design robust data models and efficient queries.

Before the Web, clients connected to back-end servers without compromises. As the Web came along with HTTP, we had to give up some of the power of our connectivity. With the evolving open Web communications standards, now we have a unique opportunity to move on from a request-response based REST world to a true, event-driven architecture. Learn what it takes to connect physical devices, such as Arduino and the Rasberry Pi to collect sensor data, or control physical devices over the Web.
Commercial aviation's biggest challenge when things go wrong is that flight data is stuck on the plane inside the black box. Until the black box is recovered, we barely know anything about what went wrong. This presentation offers detailed insights into how IoT and modern Web communications concepts have the power to change all this. If you're a maker, you will learn about "flight sensors" attached and controlled by Arduino, data transmitted over long range WiFi as well as satellite networks. If interested in real-time Web communications, you'll learn about a highly secure WebSocket implementation with extreme scale, publishing flight data to tablets and laptops used as monitoring dashboard. If protocol layering, enterprise messaging, or JMS is your thing, this talk is for you. Code samples and plenty of interactive live demos (with Things) add color to the talk.

Bring your continuous delivery pipeline to the next level with automated geb tests and a groovy domain specific language to create test data!
Creating automated browser tests is challenging, especially in those fast, asynchronous times. But fortunately we got plenty of tools to tackle the complexity and to write robust tests. With geb, the browser automation tool for groovy, you are able to write acceptance tests in a fancy way. You got a powerful page concept to avoid redundancy, full traversing support of the underlying web driver, support for asynchronous operations and the full groovy syntax goodness. But even with a good automation tool you still need to setup proper test data in your database for your tests. Groovy to the rescue! Say goodbye to boring sql scripts or confusing xml files. Use groovy features instead, write an expressive domain specific language and let the rest handle spring for you! In this talk I will present geb tests in action and show how easily complex test data could be created with groovy.

Find out how Vaadin and the functional features of Java 8 and Scala empower you to write more clear UI code.
The functional programming style fits the event based development paradigm of Vaadin very well. This presentation explores how the functional language features of Java 8 and other JVM languages combine with Vaadin to allow you to write more clear UI code. After introducing the tools we start with a short application in Java 7, and evolve it step by step using the capabilities of Java 8 and Scala to demonstrate the benefits of each.

Hvorfor unødig tilstand gjør koden din dårlig, og hvordan unngå det med bare noen få enkle tommelfingerregler.
Lambdaer er fint, men man glemmer ofte den andre store lærdommen fra funksjonell programmering: tilstandsløshet. I denne lyntalen vil jeg argumentere for kostnadene ved unødig tilstandsfull kode, og vise med eksempler hvordan man med enkle grep kan kode i en mer tilstandsløs stil i helt vanlig Java, at det er minst like lett, og at koden blir bedre. Jeg fokuserer på pragmatiske, billige og lett forståelige tiltak, og det blir ingen funksjonell purisme, sære tredjepartsbiblioteker eller kryptisk syntaks.

Continuous Delivery and architecture intersect in interesting ways, ranging from operational concerns for deployment pipelines to the ability to evolve your architecture over time.
Continuous Delivery is a process for automating the production readiness of your application every time a change occurs – to code, infrastructure, or configuration. It turns out that some architectures and practices yield code that works better in this environment. This session takes a deep dive into the intersection of the architect role and the engineering practices in Continuous Delivery. In the Continuous Delivery world, rather than hone skills at predicting the future via Big Design Up Front, the emphasis lies with techniques for understand and changing code with less cost during the process. I discuss the role of metrics to understand code, how Domain Driven Design’s Bounded Context reifies in architecture, how to reduce intra-component/service coupling, and microservices architectures, and other engineering techniques.

Lurer du på hva iBeacon er for noe? Og hva du kan bruke det til? iBeacon er Apples nye protokoll for kommunikasjon og mikrolokasjon over Bluetooth. Sannsynligvis går du allerede med en dings i lomma som kan både oppdage og fungere som en iBeacon. I denne lyntalen gir vi deg en rask innføring i teknologien, og viser deg hvordan du enkelt selv kan sette opp en iBeacon og lese den med din smarttelefon.
Denne lyntalen vil forsøke å gi tilhørerne svar på spørsmålene “hva”, “hvorfor” og “hvordan” rundt Apples iBeacon-protokoll. Apple reklamerer selv med iBeacon som en teknologi for å utvide lokasjonstjenestene i iOS, og har allerede begynt å bruke den i sine butikker. Med iBeacon kan man utvikle inndørs lokasjonsbaserte tjenester med stor grad av presisjon, og anvendelsene strekker seg fra varehandel til automatisering av hjemmet. Vi skal i tillegg til å fortelle hvordan teknologien fungerer, fortelle om eksisterende anvendelsesområder og skissere noen fremtidige. Vi skal vise deg noe av den hardwaren for iBeacon som finnes i dag, samt fortelle deg hvordan du kan bruke smartelefonen din som iBeacon til testing og utvikling. Videre skal vi fortelle litt om noen av de ulike leverandørene av både dingser og rammeverk, og vår erfaring med dem. Vi vil også gi en live demo av både muligheter og begrensninger med iBeacon. Til slutt vil vi gjerne vise hvor lite kode som skal til for at du selv kan komme i gang, og vi håper dermed å inspirere deg til å dra hjem og lage noe kult!

This presentation will give developers insight into how to model data in Cassandra, how to integrate Cassandra and Hadoop, and how to build big data platforms suitable for both batch and real-time processing while maintaining low latency response times suitable for web applications.
This session will go through various product development where Cassandra has shown to be the best choice. Focusing on the primary use-case: a tracking solution that collects raw time-series data in c* and aggregates it near real-time using Hadoop into various new datasets from advert-centric statistics to user-centric behavioural analysis. Mick will cover the final technical design chosen after three years of development iterations, touching on technologies: scribe, thrift, kafka, hadoop, pig, mahout; the hurdles faced along the way, integration improvements done between cassandra and hadoop, and the throughput and performance of today's systems.

Hold presentasjoner på en helt ny måte! Jeg viser deg hvordan du kan bruke moderne webteknologier til å ta presentasjonene dine til et helt nytt nivå!
Nye og gamle webteknologier gir oss mulighet til å gjøre ting med presentasjoner som vi tidligere knapt kunne forestille oss! Live tilbakemeldinger fra publikum, live videokonferanse i slidene, animert 3D… mulighetene er grenseløse!

Advice about software design focuses on the principles designers should adhere to and the structures that should be created. This leaves designers prone to creating the right design at the wrong time. "Why, When & How" fills this gap, giving designers an understanding of the overall goals of software design, when various techniques become relevant, and how to move smoothly from yesterday's design to today's.
Why A goal of software design is to enable changes to a program. We may optimize the speed with which the next feature appears (latency), the number of changes per unit time (throughput), or the predictability of features (variance). Software design is also an aesthetic experience for the designer. Optimizing for minimizing discomfort or maximizing satisfaction may conflict the the economic goals of the system. When The presumed high cost of change has led to bias for early design. However, speculative design comes with substantial costs. What are the tradeoffs that go into the decision that today is the day to change a design? How can designers actively use waiting as a design activity? How How can large changes to software design be made quickly, cheaply, and predictably? My bias is towards making large changes in small, safe steps. How is this practically done on large, production systems?

In this talk, we explore the bleedind edge of Continuous Delivery (CD). We discuss log-benchmark releases and elastic-scalability deployments as well as pros and cons of tools, e.g. comparing Chef and Puppet. All these discussions are embedded in the main part, that is an interactively set up delivery pipeline. Our pipeline integrates a lot of tools including Git, Artifactory, Bintray, Maven, Hudson/Jenkins, SonarQube, Flyway, Puppet/Chef, Vagrant and Docker. After attending this talk, you're on the bleeding edge of Continuous Delivery and DevOps.
Did you ever hear about these new things called Continuous Delivery and DevOps? In theory, all sounds so easy and meaningful. In practice, it's often hard to get started, both technically and non-technically, or to extend an existing solution to be robust and sustainable, and to span departments in the best possible way. This session shapes the core aspects of Continuous Delivery and DevOps. We talk about NoOps and deployment artifacts, including gradual log-benchmarked releases and pull-deployment/elastic-scalabillity zero downtime deployments. The main part of this session is the interactively set up example delivery pipeline pointing to good practices, proven in many big and complex project structures. After attending this session, you'll know the difference and interfaces of Continuous Delivery and DevOps, you'll be able to directly apply many recipes, know how to integrate lightweight best-of-breed tools as well as know about common pitfalls to look out for. You'll also be able to decide about what tool to choose, e.g. favor Chef over Puppet, or the other way round, and what's important about binary artifacts and how to make them cloud-enabled.

Come to learn all about the new Ceylon programming language: how it's different, what you can do with it and how it helps from development to deployment.
Ceylon is a new modern, elegant programming language for the JVM and JavaScript VM, designed for team work. But it's more than that, it is a full platform with modularity, an SDK, tools and IDEs. We will present Ceylon the language, the platform, and its ecosystem. You will see everything from starting a new project in the IDE to publishing it on Herd, our module repository, including using the SDK. We will also discuss the ongoing Ceylon projects such as the build system, Vert.x integration or Cayla, the new web framework. Finally we will discuss the plans for Ceylon 1.1, 1.2 and further.

Developers who work with quantities (sensor reading from edge devices, scientific, engineering, medical, or manufacturing) need to handle measurements of these quantities in their programs. Inadequate models of physical measurements can lead to programmatic errors. In particular when modelling a measurement as a simple number with no regard to the units it represents creates fragile code. Another developer or part of the system can misinterpret the number as a different unit.
Developers who work with quantities (sensor reading from edge devices, scientific, engineering, medical, or manufacturing) need to handle measurements of these quantities in their programs. Inadequate models of physical measurements can lead to programmatic errors. In particular when modelling a measurement as a simple number with no regard to the units it represents creates fragile code. Another developer or part of the system can misinterpret the number as a different unit. For example, it may be unclear whether a person's mass is expressed in pounds, kilograms, or stones. A human reading „10°C“, „10 C“ or simply „10 Degrees“ may interpret each of those correctly. For M2M communication, unless a program contains a „Babel Fish“, such ambiguity would not be acceptable. Don’t Panic: After programming languages like Ada, C++, Eiffel or F# added type-safe Unit support already, JSR 363, Units of Measurement API will add similar support to the Java Platform, making it competitive for M2M in the Internet of Things with strong emphasis on sensors. This session provides an overview of popular use cases for the Units of Measurement JSR and implementations on both Java ME 8 Embedded (CLDC 8) and Java SE 8. A Hitchhiker’s guide across places where this JSR helps improve data quality or save lives by ensuring e.g. a patient receives the correct dosage of medicine or smart homes and similar energy saving measures prevents Earth from being destroyed by Global Warming (rather than waiting for a Vogon express route ;-)

How can you and your business leverage Open Source better? Let's improve communication, quality, reputation and business value!
Free, Libre and Open Source software permeates almost all businesses today; but how can we get more out of it? This isn't about the old Gratis vs. Free software discussion. It's about communication, culture, enthusiasm, quality, discipline, aesthetics and more! In this talk, we'll explore different realms of Open Source, and see what we can learn. We'll touch upon technologies that make us work better, on culture and habits that improve quality and trust, on ways Open Source can help you become a better and more valuable developer and employee, and on tips and tricks that can help you and your business get the most out of your Open Source Software ecosystem of choice. You can expect thought-provoking ideas around motivation, attitude, volunteerism, fruit and social skills in code. Hope to see you there! :)

This workshop will give you an introduction to Gradle. Comparing Gradle, Maven and touching other build as well. It will teach you why you should stop using Maven and start using Gradle instead. We will go through examples of both starting from scratch and bulding a project and examples of migrating already existing Maven builds to Gradle builds.
We will start with an introduction to Gradle and a discussion of Gradle compared to other build tools like Maven, Ant. We'll look at examples and exercises that will show you how you can migrate your existing projects from Maven to Gradle. We are also going to look at how you can build a project from scratch. This workshop will also go into solving the most common tasks people have to do, like building a fat jar. If we have time we will look at tips and tricks for Gradle. Talk a little about integration with IDEs and if there is interest for it we can spend some time on Android and Gradle. After this workshop you should be able to use Gradle instead of Maven and migrate your already existing projects to Gradle.

Why can’t we just add a feature to our system without tearing the code apart or, worse, patching around it? It ought to take just a few lines. We know the code is supposed to be modular and coherent, but too often it just doesn’t turn out that way.
We don’t believe it should be this hard to change object-oriented systems. We’ve seen examples where it really is that easy to add a new feature. The difference seems to be in the intermediate level structure. The design principles that most programmers rely on don’t address the middle ground where the complexity lies. We know about principles and patterns at the small scale, such as SOLID, and the large scale, such as REST. We’re less familiar with the structures in the middle. This talk is about design principles that we’ve learned help us develop mid-scale code structures that are easy to read and easy to change. At the lowest level, this means well-known patterns such as avoiding globals and following SOLID guidelines. At larger scales, this means assembling those SOLID objects to avoid hidden coupling so that the system as a whole is amenable to change. We focus on how objects fit together and communicate, and on being clear about how capabilities and information flow between objects in the running system.

In use in nine countries around Europe and having been live in production since 2007, Erex has stood the test of time as a powerful application for the calculation of railway energy settlements. This is a presentation and demonstration of how Erex uses adaptive object modelling to create a highly customisable calculation engine for the processing of time series data captured by the train energy metering points as they travel through time and space.
As a consumer of many gigawatt-hours of energy every year, the railway industry is obviously keen to save money by measuring the energy usage of its trains and improve their efficiency wherever possible. To accomplish this railway operators across Europe are equipping more and more of their train fleet with energy meters designed to constantly record energy consumption (and generation) and location information and then transmit this data elsewhere for further analysis. Harnessing this vast quantity of data to calculate an accurate quantity for settlement, while simultaneously dealing with varying local restrictions and regulations, energy prices, taxes, and various other factors is no small feat! Yet this is precisely what has been achieved by the Eress organisation's Erex project. This presentation will provide an insight into Erex, how we model our data, and the graph-based processing engine developed specifically for calculating energy settlement in an extremely configurable manner. More information about the Eress organisation and the Erex project can be found on the Eress homepage (http://www.eress.eu) and on Twitter (@EressOrg).

Hvordan vise 3D-grafikk på web? Med denne presentasjonen vil du få innsikt i hva det er mulig å få til ved hjelp av WebGL i en moderne nettleser - også på iOS plattform. Samtidig får du praktiske tips om hvordan du kan strukturere koden din, spare tid i feilsøkingen og få god ytelse.
Presentasjonen vil gi en introduksjon til 3D-programmering, mer spesifikt i WebGL. Hensikten er å vise hvor enkelt det er å bruke nettleseren som plattform til å vise avansert 3D-grafikk med full hardware-aksellerasjon. Samtidig vil nybegynnere få hjelp til å komme i gang med et godt basis oppsett for utviklingsmiljøet sitt - og innspill til hvordan man kan gjøre feilsøking i et ellers komplekst og lite intuitivt programmeringsmiljø hvor man blant annet må skrive C-lignende kode uten støtte for hverken syntakssjekk eller logging og debugging. I presentasjonen vil det bli vist hva som er state-of-the art innen 3D-grafikk, og også hvordan man bygger opp en applikasjon - fra et helt enkelt Hello-World-nivå og opp til en godt strukturert løsning. Presentasjonen vil rundes av med fokus på praktiske hensyn man bør ta utenfor selve WebGL-koden, så som alternative 3D-biblioteker, hvordan man bør håndtere nettleserstøtte, og hvordan man bør tenke for å kunne flytte kode over fra webapper og til native applikasjoner.

We are lucky to live in a Golden Age for IT geeks! On a given date one can pick and choose between a plethora of IT themed events via meetup.com and other channels. With so many options, it is tempting to assume that all this is here to stay. But is it? Well, that depends partly upon YOU! The sustainability of this ecosystem is more fragile than you might think. Organisers, presenters and participants all have important roles to play. Attend this session to find out how YOU can contribute to the continued success of the Meetup revolution!
As an Englishman, one of my favorite Norwegian words is 'Dugnad'. It’s one of those words that doesn’t directly translate to English but for any non-norwegian speakers this word refers to voluntary work undertaken by a group of people. An example – recently my children’s nursery had a Dugnad where all the parents donated a couple of hours to do small jobs around the building – things like fixing doors, painting walls and disposing of rubbish. Working together to improve ones local environment really gives you a sense of community. It can even become an addiction! The 'Dugnad spirit' extends to the IT community. A quick browse of meetup.com reveals dozens of IT themed events running constantly here in Oslo. And what is best is that the majority of these are free! But you know what? It takes time, money and above all effort to keep this machine working! In this lightning talk I will draw upon my experiences from arranging numerous events over the past three years and show you some simple and effective ways of making a contribution and keeping this community alive! My goals are to: 1. Summarise the etiquette of Meetups. 2. Show how you can help your local Meetup community to thrive. 3. Provide inspiration and guidance for starting your own Meetup.

Working with Web development in Java is about as joyful ad having your teeth pulled. Luckily you can roll a Trojan horse filled with NodeJS awesomeness into any organization to help cure the pain!
Working with Web development in Java is about as joyful ad having your teeth pulled. Luckily you can roll a Trojan horse filled with NodeJS awesomeness into any organization to help cure the pain. In this talk I'll outline the tactics require and some tools to help you in freeing your Web developers from the chain of Java.

De fleste av oss bruker TODOs ofte, uten vi nødvendigvis tenker så mye på hvordan vi burde gjøre det. I beste fall kan TODOs kommunisere viktige ting for teamet, og øke kvaliteten av koden. I værste fall kan de skape mye forvirring og irritasjon. Så spørsmålet er, hvordan skal man bruke TODO's for få mest mulig ut av dem?
Har du noen gang vært i et prosjekt hvor kildekoden er full av uklare TODOs, som ligger der uten at noen egentlig vet hvorfor de er der? Har du noen ganger opplevd TODOs som skaper bare forvirring, eller irritasjon? Noen ganger sett TODOs som peker på en 5 år gammel JIRA-sak? Eller som er utkommentert? Eller som sier "fix me"? Hvis du synes dette høres kjent ut, så kan denne lyntalen være noe for deg. I denne presentasjonen skal jeg først vise noen veldig merkelige (eller morsomme) TODOs fra virkelige prosjekter, deretter belyser jeg grunner til det, hvorfor TODOs så ofte misbrukes, og konsekvenser av dette. Til slutt viser jeg noen enkle tiltak som kan hjelpe teamet ditt til å få mer ut av TODOs, og øke verdien til prosjektet istedetfor å skape forvirring og frustrasjon. Og forresten, visste du at det også finnes nokså skumle TODOs i kildekoden til Oracle sin Hotspot JDK (og de har vært der lenge)?

I fjor høst startet et integrasjonsprosjekt med felles datamodell og tjenestebuss som utgangspunkt. Ett år senere har vi lyst til å til å dele erfaringer med hva som gikk bra og hva som gikk åt skogen. Stikkord: Mule, felles domenemodell, mikrotjenester, integrasjon.
Mens gode prinsipper for tjenesteorientering holder stikk, er behovet for en altomfattende tjenestebuss mer tvilsomt. Produktet byr gjerne på mer kompleksitet enn enkle løsninger på praktiske problemer, og blir gjerne anskaffet før man egentlig vet hva man trenger. Vi ser på hvordan Mule preget løsningen og manifesterte seg i konsepter man kunne vært foruten. Videre ser vi på hvordan overgangen til mikrotjenester gav en vesentlig forenklet arkitektur som fortsatt holder tjenesteorientert tankegods i hevd. Tanken bak virksomhetsbrede domene-modeller er god, men blir fort problematisk. Konseptet drev frem kompleksitet i kodebasen, og vi viser hvordan splitting til sub-domener med konsistente vokabular (bounded contexts) ble en mer farbar vei.

There is a known vulnerability in a library you are using.... transitively....
Whether you are using npm, bower, maven or some other dependency management system, you are dragging in lots of dependencies. And most of them are transitive. As developers we all make mistakes, and sometimes those mistakes cause serious security holes. But not every library gets it's own Heartbleed style web page and media coverage. So how do we figure out any of our libraries have known security issues?

Introductory workshop to Akka with hands-on exercises and slides. Participants can choose to do exercises in Java or Scala. The following parts of Akka will be covered: Actors (creating them, their life-cycle and communication via messages), Supervision and Death Watch, and Routers.
User today expect responsive applications with close to zero downtime. To achieve this, concurrency, parallelism and fault tolerance is a necessity, however, building such systems is a complex task. Akka addresses the complexity of building scalable and fault tolerant systems. Participants of the workshop will learn about Akka's primary abstraction, the actor model. Participants will also learn about how actors achieve fault tolerance through supervision and death watch, and scalability through routers. Each concept in Akka will be covered with slides containing theory and mostly code examples, and concrete exercises where the participant can choose to use Java (8) or Scala. It is recommended that participants bring their own laptop, or participate in pair-programming, for the exercises.

Go reactive with me as I'll demonstrate how you can utilize react.js to build an interactive client-server web application in the browser.
Learn how to "think in React". This means throwing out the classic notion of using templates and building views with Javascript, and re-rendering your entire application everytime your data changes. This a radical approach that requires a new way of thinking when you're developing apps. In this talk I'll walk you through a demo app which will show you how React components are built, how they operate, how they communicate with each other, and how to test them.

UiO har utviklet en applikasjon for datainnsamling over nett, som nå brukes til innsamling av ekstremt sensitive data. Denne lyntalen oppsummerer viktige valg som er gjort for å holde sikkerheten på et høyt nivå samt skalere for flere hundretusen besvarelser.
Nettskjema er en egenutviklet Java applikasjon bygd på spring/hibernate/Freemarker/Jboss/Oracle. Applikasjonen brukes for all type datainnsamling og påmeldinger på UiO. Forskningsmiljøer på UiO, spesielt innen medisin og psykologi, har lenge sett behovet for å kunne samle inn store datamengder av høy sensitiv art. For at forskningen skal kunne foregå over lengre tid, er det ofte et ønske å koble data mot sykehusregistre og følge utviklingen til enkeltpersoner i etterkant. Det er også et behov for å kunne levere data fra hvilken som helst enhet (nettbrett, telefon, PC etc.) fra hvor som helst i verden. USIT lanserte i april 2014 en løsning der forskere kan la respondentene logge inn via IDporten til DIFI, svare på et skjema som PGP-krypteres og lagres i Tjeneste for sensitive data (TSD). TSD er et tilbud til alle Universiteter og Høyskoler i Norge og består av en intern infrastruktur på eget sikkert nett. Løsningen med Nettskjema og TSD vurderes som ekstremt sikker og skalerer til flere tusen samtidige innleveringer på alle typer enheter og nettverk. Denne lyntalen oppsummerer de tekniske valg som er gjort for å kunne holde det høye nivået av sikkerhet, skalerbarhet og brukervennlighet som løsningen idag tilbyr.

Code that we produce sucks! In this session, not only will we learn how to code better, but also how to raise the bar on a daily basis.
Business project are intensive and tiring. Tight deadlines often make developers produce the infamous "enterprise" code, the quality of which is the least important factor. "We are what we repeatedly do. Excellence, therefore, is not an act, but a habit" Aristotle used to say. Deploying our skills, however, is almost mutually exclusive from mastering them… In this session we will cover 33 things you want to do better, quicker and simpler applying the best of Guava, Lombok, LambdaJ, Mockito, Spock, Byteman, Groovy, Gradle, Logback, Git, Shell and others! Using some real-life examples we will have a peek at the code, analyze the flaw and propose a suitable solution. Not only will we learn how to code better, but also how to raise the bar on a daily basis!

Performance testing is often resource heavy and in need for special software and equipment. This talk will show you how you can do lightweight performance testing to get a feel of how your system will perform under stress straight from within your familiar IDE.
In small to medium sized projects performance testing is often the last thing to be thought of, if at all. The purpose of this talk is to show that it is fully possible for even the smallest of projects to get an indication of performance and find congestion points without the need for full scale stress test. By using readily available free (as in beer) open source performance tools it is easy and fun to set up some tests in only a couple of hours of effort. The talk will be using the Gatling stress tool to illustrate examples of testing scenarios.

After Object-Databases, XML-Databases, ORMs, and NoSQL, we dare have a look at SQL, the core database language and how it evolved - from a Java perspective.
In the past decade, RDBMS related traction has moved away completely from SQL towards JPA / JPQL, or even further, towards NoSQL. Evangelists have widely agreed that RDBMS are not "web scale", even if the race is far from being decided. In this talk, I want to show you how many features you're missing out on, when you don't do real SQL. When you don't take advantage of recent SQL standard evolutions, such as SQL:1999 hierarchical SQL, SQL:2003 window functions, or many vendor specific extensions. In an example session, we're going to look at how we can calculate running totals on medium-sized data sets using - nested selects - window functions - hierarchical SQL - the Oracle MODEL clause - stored functions And most importantly, we're going to see how the above can help us increase performance while we decrease the number of lines of code when using any of MyBatis, jOOQ, or SpringJDBC.

Log messages in files are a pain: they are hard to get hold of, difficult to search, and different sources are tedious to combine. This talk shows you ways to use logs as a real time source of information to react on problems – even before you users file a ticket!
Each node in every layer of your application has its own log file. In a production environment you need an admin to grant you access to the log files. Whenever you search for the causes of an error you will need to combine multiple log files to get the information you need. This talk puts the spot light on three tools that help handling log messages. All of them provide access controls for your logs and can alert you when there are problem. But each of them has a different focus. These tools are Errbit, logFaces and graylog2. Errbit will receive all error messages from your application, from the back end and the frontend. It will group them for you so you know how many times the same error occurred. With every occurrence of an error it will store all context information so that you can easily browse it. It can also store release information to show you when this error occurred for the first time and when it was fixed. logFaces receives the full log stream from your application and makes it searchable. You can prepare search filters that help you with recurring tasks. From a given log message you can dig into your logs to find more about the same user, session or class. You can even see a live log stream of your application. grayLog2 gives you a highly scalable architecture and will process all your log files. It will index them using elasticsearch and search it for you using simple and complex queries. You can put the results as performance indicators or charts on dashboards that show you the current health status of your system. graylog2 has been completely redesigned for release 0.20; this talk will show the new features. This talk will help you to choose the right tool for the job. It will enable you to find the information without the hassle. These tools are the key to find and solve problems before your users complain and file a ticket.

I store organisasjoner som driver programvareutvikling vil det alltid foregå mange utviklingsaktiviteter i parallell og for å oppnå kontroll implementerer organisasjoner ofte standarder innen teknologi. Spørsmålet er hvor stor grad av teknologistandardisering er egentlig hensiktsmessig?
I en stor organisasjon med mange utviklingsprosjekter sier magefølelsen at man må styre, ellers har man ikke kontroll og det blir kaos. En måte å styre på er å definere standarder for hva man har lov til å bruke av teknologi. Kjent og styrt teknologi betyr at man kjenner konsekvensene av den teknologien man bruker, dets styrker og svakheter. Man har (i hvertfall en opplevd) kontroll på risiko. Men hva skjer i praksis? Har du noen gang opplevd effektiv standardisering av teknologi som ikke er til hinder og som har gitt målbar effekt? Motpolen til standardisering er å la prosjektene velge fritt og bruke den kompetansen de har til å utvikle løsningene sine effektivt. Og hvorfor ikke, dette sklir jo ut uansett, bare prosjektene blir store nok så gjør de som de vil. Og det er kanskje ikke så dumt? Alle utviklere har lyst til å være effektive. Man vil benytte teknologi som passer til den oppgaven de er satt til å løse og man vil levere verdi. I denne lyntalen vil jeg presentere en måte å gjøre teknologistandardisering som både gir utviklingsprosjektene spillerom til å være effektive, samtidig som det langsiktige forvaltningsperspektivet ivaretas.

Hvorfor er det en god idé å la teven din bruke ultralyd til å snakke med Android- mobilen din? Med ultralydteknologi kan vi oppdage og sikkert bevise at et sett av devicer befinner seg i samme rom. Vi skal forklare deg hvordan, og grave oss ned i signalbehandling og problemer som må løses for å få ultralydkommunikasjon til å virke.
Datamaskiner og andre dingser bruker gjerne kabler eller radiobølger til å snakke med hverandre, mens folk pleier å basere seg på lyd. Derfor er vi vant til lydens egenskaper; når vi lukker døra forventer vi litt privatliv. Radiobølger respekterer ikke disse grensene, de går rett gjennom gulv, vegger og lukkede dører. Men hva om vi lar dingsene bruke lyd til å snakke med hverandre, akkurat som vi gjør? Smarttelefoner og PCer har jo høyttalere og mikrofoner uansett, og hvis de bruker ultralyd vil de ikke forstyrre oss mennesker! Denne teknologien kan brukes til alt fra å forbedre innlogging i nettbanken til å dele presentasjonen i dette foredraget. Vi skal se på utfordringer rundt akustikk, modulering og koding, og vise hvordan de kan løses. Vi kommer til å spille en del lydsignaler og vise en android-demo, ja du kan til å med få se presentasjonen på din egen dings hvis du har med deg en.

Lambda og streams er ikke bare syntaktisk sukker men åpner opp for et helt nytt tankesett i Java. I denne lyntalen ser vi på ett enkelt kodeeksempel og viser hvordan dette bedre løses i Java 8.
Ofte uttrykker Java-kode HVORDAN et problem er løst, mens HVA problemet faktisk er ofte er vanskeligere å forstå ved bare å lese koden. Med Java 8 streams og lambdauttrykk så kan vi endelig snu på dette, slik at intensjonen er tydelig uttrykt i koden, mens både utvikleren og den som leser koden slipper å forholde seg til implementasjonsdetaljene. I eksemplet ser vi hvordan man kan gå fra eksterne til interne iteratorer og bruke patterns fra funksjonell programmering for å oppnå robust og lesbar kode.

Vi har alle vært der. Man må vurdere om man skal kaste gammel programvare fordi han som skrev koden pensjonerte seg for noen år siden og er veldig dårlig dokumentert. Men er det et spørsmål om å kaste alt og starte på nytt? I denne lyntalen presenterer jeg noen tips og triks for å gjøre om din legacy kode til å bli moderne og endringsvillig igjen.
Å ta i kode som du ikke kjenner eller ikke er testet er nesten som å be om problemer. Du vet at det kommer til å brekke og det kommer til å skje på verst tenkelig tidspunkt. I denne lyntalen vil jeg gå igjennom noen verktøy som alle utviklere bør ha i verkøykassen og noen forslag på hvordan man sakte men sikkert over tid kan få gammel kode til å blomstre igjen. Jeg kommer til å snakke om målingsverktøy, hva slags tester man bør skrive og hvordan gjøre ting som å bytte ut databasen.

Transitioning the citizen services completely open source - utilizing Java. Migrating and restructuring existing services and departments into a single cohesive scalable resource for delivering online information for services such as, vehicle information, civil service, judicial and anything else a government entity will require. A complete SOA restructuring of disparate systems, languages and services built on proprietary systems, integration of non standards compliant web services, databases, regionally distributed system while increasing uptime, scalability, response time and management of a single master data source.
This session presents a case study of a complete transition of citizen services to an open source platform, combining NoSQL, Camel, SOA techniques, and proven Java EE technologies. It shows how a scalable, distributed, secure system was built with modular rapid development techniques. The system integrates disparate proprietary and legacy systems into a fast, modern open source solution and puts the information necessary from each government entity into the hands of the citizens.

Unit testing ensures your production code is relevant. But what does ensure your testing code is relevant? Come discover mutation testing and make sure your never forget another assert again.
In the realm of testing, the code coverage metrics is the most often talked about. A line (or a branch) is considered to have been covered if during test execution this line has been run. However, it doesn't mean that the test has been useful or even that an assert has been coded. Mutation testing creates mutants from code - a deviation from the written code, and test them also. If a test still passes on a mutant, then the test is not relevant. PIT is a Java tool that makes mutation testing possible.

Event sourcing and CQRS are trending technologies. They free you from the tyranny of relational databases, ER-modeling, object relational mapping and impedance mismatch and let you implement truly modern applications: domain driven, asynchronous, reactive, and horizontally scalable!
Event sourcing and CQRS are trending technologies. They free you from the tyranny of relational databases, ER-modeling, object relational mapping and impedance mismatch and let you implement truly modern applications: domain driven, asynchronous, reactive, and horizontally scalable! Many developers have read up on event sourcing, but fewer have have actually built applications leveraging the technique. During this workshop you will create an event sourced application, learn best practices for design and implementation, experience pitfalls and discover solutions. No previous knowledge of event sourcing is required - we will kick off with a overview of the architecture where new concepts are introduced, and the goals and limitations of the technology are discussed. Bring your own laptop with your preferred dev environment. Examples will be given in Java, but you're free to use your favorite language.

Tingenes Internet - eller Internet of Things - er et av de mest hypede trendene akkurat nå. Utfordringen er å forstå hva som er hype, og hva som virkelig kan gi verdi. I tillegg er det en rivende teknologisk utvikling, med mange aktører som "kapper land". Nye allianser inngås hele tiden. Fagsystemer kan også dra nytte av denne utviklingen, under helt andre forutsetninger. Du kan få forståelse for alt dette gjennom å prøve deg på litt hobbyelektronikk og noen enkle standarder og verktøy som MQTT og Node.red, som er ypperlig for å drive prototyping av Internet of Things systemer i bedrifter. Du vil dermed kunne få idéer til hvordan du kan involvere fysiske sensorer og indikatorer for å øke utstrekningen og verdiene av de fagsystemene du jobber med.
Først vil jeg gjennom en liten science-fiction fortelling vise hvordan IoT virkelig kan tjene oss i fremtiden. Og vi har en vei å gå innenfor sikkerhet, forretningsmodeller, personvern og standardisering før vi kommer dit! Så går jeg over til å beskrive de mest lovende teknologiene og standardene, før jeg viser en live demo med en en sonar, Arduino, Raspberry PI, node.red MQTT, en snakkende hodeskalle, sensorer og Minecraft! Jeg kommer til å gå detaljert gjennom MQTT og Node.red - teknologier som blant annet brukes av IBM for å raskt kunne lage prototyper på Internet-of-things prosjekter for store bedrifter. Dette kan være relevant for deg, da de fleste konsulentselskaper og firmaer etterhvert vil komme borti tingenes internett. Jeg kommer til å vise meldingsflyt, kildekode og hvordan du selv kan komme i gang. Og om du rekker det, kan du i likhet meg meg lage en liten animatronics-velkomst som skremmer barna på Halloween...

Hva kan DU gjøre for å begrense den globale overvåkningen som vi alle blir utsatt for på Internett? I denne lyntalen får du vite litt om hva HTTPS er og hvorfor alle nettsider bør tilby en sikker tilkobling. Og ikke minst, hvor enkelt det er å sikre din egen nettside.
Det er liten tvil om at bruk av HTTPS vanskeliggjør den globale innsamlingen av data som utføres av etterretningsorganisasjoner over hele verden. Vi som utvikler og konfigurerer nettstedene der ute kan faktisk gjøre mer enn vi selv tror for å redusere overvåkningen. Denne lyntalen gir deg en kort innføring i HTTPS, hvorfor du bør bruke det på nettstedet ditt og til slutt en demonstrasjon av hvor enkelt det er å ta i bruk.

TDD gives us quality of code. BDD builds upon TDD to enable us to get quality from functional requirements. The goal is to guide us programmers to code what our customers wants.
BDD is all about writing your requirements as tests. From TDD we know that tests form your code design. BDD is all about having your requirements expressed through unit tests. This enables us to produce live project reports, automate our requirements, discuss the requirements with our customer, enable the customer to see live project status. Reduce misunderstanding. In the end giving the customer what he/she really wants. In this talk I will give an overview on BDD. I will give an introduction to BDD as it is practiced on a high level. But the focus will be on low level practices hoping to appeal more to programmers.

Architecting and developing user interfaces used to be relatively easy, pick a server side framework, define a standard monitor resolution and spend your days dealing with browser quirks. But today, the landscape presents us with a plethora of screen sizes and resolutions covering everything from a phone to a tablet to a TV.
Architecting and developing user interfaces used to be relatively easy, pick a server side framework, define a standard monitor resolution and spend your days dealing with browser quirks. But today, the landscape presents us with a plethora of screen sizes and resolutions covering everything from a phone to a tablet to a TV. How does a team embrace this brave new world knowing that the future will introduce even more volatility to the client space? This talk will walk you through this brave new world. We'll discuss the deluge of devices the typical application must deal with today as well as looking at the plethora of client side rendering technologies. This isn't strictly a front end problem though, we need to reconsider how we've built our server side solutions as well; modern applications rely on RESTful web services delivering data to a diverse set of clients. The development landscape has changed, this talk will prepare you to face these challenges.

Learn all you ever wanted to learn about RESTful services development challenges in large scale applications
This session is a deep dive as well as an interactive discussion on design principles, considerations, lessons learned from mistakes that can be taken into account when developing RESTful services. It will cover a variety of topics from Designing of RESTful resources, Versioning, Exception Handling, Caching, Validation, Security, Rate limiting, HATEOAS, Testing and Documentation. This talk will walk through and compare the different REST API provided by companies like Twitter, Paypal, Google, Stripe and more we can learn the good, the bad and ugly. So join me in this talk to build high quality applications that can be highly scalable, available and reliable.

Java, Scala, Groovy: in the end, all JVM languages compile down to the class file format and Java byte code. It is thanks to the flexibility of this intermediate instruction set that the JVM became a platform so rich in languages. And the ability to generate byte code at run time is a prerequisite for many popular libraries such as Spring or Hibernate. This talk gives an introduction to compiled Java code and discusses different libraries for generating classes at run time.
At a first glance, Java byte code can appear to be some low level magic that is both hard to understand and effectively irrelevant to application developers. However, neither is true. With only little practice, Java byte code becomes easy to read and can give true insights into the functioning of a Java program. In this talk, we will cast light on compiled Java code and its interplay with the Java virtual machine. In the process, we will look into the evolution of byte code over the recent major releases with features such as dynamic method invocation which is the basis to Java 8 lambda expressions. Finally, we will learn about tools for the run time generation of Java classes and byte code. Among those tools, I will present Byte Buddy, a novel open source code generator which is an attempt to considerably simplify run time code generation in Java.

Hva skjer når man tar en gjeng med ivrige designere og utviklere, gir dem en spennende utfordring og kort tidsfrist? Med dagens frontend teknolog og sterk fokus på brukeropplevelse gikk vi fra en abstrakt idé til realisering av ny feedback app på tre uker. Tilbakemeldingene har bare vært positive og snart lanseres appen for 280 000 brukere.
Vi deler våre erfaringer på hvordan dagens frontend teknologi understøtter entreprenørselskap og muliggjør raskere time-to-market. Vi jobbet med konseptutvikling, grafisk design og teknisk løsning i parallell i et team bestående av 3 interaksjons designere, 3 utviklere og én arkitekt. Vi fikk på oss tre uker og frie tøyler til teknologivalg og arbeidsmetode. Resultatet ble myOpinion (myopinion.accenture.com) - enkel, brukervennlig, morsom og transparent måte å gi øyeblikket tilbakemelding. Appen har blitt brukt på over 20 eventer, fått toppscore og er i ferd med å bli lansert globalt i Accenture med potensielt 280 000 brukere/ansatte.

Det finnes et utall plattformer for å lage webapplikasjoner; så hvorfor skal du vurdere Clojure? Fordi det gir deg mer kontroll, raskere feedback og færre bugs.
Clojure representerer et radikalt alternativ til webutvikling med objektorienterte språk. Det absolutt viktigste prinsippet bak Clojure er enkelhet. Det første spørsmålet som dukker opp er hvilket webrammeverk bør man bruke? Så snart du er komfortabel med Clojure så innser du at Clojure-kode vanligvis er enklere og mer gjenbrukbar enn det du er vant til. Dermed så gir det ikke så mye mening å gå til et altoppslukende rammeverk a la Rails med de begrensningene det kan medføre; men heller sette sammen det du trenger ut fra enkle komponenter til å få den oppførselen som passer i din løsning. Et annet sterkt argument for Clojure er den korte feedbackloopen man kan oppnå når man utvikler i et REPL. Kom for å bli kjent med webutvikling i et språk som vil forandre måten du tenker på.

The theme of this talk is that conventional power to IT Architects, and to IT Managers, the power to design the technical system, and Management power to design the IT or Software Organization is not placed in the right hands.
The theme of this talk is that conventional power to IT Architects, and to IT Managers, the power to design the technical system, and Management power to design the IT or Software Organization is not placed in the right hands. We have a number of historical case studies that show, that when this power is delegated to the developer level, then they actually do a much more impressive job of getting things right. We have case studies from IBM, Raytheon, Confirmit (Norway), Boeing, Primark (UK), and Citigroup which show that when management delegates the detailed planning and decision making to the programmer level, and uses such tactics as Defect Prevention Process (DPP, CMMI 5) and Evolutionary Value Delivery (Evo), using quantified goals and frequent quantified feedback (Agile as it was meant to be), then the results are far better than anything otherwise reported or known. The simple reason is that: Programmers are on the shop floor, and know what is realistic Programmers can make, and measure detailed technical decisions, evolutionarily, iteratively, and incrementally, that Architects and Managers cannot. So, it is not even a matter of programmers grabbing the power, but that it is in management interest to delegate it to them. This is not new. It is built into the original ‘agile’ concept (try Deming’s PDSA). But you have to add some quantification, and think like real software engineers, not mere ‘coders’. Are you up for that?

This live demo shows you how to create advanced web applications using the canvas element of HTML5. The Canvas Library framework and IDE lets you create the user interface for both business applications and games quickly and easily. As a programmer, you can finally make web applications the same way desktop applications have been made for years. As a web designer, you can create stunning UIs that will work directly in the browser, without having to find a programmer to implement your sketches.
The canvas element in HTML5 allows you to draw graphics directly onto a web page, without a plugin. Sounds great, right? But what do we use it for? HTML was designed for text with hyperlinks, not rich web applications. While you can make applications in HTML these days, canvas is much easier. Provided you have the right set of tools, that is. This talk demonstrates the tools you need: a library of user interface components, and an IDE to quickly assemble them into a working application. During the session, we will use the IDE to build a small demo application. This will demonstrate what you can do with a canvas, and convince you that, if you are looking to develop advanced user interfaces quickly, you should be using the Canvas Library.

FINN Reise besluttet i 2012 å bygge et nytt flysøk fra grunnen av. Dette innebar at man måtte integrere seg mot rundt 25 eksterne partnere for å innhente live flytilbud. Camel og Groovy viste seg å være en meget god kombinasjon når mange forskjellige formater skulle samles til ett.
For å få til en enklest mulig integrasjonsprosess falt valget tidlig på Camel. Etter noen iterasjoner for å skrive selve integrasjonene der vi prøvde forskjellige Java- og Groovy-varianter, falt valget på Groovy. Camel er bra på å sy sammen små biter, mens Groovy er bra på transformasjon av data. Det blir lite og oversiktlig kode for å integrere en ny leverandør. I denne presentasjonen vil vi først og fremst vise en masse bilder av kameler, men vi vil også fortelle om prosessen som tok oss i mål. Andre ting som vil bli omtalt er testing med Camel, trådhåndtering og connection pools og hvordan man starter og stopper en integrasjon on the fly.

Dette er et foredrag om hvordan vi må ta vare på kreativiteten og skaperkraften i oss alle. Foredraget bruker mye av matrialet fra boken: "Drawing on the right side of the brain", som er en klassiker innen kreative yrker. Hvordan fungerer vår hjerne, og hvordan fungerer den ikke? Hva skjer når hjernen vår ser et symbol i en arkitektur-tegning. Når kommer eureka øyeblikkene, og hvorfor kommer de da? Og hva kan vi lære av dette når vi skal skrive dokumenter og figurer om software? Dette er et foredrag med et stort glimt i øyet, som alle som har vært i nærheten av et utviklingsprosjekt vil få mye ut av.
Vi som skriver kode, må ofte forklare hvordan noe fungerer. Vi må forklare det til andre som skriver kode, samt alle andre som trenger å vite hvordan løsningen vår fungerer. Av og til må jeg også "forklare løsningen" til meg selv! Da holder ikke alltid kode. Heller ikke prosatekst dekker våre behov for kommunikasjon. Vi må tegne "kode". Men hjelper det da med formelle systemer som UML? I dette foredraget ser vi på hvorfor vi må tenke utenfor formell notasjon, og hvorfor vi har havnet i et uføre der formell notasjon er det vi kan.

Let's get a handle on what your JVM is doing using system tools as well as JDK tools like jps, jstack, Mission Control and Flight Recoder. Using real world examples we try to get a handle on common development mistakes and performance problems.
Java is continuously evolving and each release brings new features. For sure you heard about Lambdas for Java 8, right? Who hasn’t? Unfortunately, despite all new language features developers still often struggle with performance issues and memory leaks. How do you go about solving these problems? Luckily, Java tooling support is evolving as well, but much more hidden for many. When was the last time you looked into the bin directory of your JDK? Ever heard of tools like jps, jstack or jmap? What’s about Mission Control and Flight Recoder? Java provides everything you need to track down performance and memory problems. No need for expensive 3rd party tools. In this session we are having a closer look at the above mentioned tools, in particular Mission Control. Where do I find them, how do I start them and how can they be used to solve my problems? To keep things real, we will use real world examples from projects like Hibernate Validator and Search. Buckle up and get learn how to get back into control of your JVM.

GUI-programmering i Swing er pyton! Nå som JavaFX er kommet på banen, er det mulig å omvende en innbitt Swing-hater til å faktisk like å lage brukergrensesnitt?
Hater du å programmere GUI? Vil du heller kutte av din høyre arm fremfor å fikle med foreldede Swing-komponenter? I såfall er du i godt selskap med foredragsholderen, som har skydd gui-programmering som pesten. Men er det håp for bedring når Swing snart er historie og JavaFX tar over? Foredragsholderen har testet ut JavaFX i et hobbyprosjekt, og deler av sine erfaringer fra en gui-haters synspunkt.

Moderne applikasjoner har høye krav til både ytelse, skalerbarhet og responstid. Vi har stort sett mange prosessorer til rådighet, men hvordan utnytte dem på best mulig måte? Hvordan kan en oppgave parallelliseres? Hvordan behandle mange oppgaver samtidig? Hva med skalering ved økende/varierende trafikk?
Eivind viser grunnmekanismene i JVM'en for trådhåndtering og parallellisering, og hvordan moderne rammeverk som Akka og RxJava kan tilføre enda bedre kontroll. Vi går gjennom en del typiske fallgruver og viser hvordan disse kan unngåes og hva man bør være ekstra oppmerksom på. Det hele bygges i stor grad rundt eksempler fra ekte prosjekter. Eksemplene er hentet fra moderniseringen av Skatteetaten sine datasystemer, hvor Eivind har jobbet de siste 3 årene.

Lessons learnt using web APIs and composable services to build a database server and its testing infrastructure.
In the mid-2000s I was using the web as a platform for building and integrating enterprise apps. This led to my co-authoring 'REST in Practice', a guide to applying web technologies and the tenets of REST in the enterprise. Then, in 2011, I joined a database company - a graph database company. Here, we applied the ideas that inspired 'REST in Practice' to a quite different set of architectural problems. In this session I'll discuss some the things I've learnt in applying 'REST in Practice' in a new context: implementing a database server API, and building the infrastructure we use for testing clusters, bootstrapping proofs-of-concept, reproducing customer scenarios, and benchmarking the database. My experience has reinforced many of the core precepts of the book, but it has also led me to qualify and revise others - and even, in some cases, to consider alternative web-based approaches.

Monolittiske systemer er vanskelige å endre, tidkrevende å lære, skalerer dårlig, og får byggesystemet til å svette. Likevel er monolittiske arkitekturer de mest populære. Vi lager nye monolitter hele tiden, selv om vi kanskje i utgangspunktet prøver å la være. Hvordan kan vi slutte før vi får vondt i magen?
Motstykket til monolitter er modulære arkitekturer, hvor mindre, selvstendige, funksjonelle moduler bygger på hverandre gjennom veldefinerte grensesnitt, og hvor hver modul utvikles, testes, og forvaltes for seg av ulike team. Dette foredraget er historien om første etappe av to prosjekter som søker å modularisere hvert sitt monolittiske system, en heftig web applikasjon og et massivt baksystem. Begge skrevet i Java. Det ene 10 år gammelt, det andre 20 år ungt. Som så mange monolitter så ble ingen av de to systemene designet for å være monolitter, men har derimot utviklet seg til å bli det over tid. Vi vil fortelle om vår motivasjon for å modularisere monolittene, hva vi har lært i arbeidet med å (re-) definere hva som skal være egne moduler, hvordan vi har gått frem for å trekke kildekoden fra hverandre, hvilken tilnærming vi har brukt i grensesnittdesignet, samt hvilke tanker vi har gjort oss rundt forvaltningen av modulene i etterkant. Foredraget vil inneholde referanser til relevant forskningsarbeid og reelle eksempler.

Hafslund is developing a service for managing and controlling smart homes built on Scala and Akka. A gateway in the users' homes runs embedded Linux with a lightweight Akka application collecting data from sensors and sending commands to devices to control the home. Another Akka system in the cloud gathers data and enables users to manage their home via a phone app.
This session will cover Hafslund's 18 months experience developing the Akka-based real-time system handling millions of events per second, the way we've applied the various items in the Akka toolbox, strengths and weaknesses we've come across and our overall impressions so far. While the type of system we're developing has felt like a sweet spot for Akka all the way, we've hit a number of stumbling blocks - probably common ones - which I'll talk through and examine the architectural decisions we've made to work around them.

Salesforce1 plattformen er en "multitenant cloud service" (forbrukermodelltjeneste?) som blir stadig mer aktuell her i Norge. Men hva er egentlig multitenancy, hvordan håndterer de over en milliard transaksjoner om dagen og ligger faktisk alle kundenes data i den samme databasen?
Målet med lyntalen er å gi en innføring i hvordan Salesforce ser ut "under panseret". Lyntalen gi en innføring i begrepet multitenancy før den vinkler over på hvordan Salesforce ser ut i forhold til en tradisjonell applikasjonsserver. Videre går man over på strategien for skalering hvor Salesforce har valgt bort virtualisering og heller lagt opp arkitekturen sin til å være optimalisert for skalering i skyen. Vi går så inn på hvoran metadata arkitekturen ser ut og hvordan relasjonsdatabasen til salesforce ser ut og hvordan man lar Salesforce, brukeren og tredjeparts leverandører jobbe og oppdatere det samme systemet uten nedetid.

Modularity is an architectural theme that you'll hear about more and more. Being able to deal with change in a codebase is not something trivial and requires some serious thought. In this talk I will show you that it is actually pretty easy to achieve a modular architecture using OSGi, and the right set of tools. Of course everything will be demonstrated using live coding!
In this presentation you will learn how to create modular, robust, and durable enterprise Java applications fit for the Cloud Age. Using a modular development approach with Java, OSGi, and a wealth of open source components, you will be shown how to combine these into coherent applications without locking into one of the existing PaaS providers. Finally, we will focus on deployment, introducing Apache ACE, that allows to centrally manage and distribute software components to target systems in the cloud or on premise. The presenter of this talk authored the book 'Building Modular Cloud Apps with OSGi' and is using these techniques in high profile production applications on a daily basis.

Du vet ikke hva nettsiden din er lastet med hvis den blir utsatt for XSS-scripting eller datainjeksjoner. Vi vil gi deg en kjapp introduksjon og how-to til bruk av CSP, et regelsett som kan redde deg fra hacker-angrep og sikre lasten din.
Har du sikret nettsiden din i dag? Hvis ikke, kan du fortsatt rekke det før dagen er omme. CSP er et enkelt regelsett som lar deg definere hvor du får lov til å hente ressurser fra, og som derfor gjør webapplikasjonen din flere hakk sikrere. Vi leder deg trygt gjennom noen av webverdenens farer med veldefinerte regler, og viser deg hvordan du kan sikre nettsiden din på 10 minutter. Og sove bedre om natten.

Med MAG- og EDAG-prosjektene har Skatteetaten etablert en mikrotjenestearkitektur. Som en forutsetning for kontinuerlig leveranse skal tjenester kunne utvikles, testes, rulles ut, forvaltes og driftes uavhengig av hverandre. Denne sesjonen presenterer løsninger og problemstillinger i en mikrotjenestearkitektur, som tjenesteregistrering og -oppslag, API-utforming og bakoverkompabilitet, robusthet, skalerbarhet og driftsovervåkning.
Skatteetaten er i en prosess der de ser på hvordan de kan senke forvaltningskostnadene, øke endringsevnen i systemporteføljen, og bygge systemer som i større grad vil svare på fremtidige utfordringer. De har etablert et arkitekturmålbilde som legger stor vekt på skalerbarhet, testbarhet, vedlikeholdbarhet, driftbarhet og automatisering. “Modernisering av grunnlagsdata (MAG)”- og “Elektronisk dialog med arbeidsgivere (EDAG)”-prosjektene realiserer deler av målbildet. Hør om erfaringer fra disse prosjektene med fokus på automatisert utrulling, miljøer og versjonering, konfigurasjon og koordingering mellom tjenester, overvåkning og verktøy for drift og administrasjon. Vi ser på hva som fungerer, hva som fortsatt skaper friksjon og aktuelle alternativer som kan forbedre de utfordringene vi står ovenfor.

DRY er viktig, men vanskelig når du må kombinere JavaScript og Java i Maven-baserte prosjekter. Hør hvordan du gjør det med Maven WebJars.
Ofte har man lyst til å bruke JavaScript over hele fjøla, men er tvunget til å holde seg til et statlig prosjekts tunge arkitekturkrav om å bruke Maven og pakke alt i en jar-fil. Da blir det ofte copy/paste av JavaScript-kode mellom forskjellige moduler, istedenfor at man holder seg til DRY-prinsippene. Med Maven WebJars kan man på en enkel måte pakke ned felles JavaScript som er modularisert med require.js i en jar-fil og gjenbruke mellom prosjekter.

This 2 hour workshop will teach you how to build a mobile native application for iOS, Android and other platforms in Java by leveraging the Codename One platform and API. During the course of this workshop we will actually build a working usable application that uses device functionality and deploy it to your devices!
This workshop will start with a brief overview of what Codename One is and isn't which should be quick and familiar to Java developers. It will then delve into the process of building an application with Codename One highlighting device feature usage such as camera API's, location etc. The highlight of the workshop is the deployment to actual devices, this is a tricky bit due to Apples restrictions on device deployment.

Concurrency has become an increasingly important topic in the Java space. Nevertheless, most Java developers do not address concurrency in their unit tests. This talk shows how to and how not to test concurrent code and introduces Thread Weaver, a library for testing concurrent code.
While software engineers can disagree on almost any concept of programming best-practice, the necessity of writing unit tests remains undisputed. With the advent of concurrent applications and the ongoing deprecation of the one-thread-per-request model, unit tests do however miss an increasing fraction of programing errors such as race conditions or dead-locking code. But is it even possible to write tests that revise such errors? In the end, a good unit test is characterized by a determined execution path what effectively prevents the use of concurrency within a single test. However, there are tools and programming principles that allow for unit tests of concurrent code. This talk reviews typical mistakes made when concurrent code is tested and introduces Thread Weaver, a test suite for writing valid unit tests that uncover concurrency-related programming errors.

In recent years functional programming has gained ground over object oriented mainly due to the advancement in computing power. The JVM is no exception, you can find powerful contenders in Clojure and Scala. However Groovy doesn't stay behind. The Groovy programming language contains a wide array of APIs and features that facilitate a functional programming style, such as closure composition, memoization, trampolines, iterator methods and more. We'll explore all of these features that are sure to spice up your daily experience.
In recent years functional programming has gained ground over object oriented mainly due to the advancement in computing power. The JVM is no exception, you can find powerful contenders in Clojure and Scala. However Groovy doesn't stay behind. The Groovy programming language contains a wide array of APIs and features that facilitate a functional programming style, such as closure composition, memoization, trampolines, iterator methods and more. We'll explore all of these features that are sure to spice up your daily experience. We'll also discover how JDK8's new functional capabilities can be used alongside Groovy.

H2O - It's open source, in-memory, big data, clustered computing - Math At Scale. We got the Worlds Fastest Logistic Regression (by a lot!), world's first (and fastest) distributed Gradient Boosted Method (GBM), plus Random Forest, PCA, KMeans++, etc... R's "plyr" style data munging at-scale, including ddply (Group-By for you SQL'rs) and much of R's expressive coding style.
We built H2O, an open-source platform for working with in-memory distributed data. Then we built on top of H2O state-of-the-art predictive modeling and analytics (e.g. GLM & Logistic Regression, GBM, Random Forest, Neural Nets, PCA to name a few) that's 1000x faster than the disk-bound alternatives, and 100x faster than R (we love R but it's tooo slow on big data!). We can run R expressions on tera-scale datasets, or munge data from Scala & Python. We're building our newest algorithms in a few weeks, start to finish, because the platform makes Big Math easy. We routinely test on 100G datasets, have customers using 1T datasets. This talk is about the platform, coding style & API that lets us seamlessly deal with datasets from 1K to 1TB without changing a line of code, lets us use clusters ranging from your laptop to 100 server clusters with many many TB of ram and hundreds of CPUs.

In the past year the Arduino micro controller has become a hot topic amongst developers in Norway but it has existed for quite a few years. These are great boards for playing with and writing code to control physical things but is it really possible to use one of these for something in real life?
In the past 3 years Motorbike racing has taken a big step into the world of electronics which comes at a huge cost to the teams / riders if they want to buy and use some of these electronics. I race motorbikes in the UK and around Scandinavia and for the 2013 season I decided it was possible to make my own data logging system for my race bike using an Arduino & Raspberry PI. In this talk I will cover the highs and lows of trying to do such a thing, giving you details of what you can do at home to get a similar results. Its worth watching my introduction lightning talk from last year - http://vimeo.com/74300430

Har du noen gang vært redd for å gjøre massive omskrivninger av koden din for å øke lesbarhet? Har du noen gang vært nervøs ved bytte av server, versjoner etc? Automatisert regresjonstest er din reddende engel!
Hva gjør man når: ...det er særdeles høye krav til kvalitet og regresjonsfeil er utelukket? ...man må endre en applikasjon med nærmest ingen testdekning? ...når tester kun dekker den delen av programmet som er endret, men ikke annen funksjonalitet? Vi har utviklet en fri programvareløsning for automatisert blackboxtesting. Denne pakken hjelper deg med å fange input og output fra systemet ditt i produksjon, og deretter bruke denne inputen og outputen som henholdsvis testinput og testfasit. Det er støtte for å ta opp og spille av databaseendringer, HTTP-kall og servicekall i Java. Gjennom automatisering blir blackbox regresjonstest en god løsning for de fleste systemer. I dette foredraget vil vi presentere en komplett løsning for fullautomatisert regresjonstest. Vi ser hvordan man kan unngå tidkrevende fallgruver som det å vedlikeholde en testgrunnlagsdatabase, manglende systemgrenser, batchmareritt og løsninger med sveiv. Vi forklarer løsning i dybden, med utfordringer vi møtte på underveis slik som CSRF-beskyttelse og andre kompliserende faktorer.

Lyntalen gir et innblikk i arkitektrollen, og hvordan man kan gå frem for å bli arkitekt i et team. Målet er at du også får økt bevissthet på din rolle i ditt nåværende og fremtidige prosjekt.
Høsten 2010 fikk jeg for første gang rollen arkitekt i et prosjekt, og jeg hadde da mine ideer om hva det innebar å være arkitekt. Etter fire år i rollen har disse forestillingene blitt ganske kraftig endret. Kom og hør når jeg forteller om min reise mot arkitektrollen, mine tanker om hva det innebærer å være arkitekt i et prosjekt, hva som har vært og er vanskelig, og alt jeg har fått ut av reisen.

All theory regarding consensus algorithms refer to the Paxos algorithm. The original paper describing Paxos have been very influential, but many describe it as hard to comprehend and many of those who don't have failed at trying to implement it.
In this talk I will try to give a more easily comprehensible description as I tell the tale of the mythical greek island called Paxos. On the Paxos island legislators passed laws by passing notes using unreliable couriers and at the same time leaving and returning to the senate whenever they felt like it. The incredible thing is that they still managed to consensus on their ledgers of all the laws that had been passed.

Nysgjerrig på app-utvikling for Chromecast? Start her.
Chromecast er en dings fra Google som du kobler til HDMI-inngangen til tv-en, og som lar deg streame filmer og musikk fra f.eks YouTube og Netflix. Heldigvis har Google gjort Chromecast API-et åpent for utvikling av tredjeparts-apper, noe som åpner for artige muligheter. Dette lynforedraget gir deg en oversikt over arkitekturen i Chromecast, hvilke begreper som brukes, retningslinjer for UX, ninjatriks for testing og debugging, en kjapp titt på API-ene, og ikke minst hvilke begrensninger plattformen har. Foredragsholderen har implementert casting av musikk og film i streaming-tjenesten Subsonic (subsonic.org) og vil vise noen eksempler fra det.

PostgreSQL har noen egenskaper som gjør den til en halvblods MQ som få er klar over. Denne lyntalen viser raskt hva mulighetene og begrensningene er og hvordan vi har brukt PostgreSQL som MQ i fiken.no.
1) En rask oversikt over tilstanden en kobling til en postgresql-server kan være i 2) Hva som kreves på JDBC-siden 3) Viser de utility-klassene som vi har brukt i Fiken.no for å bruke postgresql som en måte å få til push mellom applikasjoner, samtidig som man plukker opp meldinger som feiler via bakgrunnsjobber. Eksemplene vil gå fra frontend med AngularJS tilbake til backend og tilbake til en annen frontend hvor man oppnår det man pleide å tro at man trengte ActiveMQ eller tilsvarende til for å oppnå.

We used to have a simple, declarative web. Then we got fancy and everything has gone crazy. The Polymer project is an attempt to use W3C standards to reclaim the simple, declarative Web while still allowing us our modern whizzy UIs.
Enough with the darn JavaScript frameworks already! There's nothing wrong with a judicious use of this ubiquitous programming language, but it's gotten a little out of hand. What if there were an evolvable future state of declarative and encapsulated user interface elements that was available today in most modern browsers? There is! The Polymer Project is a young but impressive glimpse into where things should go. It's goals are: - Use the platform - Everything is an element - Eliminate boilerplate This talk will introduce you to: - The Polymer Project - The strategy for supporting today's browsers with tomorrow's technologies - Application frameworks that build upon these core technologies - Custom visual and non-visual elements - The underlying W3C Specifications that engender all of this

Hva betyr AES_128_CBC, hva er forskjellen mellom ECDH og ECDHE, hvor lang bør en nøkkel være og hvilken versjon av TLS er riktig å bruke?
Det siste året har det blitt tydelig for alle at integritet og konfidensialitet er viktig når man kommuniserer på internett, En velkjent teknikk for å få til dette er å bruke TLS, Transport Layer Security (tidligere kjent som SSL, Secure Sockets Layer). TLS kan brukes for å legge til kryptering, integritetssjekk og PKI-basert autentisering på eksisterende nettverksprotokoller uten endre disse, og gir derfor en enkel måte å sikre eksisterende infrastruktur på. Den mest kjente anvendelsen av TLS er selvsagt HTTPS, som er HTTP gjennom en kryptert TLS-kanal. Men for å sette opp TLS er det en lang rekke konfigurasjonsvalg man må ta stilling til; versjon, nøkkellengder, utvidelser samt protokoller for nøkkelutveksling, autentisering, kryptering og meldingsvalidering. Da Yahoo, som den siste av de store tjenesteleverandørene på internett innførte TLS som standard høsten 2013 ble dette ikke gjort i henhold til gjeldende beste praksis. Når de store bommer på dette er det en indikasjon på hvor vanskelig det er å gjøre dette riktig. Denne presentasjonen vil gå gjennom hva TLS består av, hva som er anbefalt beste praksis for oppsett og hvorfor det, samt hva man ikke bør bruke. Fokus vil være på TLS isolert, uavhengig av hvilke protokoller man legger oppå, men det blir også vist eksempelkode i java og tips for konfigurasjon av vanlige web- og applikasjonsservere.

Ved hjelp av 11 matematiske problemer som er enkle å forstå og som tilsynelatende har åpenbare løsninger, skal vi demonstrere at det ofte kan være lurt å stoppe opp og tenke seg om før man hopper på den mest innlysende løsningen.
Verden er ikke alltid som den fremstår, noe vi stadig får erfare. Kravene var ikke slik vi trodde, programmet vår gjør ikke akkurat slik vi tenkte. Vi går gjennom noen matematiske problemer som er enkle å forstå og som man intuitivt har en oppfattelse av løsningen på. Ved å gå gjennom løsningene og demonstrere hvordan man kommer frem til dem, og peke på hvor intuisjonen går feil, skal vi forhåpentligvis klatre litt nærmere kanten på den berømmelige boksen. Der det passer seg, kommer vi til å gå gjennom litt kode som demonstrerer løsningene, eller som demonstrerer fallgrubene. I noen tilfeller skal vi se raskt på hvordan lærdommen vi får fra matematikken kan påvirke kode vi skriver, og vi kommer til å se at dersom man ikke oppfatter kravspesifikasjonen riktig, blir resultatet feil.

Er du lei av å google de samme kommandoene hver gang du skal sette opp et miljø? Lei av at TEST ikke er likt PROD? Mangler du god dokumentasjon av miljøene dine? Provisjonering lar deg automatisere en reproduserbar konfigurasjon, og det trenger ikke være vanskelig. Vi viser deg hvordan du kommer veldig enkelt i gang med provisjonering ved hjelp av verktøyet Ansible.
Vi skal se på hvordan du kan skrive infrastrukturen din som kode, ved hjelp av Ansible. Ansible følger en litt annerledes filosofi enn mer konvensjonelle provisjoneringsrammeverk som f.eks. Puppet. Det krever minimalt med boilerplate, og omtrent ingen eksisterende infrastruktur. Vi skal se på noen helt konkrete eksempler på hva man kan bruke det til, og vise et minimalt eksempel samt teknikker for å håndtere gjenbruk når en større infrastruktur skal provisjoneres.

Do unit tests make life better? Should we develop using test driven development (TDD)? What exactly are our customers paying for? These questions, and others, will be answered definitively in this session.
Software development is hard. Unit testing and Test Driven Development (TDD) can make it easier, but only if done well - and that takes time. In this session we will cover: - HOW these practices can help your project, - WHAT you can do to get better at them, and - WHY your boss should care. You’ll learn about project risk and how developer testing can improve the chances of a successful delivery. You’ll see how developer tests don’t just protect against regression, but also act as a primary source of documentation. And we’ll take a few hints from the ancient Egyptians! You might have heard people say: - “Tests make it hard to refactor.” - “The customer doesn’t care how many tests there are.” - “If we had to work the way the agile gurus tell us, nothing would ever get done.” If you’ve ever struggled to respond to these challenges, then this session is for you. A note about the title: In Douglas Adams’ Hitchhiker’s Guide To The Galaxy the dolphins leave planet earth before it gets destroyed, with their last enigmatic message “So long, and thanks for all the fish” being misinterpreted. Is our software giving us the same message? After all, the software would still perform the same function without the tests, wouldn’t it?

In the presentation the topic database migration will be introduced as well as advanced concepts based on real life experience, a few tips and tricks and demonstrations on stage. The talk will focus on the two most popular Open Source frameworks, Liquibase and Flyway, and their role in a Java EE setup.
Schema migration (also database migration, database change management) refers to the management of incremental, reversible changes to relational database schemas. A schema migration is performed on a database whenever it is necessary to update or revert that database's schema to some newer or older version[1] In the presentation the topic will be introduced as well as advanced concepts based on real life experience, a few tips and tricks and demonstrations on stage. The talk will focus on the two most popular Open Source frameworks, Liquibase and Flyway, and their role in a Java EE setup. [1] http://en.wikipedia.org/wiki/Schema_migration

Do you wonder how the "log in with Facebook"-option in many applications work? Open authentication 2.0 is an open standard that is implemented (with a few variations) in a number of platforms. It allows you to create a secure application without dealing with passwords and it enables ecosystems of cooperating applications. If you want to simplify the login for your users, use third party APIs or provide a flexible security framework for your internal application ecosystem, this talk will show you how.
We will show a simple example of an application that authenticates with OAuth 2.0 with a number of providers and break down the application flow. The flow of OAuth 2.0 is very simple and provides many benefits. The talk will cover what you need to understand in order to use or build an OAuth provider.

This talk covers some concrete, practical advice for people building, or considering building, microservice arcitectures.
So you’ve heard about the buzz behind Microservices and finer-grained architectures in general? Microservice architectures can lead to easier to change, more maintainable systems which can be more secure, performant and stable than previous designs. But what are the practical concerns associated with running more fine-grained systems, and what are the new things you’ll need to know if you want to embrace the power of smaller services without the new sources of complexity making your life a nightmare? This talk will delve deeper into the characteristics of well-behaved services, and will define some clear principles your services should follow. It will also discuss in more depth some of the challenges associated with managing and monitoring more complex distributed systems. We’ll discuss how you can design services to be more fault-tolerant, what technologies may exist in your own platform to get you started. We’ll end by giving some pointers as to when you should consider microservice architectures, and how you should go about introducing them in your own organisation. This talk gives practical advice to help you adopt Microservice architectures in your own organisations, based on real-world experience of building similar systems gathered from all over the industry.

Java 8 introduces a new Stream concept for iterating over structures. In what way is this different from traditional iterator based iteration? In what situations can you benefit from using Stream? When is it not possible? Finally, we will look at how to Stream enable your own data.
Java 8 has adopted a new paradigm for iteration, inspired by recent trends and other languages. Traditionally Java iteration has been iterator based. Iterators are complex to write and have many inherent limitations. With the new Stream abstraction, the iteration is no longer driven by the consumer, so the implementor has greater freedom to implement and optimise. The interface also includes new and valuable functionality at your fingertips. The default Stream support in Java 8, is however still based on iterators. Therefore as a final exercise, we will look at ways to Stream enable code, without the burden of an iterator. This is the final step to make your iteration truly internal.

En workshop hvor du kommer raskt i gang med å lage din første AngularJS applikasjon. Vi viser litt teori, men hovedvekten vil være på praktiske øvelser. På slutten vil vi dele noen praktiske erfaringer fra en stor AngularJS applikasjon vi har laget (https://fiken.no). Vi vil også fortelle litt om hva som kommer i fremtiden for Angular.
Mer spesifikt vil vi gå igjennom: * Oppsett av en Angular-side/prosjekt * Dependency injection * Templates / Expressions * Filters * Directives * Routing

Macros are a core part of Clojure, probably its most powerful feature. To fully understand Clojure you need to understand macros. In this talk we will do a deep dive into Clojure's macro system.
Clojure is arguably one of the most powerful languages on the JVM, and it is gaining in popularity. But to really understand its power, we need to take a deeper look into one of its core features. In this talk, we will do a deep dive into Clojure’s macro system, understanding how it works, when to use macros, and when not to use them. Getting into macros, means understanding the reader, the compiler and the runtime. Hence understanding macros, means really understanding Clojure. After this talk you should have a better perception on how this wonderful language actually works!

Groupon recently completed a year-long project to migrate its web traffic from a monolithic Ruby on Rails application to a new multi-application stack with substantial results. Learn the strategies, techniques, and tools used to accomplish this!
Groupon recently completed a year-long project to migrate its U.S. web traffic from a monolithic Ruby on Rails application to a new multi-application stack with substantial results. Groupon's entire U.S. web frontend had been a single Rails codebase from its inception in 2008. The frontend codebase quickly grew large, which made it difficult to maintain and challenging to ship new features. As a solution to this gigantic monolith, we decided to re-architect the frontend by splitting it into small, independent and more manageable pieces which we integrated into a cohesive whole. At the center of this project, we rebuilt each major section of the website as an independent application. We also rebuilt the infrastructure to make all the independent apps work together. Interaction Tier (I-Tier) was the result. Learn the strategies, techniques, and tools used to peel apart a monolithic application, and then integrate dozens of smaller applications into a cohesive, faster to run, faster to evolve, and easier to maintain whole!

Erfaringsrapport om da prosjektet jeg var på "plutselig" gikk over til å bruke Scala. Om opplevelsen av overgangen til både nytt språk og ny måte å tenke på fra ståstedet til noen som ikke var involvert i innføringen av det nye.
Jeg sitter intetanende og konfer java enterprise og xml-til-xml transformeringer. Livet er greit om enn noe grått, litt trist og litt frustrerende. Men, alt er bare litt og ikke mye og ikke voldsomt. Plutselig skal alt gjøres i Scala da ildsjelene™ har klart å drive det inn både i prosjektet internt og hos kunden. Dette blir en lyntale om overgangen til en helt ny måte å tenke på, fra imperativ til funksjonelt. Ja, det pakkes ofte inn i at Scala kjører på JVM og det er fine broer over til Java hvis man trenger det (ikke bli redd), og det er ikke SÅ forskjellig - MEN det det egentlig handler om når du sitter der, er at hele din vanlige måte å tenke på faktisk blir snudd på hodet. Dette blir en talk som inneholder personlige WTFs og brain-pains rundt denne overgang. Det handler også om hvordan man håndterer endringer som ikke er initiert av deg selv, rent psykologisk. Og, det blir svar på spørsmålet - hvordan er livet nå, fremdels bare litt vanlig trist?

Lei av å jobbe med store monolittiske systemer? Det har den siste tiden vært mye hype rundt begrepet Micro Service Arkitektur (MSA). ThoughtWorks har plassert dette på sin teknologiradar under "trial", og Martin Fowler blogger om begrepet. Denne lyntalen vil gi deg en kort introduksjon til MSA og vil vise hvilke muligheter dette gir i forhold til en monolittisk arkitektur.
Inspirert av flere foredrag på fjorårets JavaZone bestemte vi oss for å teste ut denne arkitekturstilen på et prosjekt hos Forsvaret. I denne lyntalen vil jeg vise hvilke verktøy/teknologier vi har brukt for å få til MSA i praksis. Jeg vil også peke på andre relevante verktøy som finnes, og forklare hvilken påvirkning en slik arkitektur får på utvikling, drift og overvåkning. Til slutt vil jeg dele erfaringene vi har gjort oss og gi tips til hvordan du kan komme i gang med Micro Services i ditt neste prosjekt. Er dette en ny Silver Bullet? Bør du kaste deg på hypen og velge MSA i ditt neste prosjekt? Lyntalen avsluttes med en oppsummering av fordeler og ulemper med MSA.

According to many researches, we learn the best when we experience it personally, and we comprehend when we teach to someone else. So if you want to achieve ample understanding of a topic, you’ll need to follow these basic steps: “Listen -&gt; Observe -&gt; Do -&gt; Share” Fibonacci Pairing is simple yet very effective technique that can improve team work.
Pair-programming is a well-known practice, and it has been introduced by one of the thought leaders of Agile world, Kent Beck. I respect any technique that encourages collaboration and interaction among teams, and gets teams to communicate better. However, if you want to establish understanding of mastery or a skill-set, and increase the shared knowledge across your team members, then you need to re-think & apply new techniques. In this talk, I’ll share about What-Why-How of "Fibonacci Pairing" technique, which is yet another discovery from practice. The main goal of that technique is to establish understanding and improve collaboration, without overcrowding by artificial ways like lecturing. This technique should be regarded as a complementary way to improve team work effectively. We will elaborate with practical examples, real life experiences, and applicable ways onto different contexts.

Interpolation is the act of filling in the blanks between to discrete states. This can be as simple as moving a dot from one part of the screen to another, changing a color from red to blue - or displaying the balance of your bank-account draining away till nothing remains. This will be a peek at the math of interpolation - the in-between of theory and application.
Today interpolation and tweening is readily available in various libraries; animating DOM elements on the web has for many become second nature curtsy of jQuery and others. This talk tries to talk one step back and take a look at the (relatively simple) math behind interpolation. A walkthrough of how a basic mathematical formula can be adapted to provide a vast range dynamic animations, which can be applied to an array of front-end attributes; position, size, color and rotation. Inspired by Flash animator Robert Penner, the presentation seeks to use the very concepts of the talk as a visual aid to illustrate the topic at hand, in what is hopefully a visually interesting ride from A to B - and in-between.

I følge fossefallsmetodikken skal man gjøre mye planlegging og detaljering i forkant av en konstruksjonsfase, mens man i en smidig setting ikke gjøre den samme detaljeringen men heller avklarer og detaljerer ting undervis. Så hvor mye arkitekturarbeid bør man da gjøre i forkant?
Når har man gjort nok arkitekturarbeid og kan begynne å skrive kode? Skal man gjøre som i de gode gamle fossefallsdager og detaljere arkitektur og design komplett før man starter utvikling, eller skal man ikke gjøre noe arkitekturarbeid i forkant av utvikling og heller la arkitekturen dannes gjennom testdrevet utvikling? Satt på spissen er selvfølgelig svaret at ingen av disse ytterkantene er den beste måten å gjøre det på. Lyntalen vil se på hvordan man kan lage "akkurat sånn passe mye arkitektur" og hvordan man vet når man har gjort "sånn passe mye arkitektur".

BIG-IP benyttes som blant annet for implementere høy tilgjengelighet, lastbalansering og web-cache. BIG-IP er i bruk hos mange av de store driftsleverandørene og også hos aktører med større interne driftsmiljø. Likevel ses den ofte på som svart magi av mange utviklere og arkitekter. Applikasjonsutviklere og arkitekter er nødt til å ta mer kontroll over infrastrukturkomponenter som BIG-IP for å lage sikre og stabile løsninger. Dette foredraget tar sikte på å gi en introduksjon til BIG-IP for applikasjonsutviklere og arkitekter. Men utgangspunkt i applikasjonsutvikling og forvaltning vil det bli vist hva man bør ha kontroll på, hvilke konfigurasjoner man bør vurdere og hvilke feil man bør unngå.
Oppsett og endringer av lastbalanserer og andre komponenter for høy tilgjengelighet gjøres ofte kun som bestillinger til drift med liten eller ingen kontroll fra de som utvikler og forvalter applikasjonene. Bestillinger beskrives gjerne i lite konkrete vendinger og er ofte vanskelig for applikasjonsutviklere og arkitekter å bekrefte. Samtidig er det lite kjennskap blant applikasjonsutviklere hva BIG-IP kan gjøre, hva den bør og ikke bør gjøre og hvordan denne svarte magiske boksen virker. Konsekvensen er derfor ofte større eller mindre feil i BIG-IP oppsettet som kan gi varierende konsekvenser for applikasjonene. Utfordringer med BIG-IP er både relatert til nyutvikling og forvaltning, både av applikasjoner og CMS løsninger. Dette foredraget vil forsøke å gi en introduksjon til de viktigste og mest brukte konseptene i BIG-IP. Vi vil se på hvordan man typisk setter opp en applikasjon i BIG-IP. Tema som vil berøres er lastbalansering og lastbalanseringsalgoritmer, monitorering, regler (irules) og tilhørende testing, web-cache og ytelsestesting. Foredraget er i hovedsak basert på erfaringer fra virkeligheten og tar utgangspunkt i reelle problemer. Mange av momentene som tas opp vil også være overførbare til andre lasbalanserere og proxy-komponenter, men det tas utgangspunkt i BIG-IP.

I denne lyntalen vil du lære om kontekst i javascript, altså verdien av nøkkelordet "this" samt hvordan vi kan styre denne med javascripts egne funksjoninvokeringsmekanismer.
Kontekst i JavaScript er rare greier. *this* er aldri det du tror den skal være, og det later heller ikke til å være noen logikk å spore. I dagens rammeverkbonanza i javascriptverden er det ikke blitt noe lettere, ettersom mange av disse rammeverkene går i vei og setter mer eller mindre fornuftige kontekstverdier for deg rundt omkring i applikasjonen. Hvordan dette fungerer er en av tingene man bare er nødt til å lære seg dersom man skal beherske JavaScript. I denne lyntalen skal vi oppklare mysteriet ved å gå gjennom reglene for defaultverdiene av this, samt vise hvordan vi kan selv sette kontekst ved funksjonsinvokering gjennom call, apply og bind.

En kjapp introduksjon til Web Components. Der jeg vi går igjennom de forskjellige delene som trengs for å bygge egne komponenter og demonstrerer noen komponenter som allerede er laget.
Som utviklere hopper vi mellom utallige frontend-rammeverk, og må gjerne lære oss et nytt rammeverk for hvert eneste nye prosjekt vi begynner på. Dette er både tidkrevende og en smule irriterende. Hadde det ikke vært deilig med en standard? Jo, og det synes også folkene bak HTML også. Web Components ligger i standardiseringsløpet, og er snart klart til bruk. Med litt polyfill kan vi begynne å bruke det allerede i dag. I denne lyntalen går vi lynkjapt igjennom, med enkle kodesnutter, hvordan man kommer i gang med å lage egne komponenter, samt å vise noen eksempler på hva Web Components kan brukes til. Web Components er kult!

Interaktiv programmering er en teknikk som gir deg en umiddelbar nærhet til koden din og åpner opp for en ekstremt kort feedbackloop.
Alle vet at programmering er en treg prosess. Du endrer litt kode, bygger, venter. Hvis alt går bra så endrer du litt kode til. Etter hver så blir man vant til den store avstanden mellom koden og hva den faktisk gjør og tenker at dette bare er sånn programmering er. Men det trenger ikke være slik! Tenk om du slapp å simulere i hodet ditt hva hver kodelinje gjorde. Tenk om du kunne se effekten av endringene dine umiddelbart. Målet med presentasjonen er å demonstrere hva interaktiv programmering er, hvilke utfordringer man står overfor og hvordan det fundamentalt forandrer måten du utvikler på.

Skal du drifte et distribuert system er det viktig å enkelt kunne administrere og overvåke applikasjoner på ulike servere. Men alle som har prøvd å benytte JMX MBeans på eksterne maskiner vet hvor utfordrende det kan være. Hawtio and Jolokia to the rescue!
Jolokia er et genialt verktøy som enkelt kan eksponere JMX MBeans som et Web API. Hawtio er et utvidbart HTML5-konsoll som benytter Jolokia for administrasjon og overvåkning av JVM-baserte applikasjoner. Denne lyntalen vil gi en kort introduksjon til Hawtio og Jolokia, og vil vise hvordan du enkelt kan komme i gang med administrasjon og overvåkning av distribuerte applikasjoner. Lyntalen vil vise funksjonalitet gjennom en live demo! Så hvor "hawt" er egentlig dette konsollet? Jeg vil til slutt oppsummere erfaringene vi har gjort oss fra et prosjekt hos Forsvaret.

This lab offers developers an intro-level, hands-on session with Docker, from installation (including boot2docker on Windows/Mac), to exploring Docker Hub, to crafting their own images, to adding Java apps and running custom containers. It will also explain how to use Kubernetes to orchestrate these containers together.
Containers are enabling developers to package their applications (and underlying dependencies) in new ways that are portable and work consistently everywhere? On your machine, in production, in your data center, and in the cloud. And Docker has become the de facto standard for those portable containers in the cloud, whether you’re working with Amazon Web Services, Google Cloud Platform, or Microsoft Azure. Docker is the developer-friendly Linux container technology that enables creation of your stack: OS, JVM, app server, app, and all your custom configuration. So with all it offers, how comfortable are you and your team taking Docker from development to production? Are you hearing developers say, “But it works on my machine!” when code breaks in production? And if you are, how many hours are then spent standing up an accurate test environment to research and fix the bug that caused the problem? This lab offers developers an intro-level, hands-on session with Docker, from installation (including boot2docker on Windows/Mac), to exploring Docker Hub, to crafting their own images, to adding Java apps and running custom containers. It will also explain how to use Kubernetes to orchestrate these containers together. This is a BYOL (bring your own laptop) session, so bring your Windows, OSX, or Linux laptop and be ready to dig into a tool that promises to be at the forefront of our industry for some time to come.

Universell utforming handler ikke om ekstra løsninger for mennesker med funksjonsnedsettelser. Ved å tenke på de som har ekstra utfordringer når vi designer og utvikler nettsider, vil det føre til bedre løsninger for ALLE. Denne presentasjon vil gi informasjon om universell utforming som alle i utviklingsbransjen burde vite om, i tillegg til å vise noen enkle teknikker alle produktfolk, designere og utviklere bør kunne for å gjøre nettsidene bedre for alle.
Akkurat som en trapp er vanskelig å gå for en som bruker rullestol, kan nettsider være vanskelige å lese for en som er svaksynt eller en som er blind. Det finnes trapper med gangvei på tvers, som også er positivt for alle som har barnevogn eller en trillekoffert. På samme måte vil det at vi tar hensyn til en svaksynt som må forstørre en nettside flere hundre prosent, gjøre at vi samler det som hører sammen. For en svaksynt vil det gå fra umulig til mulig å forstå nettsiden, mens det vil for oss andre gå fra litt vanskelig til en mye bedre brukeropplevelse. Det finnes flere teknikker som er lette å gjennomføre, og som vil gjøre at vi finner utfordringer for mennesker med funksjonsnedsettelser. Disse teknikkene hjelper oss å lage bedre nettsider for alle. Presentasjonen vil også vise hva vi har gjort i FINN.no på området, som kanskje kan inspirere andre til å gjøre tilsvarende. Loven for universell utforming er kommet for å bli. I stedet for å tenke på loven som et pålegg, vil denne presentasjonen vise hvordan den heller kan være en inspirasjon til å lage gode nettsider for alle. Vi kan bli eksperter, og snart kommer resten av Europa for å lære!

Vi har alle kjørt `mvn clean install` for å bygge et prosjekt, men har du lurt på hva mer Maven kan gjøre? Hvordan Maven kan hjelpe oss redusere byggetiden eller få bedre kontroll slik at avhengighetene holdes oppdaterte?
Som gode utviklere bør vi kjenne bibliotekene og verkøyene vi bruker. Men når det kommer til byggverktøy ender vi ofte opp med å bruke en eller to kommandoer som vi kjører om og om igjen. Likevel har disse verktøyene ofte flere bruksområder og valgmuligheter som vi ofte ikke kjenner til eller har satt oss så godt inn i. Jeg ønsker i denne lyntalen å gi en kort introduksjon og vise hva mer Maven kan brukes til, med enkle tips som kan gjøre hverdagen litt bedre.

Google Maps, OpenStreetMap og flere andre gir deg muligheten til enkelt å lage kart-funksjonalitet i løsningen din. Samtidig blir du da låst til datasettene, presentasjonen og funksjonaliteten og som er tilgjengelige via disse leverandørene. Denne workshopen vil gå igjennom hvordan du kan lage dine egne kart fra bunnen av og så publisere de på web. Vi vil basere oss på åpne data fra Kartverket og et utvalg gratisverktøy.
Etter det store frislippet av geodata for Norge har man nå mange nye muligheter for å lage egne, spesialtilpassede kart for ulike bruksområder. Denne workshopen vil vise hvordan dette kan gjøres, og dekke hele prosessen trinn for trinn - fra dataimport via grafisk design og fram til et ferdig webgrensesnitt med enkel funksjonalitet. Fokuset i workshopen vil være på enkelhet og å få til en fullstendig gjennomføring, men foredragsholderen vil her og der ta opp relevante problemstillinger i kartografi og GIS-systemer.

Kan man bruke fjellvettreglene når man designer software? Ja. Jeg skal vise hvordan.
I 1967 døde 18 ungdommer i fjellet. Norges Røde Kors og Den norske Turistforening gikk sammen og lagde et enkelt sett med regler. Fjellvettreglene skulle hindre at flere liv gikk tapt på grunn av uvettig oppførsel. Kan de samme reglene hjelpe oss når vi lager software?

A fun exploration of several lessons the craft of filmmaking can teach us about development.
Filmmaking is a deeply technical, collaborative, artistic, high-stakes endeavor. The details of this mysterious craft are unknown to all but an elite few, while the benefits are enjoyed by almost everyone. Sound like a profession you know? In this short talk, we'll explore some stories from filmmaking's past and present and learn from another industry's technological transitions, collaborative patterns, and specialized roles. From synchronized sound to diva directors to dolly grips, this highly scientific art has a lot to teach us about the way we developers are changing the world.

How can you make sure that code which was written some time ago is still readable and can be understood by you and your team? How can you ensure that all developers of a team write high quality code? How can you find bugs in your code before the product is deployed?
This talk will introduce techniques for doing code reviews. Readable, high quality code is essential for the long term success of a project. Code reviews are an enabling factor to write code which can be extended and maintained easily. We will also have a look at some tools which can help with and partially automate code reviews. I will include the personal experiences I have made since starting with code reviews and how to avoid some common pitfalls. The talk will answer the following questions: - How can we start with code reviews? - Who is doing code reviews? - Should we review every line of code? - We are doing TDD, do we need code reviews? - How do I pass knowledge during code review? - Which tools can support the code review process? - How can all team members enjoy code reviews?

Hva skjer hvis man religiøst følger pattern og metodikk? Noen eksempler hvor man burde vært mer pragmatisk.
I forbindelse med programmeringspråk blir det ofte diskutert metodikk og patterns. Hva er den nye rette metodikken? Hvilke patterns erstatter nå gårsdagens antipatterns. Når det kommer noe nytt eller ihvertfall et nytt navn på det, popper det alltid opp en del evangelister som forkynner hvor bra det er. Ideene kan være gode, men går det bra hvis vi følger det med en fanatisk iver? Foredraget tar noe få «highlights» på populære ideer som tatt for langt kan ødelegge applikasjonen din.

Learn about HTTP/2 and its relationship to HTTP 1.1 and SPDY through an open source project from Square called okhttp. Understand how HTTP/2 works at a network level and how things like header compression matter. Leave with a solid understanding of what HTTP/2 buys you and how it impacts how to design HTTP Apis.
Developers choose HTTP for its ubiquity. HTTP’s semantics are cherry-picked or embraced in the myriad of apis we develop and consume. Efficiency discussions are commonplace: Does this design imply N+1 requests? Should we denormalize the model? How do consumers discover changes in state? How many connections are needed to effectively use this api? Meanwhile, HTTP 1.1 is a choice, as opposed to constant. SPDY and HTTP/2 implementations surface, simultaneously retaining semantics and dramatically changing performance implications. We can choose treat these new protocols as more efficient versions HTTP 1.1 or buy into new patterns such as server-side push. This session walks you through these topics via an open source project from Square called okhttp. You’ll understand how okhttp addresses portability so that you can develop against something as familiar as java’s HTTPUrlConnection. We’ll review how to use new protocol features and constraints to keep in mind along the way. You’ll learn how to sandbox ideas with okhttp’s mock server so that you can begin experimenting with SPDY and HTTP/2 today!

Hva ligger i rollen til en teamleder? Hva er det en teamleder bør fokusere på? Hva skiller en god teamleder fra en dårlig?
Teamlederrollen er ofte veldig uklar, og det er heller ikke en rolle man får så mye opplæring i. Jeg har tenkt mye på hva som ligger i denne rollen og kjent litt på kroppen hvilke forventninger som stilles, men likevel ikke uttrykkes. Hva er det minste en teamleder bør prøve å få til? Lyntalen er en oppsummering av hva jeg mener en god teamleder bør gjøre, men ikke minst også hvordan han/hun bør være personlighetsmessig for å best mulig støtte teamet sitt.

Most NoSQL databases use an eventual consistency model for better scalability. This talk explains the CAP theorem, how it relates to eventual consistency, other possible solutions, and also explains how consistency is directly related to Einstein's theory of relativity. Finally, there is a surprise.
The CAP theorem says you have to choose between consistency or availability. In essence, this is the trade-off between having nodes communicate upfront about writes to ensure clients get the same answers from all nodes, or reducing communication at the cost of giving clients inconsistent answers depending on which node they are talking to. SQL databases choose consistency, while NoSQL databases generally choose availability via eventual consistency. This talk explains the theorem and the various approaches to scalability and their benefits and problems. It also explains how this is directly related to the central insight in Einstein's theory of relativity: time is not absolute, or, as it's sometimes phrased, there is no now. Finally, the talk shows how the insight from relativity has been used to scale consistent databases.

With the introduction of the Nashorn JavaScript engine in Java 8, it is possible to run modern (ECMAScript 5.1) JS in the JVM. This allows for reusing existing JavaScript frameworks, or even running Node.js applications within your Java-applications. Are there any compelling reasons for doing this? We’ll show you how easy it is to include JavaScript in your stack, talk about how it differs from Node.js and the browser, and try to pinpoint a few use cases.
Java has had the capability of running JavaScript for some time now, but it’s only with JDK 8 that support for modern JavaScript has caught up. In this talk we will show you some of the things that are possible to do with Nashorn. For instance, you can use JavaScript frameworks that don’t have any Java counterparts, or you can easily open up scripting possibilities within your applications. Another possibility is to handle JSON objects in JavaScript instead of in your Java code, or even share code between the client and the server. Nashorn even allows you to call Java methods from the JavaScript code. In addition Nashorn supports some JavaScript extension that might be worth a look, for instance passing a JavaScript object as a literal to a Java method. To finish off we will take a look at how Nashorn allows you to run multi-threaded JavaScript, and see if there are any pitfalls.

Are you overwhelmed by all the big data and NoSQL buzzwords? Do you feel drowned in the sea of all the new and exotic technologies you hear about everyday? If you are wondering how seriously to take all of this, this session is for you, whether you happened to be on the engineering or business side of the fence.
This talk is designed to help you navigate and understand the most important Big Data technologies and trends well-enough to formulate and implement an evolutionary data platform within your organization. A plethora of technologies will be discussed at a satisfying technical level including NoSQL, Hadoop, Spark, Storm, and Kafka, along with an architectural deep-dive highlighting the best practices and patterns including the lambda architecture, and enterprise data lakes. If you love jigsaw puzzle games, there is a very high chance that you will enjoy this session. Be there or be square!

Med hundrevis av tjenester som prater sammen over nettverket er det ikke til å unngå at noen tjenester er nede. Vi ser på hvordan FINN.no har tatt i bruk Hystrix for å isolere oss mot feil, og samtidig få monitorering og visualisering på kjøpet.
Finn.no har de siste årene gått over til en arkitektur basert på microservices. Dette har ført til mange flere nettverkskall mellom tjenester, noe som har økt sårbarheten i systemet, der feil i tjenester tar ned andre tjenester. Vi viser hvordan Finn.no har brukt Hystrix siste halve året for å fjerne disse sårbarhetene. Vi vil ta for oss spørsmål som: - Hvor i stacken passer Hystrix? - Hvordan konfigurerer man Hystrix, og hvordan finner man fornuftige verdier verdier skal man bruke? - Hvilke deler av Hystrix passer best når? - Hvordan passer hystrix sammen med eksisterende løsninger for monitorering?

Det skal ikke så mange tegnsettfeil til før frykten sniker seg inn. Kanskje tenker du ikke over det selv lengre, men sniker deg stille forbi en ensom Å naar du moeter den i en moerk bakgate?
Java har i utgangspunktet støtte for alle verdens tegn, men det er noen snubletråder på veien. Å håndtere tegnsett riktig er noe en hver utvikler burde kunne, men litt for mange lukker øynene og håper at det går greit. Kom for å høre hvordan du kan slippe å noen sinne se en � igjen.

OWASP developed the Application Security Verification Standard to help develop and maintain secure applications. The talk will discuss the standard and give details how to achive advanced level.
OWASP developed the Application Security Verification Standard to help develop and maintain secure applications. This is a very usable standard. It contains checklists in sixteen requirement areas, ranging from authentication, session management to mobile verification. There are three levels of compliance (opportunistic, standard and advanced). During the presentation we will give an overview of these requirements and give some ideas of how the advanced level can be reached in a simple sample (business) application. This will be achieved using a skeleton application built using a Java back-end (using JEE) and a JavaScript front-end (using Angular). You will see the challenges and how they were overcome.

junit-quickcheck er et verktøy for JUnit hvor man kan uttrykke generelle egenskaper i stedet for å teste med et antall eksempler, og denne lyntalen gir en rask introduksjon til dette.
Ofte er det hensiktsmessig å lage funksjonalitet av mer generell karakter enn domenet man utvikler et system for. Dette kan være alt fra små hjelpemetoder for strengmanipulering, til håndtering av brukerinput, og mye annet. For å teste dette bruker man som regel et lite endelig antall eksempler. Man må sørge for at eksemplene dekker alle corner-cases, og hva som anses som corner-case kan være direkte avhengig av implementasjonen. Dette skal i prinsippet bevise at logikken håndterer en massiv, og noen ganger i prinsippet uendelig, mengde ulik input. Hvis man i stedet kunne uttrykke "for alle strenger", "for alle heltall mindre enn", "for alle enums av type, unntatt" kan man slippe unna med færre tester, og man vil ikke få avledet oppmerksomheten av eksempler hvis innhold egentlig ikke har noen semantisk betydning for testenes utfall. junit-quickcheck er inspirert av tilsvarende verktøy for Haskell (QuickCheck) og Scala (ScalaCheck), og muliggjør at man spesifiserer egenskaper (property-based testing) fremfor å syntetisere eksempler for å teste kode. Denne lyntalen vil gi en introduksjon til junit-quickcheck i Java, og forutsetter ingen tidligere erfaring med property-based testing.

Det er viktigere at kode havner i riktig modul enn at vi har den korrekte dekorasjonen med javadoc, eller som kanskje Jan P. Syse ville sagt det: “Det hjelper ikke være på riktig hylle når du er i feil skap”
Det er enkelt å ha feil fokus, og det finnes bra verktøystøtte for det også, en klasse uten javadoc kan vi få til å bryte bygget hvis vi vil. Sikring av at kode havner på rett plass er ikke like enkelt. Tenk deg at noen rett fra gata skal jobbe med koden på ditt prosjekt, bryr vi oss om javadoc eller at koden skrives i riktig modul? Denne lyntalen handler om de enkle skissene vi trenger som guidelines, de som er langt viktigere enn javadoc.. .

This talk is about how to secure your front-end + backend applications using a RESTful approach. As opposed to traditional and monolithic server-side applications (where the HTTP session is used), when your front-end application is running on a browser and not securely from the server, there are few things you need to consider. In this session Alvaro will explore standards like OAuth and JWT to achieve a stateless, token-based authentication and authorisation. He will explore the existing impl More specifically, the demonstration will be made using Spring Security REST, a popular Grails plugin written by Álvaro.
Authentication is normally a stateful service. Most of the implementations rely on the HTTP session, thus introducing state as the session is an in-memory data structure in the application server. In the microservices era, most of the companies are developing such called RESTful services, where one of the principles is to create stateless systems. In such scenario, authentication should be stateless too. There is a standard specification to secure web application and API's, that is being adopted massively by the industry: OAuth 2. The specification doesn't explicitly cover how to make a stateless implementation. And most of the existing ones depend on some sort of external storage (such as a DB) to store the tokens generated for a later validation. Fortunately, there is another specification by the IETF called JSON Web Token, that can be combined with OAuth 2 to achieve a stateless authentication system. In the session, Alvaro will explain the core concepts of OAuth 2, as well as JWT and how can them be used together to achieve the last 2 letters of REST: State Transfer.

Har du ikke budsjettet til Facebook for å lage en moderne app? Apps laget i Meteor gir brukeren en moderne brukeropplevelse både på mobil og web, full-stack reaktivitet gjør at data sømløst deles mellom brukere i tillegg til at appen føles veldig responsiv. Lær hvordan du kan komme i gang med Meteor og lage awesome apps i morgen!
I denne lyntalen vil vi få en kort introduksjon til hva Meteor er og se på noen av prinsippene som ligger bak denne forholdsvis nye plattformen for å lage apps. Med betydelig mindre kode enn før kan man nå lage moderne reaktive apps på kort tid. Et språk overalt og isomorfisk kode gjør at koden kan kjøre på server og klient. Vi vil også se på hvordan man kommer i gang med Meteor, forstå hva en app består av og hvordan man tar i bruk ferdig pakker med funksjonalitet, og til slutt hvordan man deployer en app opp i skyen.

Etter å ha utsatt en nødvendig refaktorerings/nyutviklingsjobb lenge ble vi nødt til å krumme halsen og sette igang: Nye krav og brukergrupper gjorde det nødvendig å nyutvikle registreringen av parter og aktører i Lovisa (domstolenes saksbehandlingsløsning). I denne lyntalen beskriver jeg hvordan vi grep problemet an, hva slags vurderinger vi gjorde underveis og hvordan vi fikk levert en forbedret og utvidet løsning til kunden.
Det er en stor utfordring å fornye virksomhetskritiske systemer med lang levetid. I denne lyntalen fokuserer vi på hvordan vi gikk fram for å refaktorere/nyutvikle en sentral komponent i Lovisa som har vært domstolenes sentrale saksbehandlingsløsning siden 2003. Den aktuelle komponenten for å registrere parter og aktører i en sak ble realisert av en utvikler sommeren 2004. Denne utviklereren har vært ute av prosjektet lenge, og vedlikehold og feature-creep i årene etter hadde skapt en komponent som var svært krevende å vedlikeholde og utvide. Sommeren 2014 bestemte vi oss derfor for å gå drastisk til verks med tre mål for øyet: 1. Forbedre vedlikeholdbarheten av Swing-komponentene med tilhørende view-controllere. 2. Forbedre brukergrensesnittet. 3. Støtte nytt behov for å registrere eiendommer fra Matrikkelen som parter i saker. Vi valgte å ikke nyutvikle Swing-koden fra scratch, da vi vurderte dette til å føre med seg for stor risiko. I stedet gjorde vi en trinnvis refaktorering av den eksisterende koden som gjorde at vi til enhver tid hadde en fungerende løsning i testmiljøet. Vi begynte med å få kontroll på kodebasen uten å gjøre funksjonelle endringer. Java-koden ble oppgradert fra 2004-kode til 2014-kode. Vi fikk på plass testdekning i form av enhetstester og TestComplete-tester. Vi tok i bruk oppgraderte rammeverk for brukergrensesnitt, samt rammeverk for å håndtere nøstede brukertransaksjoner. Dette reduserte kodekompleksiteten og skapte et godt utgangspunkt for å kunne utvikle ny funksjonalitet. Produksjonssettingen av den nye løsningen var vellykket, og det eneste vi angret på var at vi i et snev av manglende selvtillitt hadde videreført deler av den gamle løsningen via en property-styrt nødutgang. Dette viste seg å være helt unødvendig, og skapte bare problemer med kodeduplisering.

An introduction to the Elasticsearch, Logstash, Kibana stack and our experiences using ELK.
We receive error logs from our production environment and required a tool to deal with the, at times, large amount of error messages. After looking into available log analysis products we chose Elasticsearch, Logstash and Kibana. It's a complete, highly configurable software stack for log processing, and a free, open source alternative to tools like Splunk. Logstash is a tool for processing events and logs. It can be configured through simple configuration files using Ruby dictionary syntax. The configuration files set up a pipeline for how logs should be processed. This allows you to split log messages into separate fields, tag them and add data based on the processing of the log message contents. Logstash integrates with Elasticsearch, a search engine based on Apache Lucene, to store and index the enriched logs. Elasticsearch makes the logs searchable in a modern search engine with data analytics capabilities. Kibana is a web front end for searching and visualizing data available in Elasticsearch. Using Kibana, one can search logs and create graphs and other visualizations of the log contents. We use Logstash to detect patterns in logs, which we use to tag error messages with Jira issue numbers and exception types. Kibana lets us visualize the amount of errors, the kinds of errors that occur and when. The visualizations gives us an easily understandable overview of the problems in the analyzed environment.

Tips og triks for å lage loggmeldinger som kan brukes til noe.
Gjennomgang av noen enkle triks man kan gjøre for å skrive loggmeldinger som gir god nytteverdi ved feilsøking, samt litt om hvordan man kan nyttegjøre seg av logger gjennom bruk av loggsøkeverktøy.

Ti minutter om hvordan vi i et prosjekt sammen med kunden og kundens jurister brukte XML til å utvikle en selvdokumenterende modell for utledning av hvilke dokumenter som er påkrevd i innsendte refusjonssøknader.
Jeg føler ikke at jeg sparker inn noen dører når jeg sier at vi utviklere generelt er mindre begeistret for XML og når vi oppdager svakheter ved en teknologi eller anvendelsen av den svinger vi urovekkende ofte pendelen til det motsatte ytterpunktet. Jeg har med denne lyntalen ingen intensjoner om å overbevise deg til å flytte alle JPA annotasjonene dine tilbake i XML. Mine tilmålte ti minutter har jeg tenkt å bruke på å beskrive en snedig måte vi i et prosjekt sammen med kunden og kundens jurister anvendte XML, XSLT og Twitter Bootstrap til å utarbeide en selvdokumenterende modell for utledning av påkrevde vedlegg for en gitt søknad.

Vulnerability in our applications: is there anything more we can do about it? Should security always be an "afterthought"?
This talk is inspired by the book Future Crimes by Marc Goodman which portrays the exponential growth of the current technological development, and projects the future development and then elaborates their possible exploits and consequences. The ever-growing number of computer screens proliferating in our world, our growing interconnectedness and the ubiquity of inherently vulnerable computing systems (both the “traditional” and the future ones like IoT, AI, etc) imply that this gathering storm of technological insecurity can no longer be ignored. “As things stand today, the engineers, coders, and companies that create today’s technologies have near-zero personal and professional responsibility for the consequences of their actions.” Should security be “merely an afterthought” and an external process? Can security aspects be integrated in the craftsmanship/agile paradigms, and then reflected in the methodologies, practices and tools?

Stream processing, to quote Mugatu, is so hot right now. Come see how Akka Streams is used to create reusable pieces of transfomation pipelines that transparently leverages multicore hardware.
In this presentation we'll explore fast data streaming using Akka Streams—how to design robust transformation pipelines with built-in flow control, able to take advantage of multicore and going over networks. We'll discuss the traditional pitfalls and how they can be overcome as well as explore how we can build reusable pieces of pipeline logic that we can reuse—a smorgasbord of transformations.

Java was designed to abstract your hardware, this has come at a cost and thanks to Moore's law we've not noticed. Look a little deeper into your performance however and you'll see the price you're paying for Java's Objects. Turn it into binary though and see order(s) of magnitude better performance from the same code.
There are a lot of advantages to XML. Using XML schema is probably one of the best ways to define a model and messaging standard, but the messages we pass around and store are horribly verbose. For years now, we’ve been binding the XML to Java and working with tools such as JAXB, but they often inflate the in-memory size even further, not to mention the number of objects they create. Incept5 developed a Java XML binding tool with the same API but where the content is stored as a single byte array. So, just one object per message, a fraction of the memory footprint, and at least an order of magnitude more speed than traditional Java binding. Taking XML back to binary means getting big data in memory, and 100 GB of XML in your laptop’s RAM is entirely feasible. Learn more in this session.

Introduksjon til hierarkisk temporært minne, som er en modell av hjernens neocortex, for å gjenkjenne mønstre og finne avvik i Big Data. Noen eksempler hvor hierarkisk temporært minne kan benyttes for Big Data - datastrømmer.
Neocortex er et 4 mm tykt "teppe" i hjernebarken, som benyttes for gjenkjenning av mønstre, for å forutsi hva som kommer til å skje og for å finne avvik. Det strømmer kontinuerlig store mengder data gjennom neocortex fra våre datakilder som syn, hørsel og andre sanser, og neocortex setter dette i system med sitt hierarkiske minne. Med hierarkisk temporært minne (Hierarchical Temporal Memory, HTM) forsøker man å lage en datamodell av neocortex, og HTM er sånn sett en ny type nevrale nettverk. Teorien bak HTM utvikles raskt, men man har mye igjen før alle seks lag av neocortex er forstått og implementert i HTM - modellen. Allerede nå finnes open source kildekode, bl.a. "htm.java", og kommersielle løsninger som utnytter mulighetene med HTM. Datastrømmer fra Big Data - kilder som IoT, GPS-tracking, medisinske applikasjoner, serverovervåkning, finans, jordskjelvovervåkning er bare noen eksempler hvor HTM kan gjenkjenne mønstre og finne avvik.

Learn how to build native Android apps from scratch! We will first live code a simple Spotify app and describe all relevant topics along the way. Then, you will get hands-on experience by doing assignments and developing a Twitter-like app.
This workshop provides a solid foundation for everyone who wants to learn Android development. You will be introduced to topics such as: - Activities, Events and Intents - Creating a flexible UI with layouts - REST API integration with Retrofit - Take pictures with the camera and upload to Imgur (and our backend) - Target the newest version of Android, Lollipop, and create a beautiful app with Material Design When doing the assignments you are free to either focus on creating a beautiful app, or implementing as much functionality as possible. If you have an Android Wear watch, why not add support for Wearables?

Burp Suite is an integrated platform for performing security testing of web applications. We have built that security check into our Jenkins build server. In this presentation we will show you how it works, how to do it, challenges and shortcomings to our suggested solution.
As most conscious software companies, we have a security crew doing pen-tests before releasing to production. However, as the pen-test was very late in the development game this wasn’t very agile and fixing errors this late was an extremely high risk activity. Of course, we could get them to do the pen-test multiple times earlier in the development cycle, but we then of course have to use more time and resources and time and resources cost lots of money. So, our security guys came to us and wondered if we couldn’t build in this type of security within our automated build cycle. Our build server of choice is currently Jenkins, the security guys tools of choice was Burp a java based GUI tool and we did a PoC to make these work together. In this presentation we will share our findings, our code and give you a how to guide to do it yourself. We will also touch some common security issues, a short Burp how-to and some insight on how to interpret the Burp report the tool provides.

More and more computers are used in cars to control everything from satellite navigation to braking to the cruise control. This session will look at how you can use Java to use information from a car along with that of additional sensors to record and playback detailed telemetry from a journey. Whilst a fun session there, there are practical applications for insurance, fleet management and training.
There is significantly more computing power in the average family car today than was used to get the first men to the moon. Pretty much every aspect of a car now uses some form of computing to simplify or enhance these features, from adaptive cruise control to tyre pressure monitoring systems. This session will look at the Carputer that I built using a Raspberry Pi coupled to a range of sensors, as well as an interface to the CAN bus on my car. Having written Java code to collect the data during journeys, I also developed an application to playback data for review later. All aspects of the system will be explained.

An IDE is so much more than an editor, and yet still people seem to compare one to another. In this session we’re going to look at IntelliJ IDEA and show tips and tricks that will make you a more efficient and productive developer. From searching for symbols to having a smooth worfklow when working with version control, we’ll examine all the things that make it possible to have a pleasurable development experience. You’ll be guaranteed to leave this session knowing things you probably didn’t even know existed and were afraid to ask if they did.
An IDE is so much more than an editor, and yet still people seem to compare one to another. In this session we’re going to look at IntelliJ IDEA and show tips and tricks that will make you a more efficient and productive developer. From searching for symbols to having a smooth worfklow when working with version control, we’ll examine all the things that make it possible to have a pleasurable development experience. You’ll be guaranteed to leave this session knowing things you probably didn’t even know existed and were afraid to ask if they did.

Hvorfor skal vi bry oss med funktorer, monoider , bind og andre rariteter? Verden har sett nok funksjonelle one-linere uten kontekst! Bli med på en reise fra den objektorienterte verdenen til den funksjonsorienterte, med tips, triks og aha-opplevelser som vil fylle verktøykassen din med godsaker som fungerer i ekte prosjekter.
Som en som programmerer funksjonsorientert med Java daglig treffer jeg mange som etterlyser informasjon om hvordan man anvender funksjonell programmering i ekte prosjekter med betalende kunder og hva man kan få igjen for det. Jeg skal fortelle mine erfaringer og dele aha-opplevelser fra da jeg leste om ordet funksjon for første gang til jeg nå sitter og bruker kategoriteori for å lage programmer.

Det er ikke din inngående kjenskap til kompilatoren som avgjør ditt bidrag til prosjektet, ei heller antal år med Java-programmering. Om du er en junior eller en senior er et spørsmål om holdninger og handlinger.
Selv om stillingsutlysninger på Finn.no skulle tilsi noe annet, er det svak korrelasjon mellom antall års erfaring og nivået på en utviklers bidrag i et prosjekt. Det er viktig med teknisk kompetanse, men uten de rette holdningene har det liten betydning. Det beste man kan gjøre for å øke verdien av sitt bidrag i et prosjekt er å reflektere over sitt forhold til følgende holdninger: Ubetinget ansvar Faglig integritet Grunnleggende ydmykhet Disse holdningene spiller videre inn på hvordan din kommunikasjon er, om du er etterrettelig, om du forhandler konstruktivt og om du mestrer dine følelser på en god måte.

Java Flight Recorder is a low overhead profiling tool built into the Oracle JDK. It is possible to turn on whenever you wish to investigate the behavior of your Java application.
You will get a walkthrough of the features and some design choices for Java Flight Recorder, learn to create flight recordings in multiple ways and analyze them using Java Mission Control. Find out how it can have such a low overhead, and how to get the most out of using it.

This session has one goal: to teach you what hypermedia really is and why it's important. We'll use hypermedia to develop and play a simple yet flexible text adventure that can be modified and extended at runtime without breaking. Just like the Web.
As the Web has shown, hypermedia messages over HTTP is an elegant and flexible way of building applications. The HTTP infrastructure simplifies your application protocol and gives you caching and scalability essentially for free. Hypermedia messages gives you dynamic control over the state transitions in your application, allowing you to grow your application and change things around without breaking clients. These are terrific properties when building any application! In this talk, I'll put these claims to the test as we play, dissect and extend an old-school text adventure game implemented using nothing but HTTP and hypermedia.

Består løsningen din av flere moduler? Vil du under utvikling og testing styre hvilke moduler og databaser du kjører opp på egen maskin og hvilke du lar gå mot eksterne miljøer? I denne lyntalen får du se hvordan et av Knowits prosjekter benyttet Boot2Docker og Docker Compose til å lage et lettvekts og orkestrerbart utviklingsmiljø av Docker-containere.
Med Docker har utviklere fått et kraftig verktøy for å pakke, kjøre og deploye software, og det kan i mange tilfeller erstatte fullskala virtualisering. Fordelene ved prodlike utviklings - og testmiljø og enklere deployment er det som ofte fremheves, men Docker kan også brukes til gi deg et enklere miljø på uviklermaskinen din. For å kjøre Docker på maskiner som ikke kjører Linux finnes det flere løsninger. Docker anbefaler i dag Boot2Docker, som er en lettvekts Linux-distribusjon som kun kjører Docker-containere i din Windows eller OS X maskin. Med Boot2docker kan flere kjørende containere dele filsystemet på maskinen din, og du kan lett kjøre opp et større antall containere som alle kjører separate moduler fra samme kodebase. Med Docker Compose (tidligere Fig) kan du orkestere den resulterende multicontainer-applikasjonen. Du kan definere de ulike Docker-containerne og avhengighetene mellom dem, og kjøre opp hele miljøet med én kommando. I denne lyntalen får du se hvordan Knowit benyttet denne teknologien i et prosjekt der utviklerne fant det tungvint å både dele utviklingsserver og kjøre opp løsningens ulike moduler lokalt. Med Boot2Docker og Docker Compose fikk de et lettvekts, fleksibelt og orkestrerbart utviklingsmiljø av Docker-containere. Du får se hvordan vi gjorde det i vårt prosjekt, og noen tips med på veien om hvordan du kan gjøre det samme.

Å skrive kravspesifikasjoner er vanskelig. Og noen ganger blir resultatet mer komisk enn opplysende.
Vi jobber alle med kravspesifikasjoner på en eller annen måte. Vi blir stilt krav til og vi stiller krav til andre. Noen kravspesifikasjoner er beskrevet i detalj med mye formalitet, andre er uformelle og ufullstendige. I denne lyntalen vil jeg presentere noen eksempler på krav jeg har sett på trykk som er spesielt vanskelig å forholde seg til, og nesten på grensen av det humoristiske. Med konkrete forslag til hva som kunne vært gjort annerledes.

Java er en større verktøykasse enn du tror helt uten tillegg
Bruker du java rammeverk som Spring og Hibernate? Vet du hvorfor du gjør det? Har du tatt noen vurdering på om du faktisk trenger å bruke det? I denne lyntalen vil jeg demonstrere at koden blir mer lettfattelig og vel så effektiv hvis man unngår slike rammeverk, og holder seg til ren java. Kode vil bli vist.

We designers have been told for ages to learn how to program because we needed to know the technology. On the other hand, very few developers bother doing the same with design. This usually leads to worse results than necessary, and robs us of the opportunity to play on the same team.
This presentation is meant to spark a much needed discussion about how developers and designers can work together to achieve excellence without losing their minds. Attendees should leave the room afterwards with a certain insight in how ignorance hinders best outcomes and how they personally can improve the situation.

The Java debugger is your best friend. But do you know how it works ? We will look at how the JVM and debugger interact in detail to make it such a powerful tool. Finally, we experiment with the same functionality ourselves to achieve things things like: *record stack traces with values * specify NullPointerException cause. Get ready to see a whole range of valuable information about your application open up!
If you are like me, then the debugger is your absolute favourite tool. But how does the Java debugger really work ? For instance, why do some conditional breakpoints severely slow down the code? We will look at how the debugger and the JVM interact to carry out common tasks such as: - breakpoints - stepping - code evaluation - value modification - reference traversal - hot code replacement We will see how the interfaces can be utilised to monitor running systems. Finally, we will experiment with the java debug interface ourselves to improve debugging and capture more precise information: - Record stack frames with values. - specify NullPointerException cause. - live object monitoring Come along to see the power of the Java debugger unleashed. Presentation: https://prezi.com/7aqnhm7gl285/jvm-debugging-under-the-hood-javazone/

JCache API (JSR-107) has been released in March 2014. For the first time since the initial release of Java we have a standardized vendor-neutral API for caching. What does it mean for developers and why we should care? Isn't this yet another bloated & hard-to-use abstraction? This talk will introduce concepts and structures JCache is based on. We will show how to deal with differences in underlying implementations, how migrate from existing proprietary caching APIs to JCache and how to avoid common pitfalls.
This talk will reason about why to move away from proprietary Caching implementations and shows common pitfalls people tried to solve over and over again in the last years. It will also feature a live-coding section to introduce the JCache APIs and show some successful examples of how to move onwards to JCache from currently used custom built or proprietary solutions.

You’ve just set up your Kafka cluster and now you are ready to process tens of thousands events per second. You decoupled your architecture and now all the communication goes via pubSub bus and you can focus only on providing business value. It would be great if that can be true. In real life you need to do a lot of tweaks to have your backbone ready to handle all the traffic you want.
In the talk we will focus on the project of redesigning the core event bus of the Allegro auction platform. We will talk issues on all the levels from network to data serialization. After the presentation you will have answers to the questions: How to assure our clients that not even a single event is lost? How to respond in less than 65ms even if Kafka is rebuilding its cluster? ...And many other questions you will face.

This talk is about how you can provide logins for your modern apps and APIs. We'll visit a broad range of related topics, such as OpenID Connect, SAML, multi-factor authentication, password hashing, IdPs, federation and brokering.
Years ago, in the days of 3-tiered architecture, logins where simpler. A basic form with a username and password validated against a users table, or in more advanced cases an LDAP server, was often enough. Today with modern architectures that's no longer the case. These architectures and the fact that everything is exposed on the Internet puts new demands on security. This talk is about how you can provide logins for your modern apps and APIs. We'll visit a broad range of related topics, such as OpenID Connect, SAML, multi-factor authentication, password hashing, IdPs, federation and brokering. Finally, we'll show how you can have all these features in your apps without any coding by using an open source identity and access management solution.

Theres no denying that JavaScript is everywhere! But did you know that you could also use it to interact with a range of Sensors (i.e. distance, pressure and heat) and control Actuators (i.e. servos and LED's)? Attend this lightning talk to find out more about the NodeBots revolution!
In 10 fast paced minutes you'll learn about how you can get started with JavaScript powered Robots using an Arduino UNO and the Johnny-Five framework. If you are interested in picking up some JavaScript, Node.js, Arduino, Robotics or Electronics skills then this is the lightning talk for you! There'll also be drones!

A new version of the protocol names HTTP/2 is on its way. In this session we’ll explore the possibilities of HTTP/2 and Java.
HTTP is the fundamental networking protocol that powers the web. A new version of the protocol names HTTP/2 is on its way. In this session I’ll explore the possibilities of HTTP/2 and Java. We’ll look at popular containers such as Jetty and Tomcat and explore how to setup HTTP/2 in those environments. HTTP/2 brings a lot of additional functionality to the table. We’ll also review the new features and discuss the ones applicable from a Java developer’s perspective.

How can new features in Java 8 be used to make writing Low Latency application easier? How do you tune garbage creation in the use of Lambdas?
Writing Low Latency applications means using the subset of a language which performs consistently. Can Streams and Lambdas be used in this context? What are some of the practical performance considerations? When does it make sense to use parallelStream()?

Maven 3.3.1 har fått bedre støtte for core extensions. I kombinasjon med continuous friendly versions gjør dette det mulig å få til continuous releases på både utvikler- og byggeserversiden på en elegant måte.
Denne lyntalen vil ta for seg hva maven støtter ut av boksen for continuous releases, hva og hvordan man kan legge til de resterende bitene, samt hva som fortsatt mangler i et større perspektiv. Det blir gitt en rask innføring i Core Extensions og mavens continuous friendly versions.

Ofte trenger man å kjøre regelmessige batchjobber, og å overvåke resultatet av dem. Batchjobber kan ha avhengigheter og det kan være komplekst å bygge gode systemer for å håndtere dette. Hvorfor bruker du ikke Jenkins?
Jenkins har mye funksjonalitet som man kan bruke i forbindelse med batchjobber, monitorering, varsling og så videre. Er det så gøy å lage sitt eget batchsystem at du ikke vil bruke Jenkins? Eller har du ikke oppdaget at du kan bruke Jenkins som batch-motor? La oss se hva den kan gjøre for oss.

Erfaringer fra FINN.no rundt recommender systems fra Item Similarity i Apache Mahout til User Based Collaborative Filtering i Spark MLlib.
Gjennomgang av hva vi har gjort på rundt det å anbefale annonser i FINN.no. Vi startet med Item Similarity i Apache Mahout i sent 2013. Vi startet med minne-basert modellgenerering og gikk så over til persisterte modeller. Lagret i filer som ble kopiert fra server til server. Sommeren 2014 introduserte vi Spark og MLlib og algoritmen ALS for User-Based Collaborative Filtering. ALS, Alternating Least Squares, er en Matrix Factorization modell som er bedre enn item-based/Item Similarity for implicit ratings. Matrix Factorization modeller krever mye minne og det å kopiere filer fra server til server var ikke noen varig løsing, så vi har gått over over til å lagre modellene for anbefaling i Cassandra, sammen med trafikk-dataene.

The award winning app - RuterBillett! How did we test an app that needed GPS, payment channels and were subject to poor conditions regarding connectivity.
the goal of this talk is to highlight some issues that developers tend to forget and testers must be aware of. - test the app where your customers use it - GPS positioning in a lab is not the same as out in the field - poor conditions may affect the app, especially in that moment when you try to buy a ticket. - change the time on your device, will your ticket suddenly be alive again?

Alle prosjekter gjør valg man skulle ønske man kunne gjøre om i etterpåklokskapens klare lys. Vi tar for oss 11 erfaringer fra MAG og EDAG i Skattetetaen, bakgrunnen for valgene og konsekvensene de medførte. Sannsynligvis greit å vite om ditt prosjekt står ovenfor tilsvarende problemstillinger.
Ifølge Oscar Wilde er "the only good thing to do with good advice is pass it on; it is never of any use to oneself". Allikevel vil vi beskrive 11 erfaringer som kan være nyttige for akkurat deg. Prosjektene MAG (Modernisering av grunnlagsdata) og EDAG (Elektronisk dialog med arbeidsgiver) nærmer seg avslutning, og har levert de første stegene i Skatteetatens moderniseringsmålbilde. Med et blikk i bakspeilet ser vi på designvalg som vi sannsynligvis ikke ville gjort om vi hadde hatt kunnskapen vi har i dag. Dette omfatter større og mindre valg som bruk av UUID som primærnøkkel, tilrettelegging av backup og restore, streaming, feilhåndtering, transaksjonstimeout og Jersey-avhengigheter. Rådene kan iallefall videreformidles til andre!

Erfaringsforedrag om arkitektur- og teknologivalg i open source-utvikling av sikkerhetskomponenter.
Systemer for autentisering, single-sign on og tilgangskontroll er tradisjonelt store, komplekse og dyre "enterprise"-systemer. Elsket av powerpoint-arkitekter og lisenspushere, men hatet av utviklere og DevOps-tilhengere. Kan Open Source og microservices være en bedre tilnærming? Tema for foredraget er hvilke valg som er gjort og hvordan disse har påvirket produktet og utviklerne. Microservices-arkitekturen står sentralt, men hovedpoenget er hva som har fungert godt og mindre godt. Kombinasjonen Open Source og sikkerhetskomponenter gjør at erfaringene kanskje vil overraske mange...

In this ligthing talk you will learn how you can finish all the half-finished projects located on your hard drive collecting dust.
I have many almost finished projects that I've never quite reached the goal of. The projects exceeded in time. I lost motivation or some other exciting project / technology emerged that drew my focus away from the unfinished projects. Becoming a dad for the first time, I suddenly had drastically less time dedicated to my projects. This forced me to change my habits and set clear limits. In this lightning talk I will share 20 simple but vital tips that I have learned along the way which will let you complete your projects 100%.

Motivasjon er alfa og omega når det kommer til å ha det bra på jobb. Denne lyntalen vil gå gjennom hvorfor motivasjon er så viktig og gi deg noen konkrete tips til hvordan DU kan motivere menneskene rundt deg og bidra til en bedre jobbhverdag.
Tenk alt du kan få til hvis du er motivert på jobb! -Og tenk hvor tung hverdagen blir når motivasjonen uteblir. Denne lyntalen vil ta for seg noen betraktninger rundt hva som gjør en dårlig sjef, hva som gjør en god leder og hvorfor jeg mener motivasjon er nøkkelen til gode resultater. Etter å ha hørt på denne lyntalen vil du ha noen konkrete tips du kan bruke i din jobbhverdag for å motivere menneskene rundt deg. -Uavhengig av din rolle i organisasjonen.

React.js har tatt framsida med storm. Men React.js kan også kjøre på serveren og rendre HTML som nettleseren kan vise med én gang. Med Java 8 sin Nashorn kan vi kjøre JavaScript på JVM, og det går ikke så verst fort heller. Vi ser på hvordan du får reactappen din opp å kjøre på Nashorn.
Ingen liker å messe med DOM-oppdateringer lenger. Alle er glade for å kunne organisere koden i enkle, gjenbrukbare komponenter. Men all denne javascripten har noen ulemper: koden må lastes ned og kjøres før du ser noe innhold på siden. Det kan gå fort, men er mobilen din treig, eller nettet ustabilt, blir brukeropplevelsen dårlig. I verste fall sitter du der, da, med en tom side og en vag følelse av at noe ikke helt stemmer. Søkemotorer har såvidt begynt å kjøre JavaScript, men det er trygt å anta at HTML fortsatt gir det beste resultatet når du kjemper om en god plassering i søkeresultatet. Vi ser på hvordan du kan med enkle grep kan kjøre reactkomponentene dine på JVM og viser teknikker for å parallellisere dette. Vi kikker på resultater fra hastighetsmålinger på FINN.no, og hvordan du optimaliserer JS-kjøringen på JVM.

Metrics is a library for gathering and exposing metrics from your application. In this talk I will show you how to get started, and what you can do with it.
Collecting data from how your application is behaving is important to get feedback and to improve your service. Metrics is one simple way to collect application specific performance data with very little overhead. With it you can find out things like: how your application is used, how fast it is responding, which parts are the most used, do I need more memory, how much CPU am I using. Setting it up is easy, but what's next? I will show you a few ways to use those metrics to get useful insights.

URLens rolle i APIet ditt endrer seg etterhvert som du går fra REST level 1 til 3. Noen av disse endringene er ikke selvsagte.
En vanlig attraksjon med RESTfulle APIer er hackable URLer. Når vi går fra tunge RMI-over-HTTP tjenester til REST er det fristende å lage pene URLer som beskriver med den største selvfølge hva den peker på, og som utviklere kan hacke på for å utforske APIet ditt. Første level REST gjør slike URLer nærmest til et krav, og kombinert med verbene i andre level har man et API man kan være stolt av. Men når du treffer level 3, er URLene forsatt dine venner? Jeg mener du må glemme dine hackable URLer om du vil gå hele veien til level 3.

I denne lyntalen vil du se hvordan du svært enkelt kan få din mobilapplikasjon til å konsumere et HTTP API ved hjelp av noen få linjer kode. Enklere blir det ikke!
Mobilapper og REST API-er går gjerne hånd i hånd om man ønsker å lage en mobil app som skal snakke med omverdenen. Å forholde seg til nettverkskall, trådstyring, JSON-parsing og feilhåndtering kan være en hodepine, men heldigvis finnes det en løsning. Retrofit gjør dette til en lek og du skal få se hvordan. I løpet av lyntalen vil vi gå gjennom et enkelt oppsett for å konsumere et HTTP API, se nærmere på grunnleggende funksjonalitet som ned- og opplasting av data, og avslutte med å gå inn på noen av de mer avanserte tingene man kan gjøre med Retrofit. Retrofit er et av flere rammeverk fra Square, en startup innen betalingsløsninger til mobilen. Square har ansatt open source Android-guru Jake Wharton, som står for vedlikehold og videreutvikling av bl.a. Retrofit. Selv om Retrofit ble laget med utgangspunkt i Android og mobilverdenen, fungerer det vel så bra i en hvilken som helst Java-applikasjon.

Have you ever explored the bin directory of your jdk? Do you know how you can analyze a memory dump using the tools there? Or get stacktraces of all java processes in a system? Or… There are many treasures in there, I'd like to give you a tour and show some useful tricks. This talk is a live walk through the tools that you already have and could start using in your JDK today!
Have you ever explored the bin directory of your jdk? Do you know how you can analyze a memory dump using the tools there? Or get stacktraces of all java processes in a system? Or… There are many treasures in there, I'd like you to understand what tools are there at your disposal and what you can achieve with them. This talk is a live walk through the tools that you already have and could start using in your JDK today!

This talk is about integration architectures, and in particular, how to pick the right one for your company. We will talk about what the pluses and minuses of each one are, and how Apache Camel can help you do the heavy lifting in each case.
You are setting out on an integration project. A lot of the documentation that you have found on the net is from vendors, and a good portion of that looks to have been written 10 years ago. ESBs are old hat, right? You have been on Twitter and it's all abuzz with microservices and Docker containers. Wouldn't it just be easier to hand-craft a couple of point-to-point integrations and glue them inside your web app? This talk will clear the fog and outline your options as they appear today. We will then discuss how to select the one most likely to succeed in your organization through the application of Conway's Law (one size does not fit all). We will discuss the non-functional requirements that any set of integrations should consider and how they can be applied to each option. We will then outline the Apache Camel open source integration framework, what it and its tooling ecosystem bring to the party, and how it can be applied in each instance to reduce your workload, so that you and your team can focus on the functional and non-functional problems of integration today.

JTransfo is a library which allows you to indicate in your transfer objects how they map to your domain objetcs. Why and how should you use it.
JTransfo is a library which allows you to indicate in your transfer objects how they map to your domain objetcs. This allows you to avoid a lot of boiler plate code in your application. jTransfo can also help you with security and constraint checking. You can indicate which fields should be copied in which cases, based on tags which can for example represent user roles or object state.

In a world of "continuous everything" each discipline within the industry has to find ways to provide value fast and reliably. Business people need to be able to adapt to an ever changing world, developers need to deliver software many times per day, and operations need to provide high availability infrastructure at an instant. How does security integrate into this work stream?
Reviewing every code change quickly becomes impractical. Integrating security tools into the development and security cycles is hard when you need to focus on security without introducing any noise. Automation as close as possible to when code is written is key to prevent vulnerabilities before they are shipped. But how does one go about automating security? And even when you have done your best effort of not introducing vulnerabilities into production you are only half way. Development, Test and QA are not hostile environments when it comes to security. The real test only happens after you have hit Production. In this talk we will present experiences with security work on a team delivering continuously. We will also explain the state of continuous delivery and how this affects working with security together with some recommendations for the future.

Everyone's doing Stream Processing these days. During last 5 years there's been more CEP engines released than Web Frameworks. This is a great pattern, but without Functional Programming concepts you're just touching a surface. How to make your streams immutable, composable and reusable, and why many out-of-the-box distributions are limiting your basically endless opportunities.
Stateful streams is a current state-of-art. Although much too often state makes the Stream less composable and performant. People are using stores such as Redis to store the intermediate state, and never think about better ways to make state available for every worker. With currently existing single-box RX Frameworks and Message Queues it's possible to build Streams in ways that entirely change the perspective and thinking about the stream, taking complexity out and letting developers think about each entity in a stream as an isolated event, allowing better composition and testability.

Hva skjer når en ny brukergruppe med nye behov skal begynne å bruke eksisterende løsning? Er det alltid bare gøy for eksisterende brukere å få snudd verden sin på hodet ved at gamle, kjente og kjære skjermbilder blir helt nye?
I forbindelse med ny jordskiftelov av 2016, skal Jordskifterettene begynne å bruke det eksisterende saksbehandlingssystemet til Ting- og Lagmannsretten. Vi hoppet på dypt vann og tok tak i den viktigste kjernekomponenten i hele systemet og forandret den totalt. I denne lyntalen ser vi på våre erfaringer med å introdusere nye og radikalt annerledes løsninger til en eksisterende brukergruppe, og hvordan vi gikk frem for at veldig ulike behov skulle løses i felles funksjonalitet.

Det kan være utfordrende å finne en god inndeling i moduler og applikasjoner når man skal utvikle løsninger for et større funksjonelt område. Ved å basere systemet på plugins kan man oppnå god granularisering samtidig som inndeling i en eller mange applikasjoner/micro-services kan utsettes til et senere tidspunkt.
Plugin-baserte systemer er vanlig i mye av den mest brukte programvaren for systemutvikling. Applikasjoner som Jenkins, Jira, IntelliJ og Emacs er alle glimrende eksempel på dette - hvor plugins brukes for å utvide eller tilpasse systemet til hver enkelt bruker eller gruppes behov. Plugin-tankegangen er også nyttig i de applikasjonene vi selv utvikler. Med plugins blir det enkelt å skru funksjonalitet av/på (feature-toggling), gjøre utrulling av deler/bugfix uten å ta ned systemet, og få en generelt god inndeling av applikasjonen. De siste årene har jeg fått starte utviklingen av en rekke nye applikasjoner som skal passe inn i en verden av micro-services. Applikasjoner som ideelt sett skal være enkle, testbare og skalerbare. På et par forskjellige applikasjoner har vi nå tatt i bruk en plugin-basert arkitektur som lar oss styre inndelingen på en langt mer fleksibel måte uten at det kompliserer ting. I denne presentasjonen går jeg gjennom hvilke erfaringer vi har med denne typen arkitektur - Hva oppnår vi? Hvordan gjør vi det rent praktisk? Hvilke andre alternativer har man?

Det offentlige og flere store bedrifter bruker milliarder av kroner på konsulenter hvert år. Få hodet opp av sanda, se virkligheten i hvitøyet og innse at å ha konsulenter rekende rundt i årevis ikke skaffer deg annet en dyre og dårlige løsninger!
Etter å ha sett denne lyntalen vil publikum forstå at korrekt bruk av konsulenter er at man leier dem inn for å løse spesifikke oppgaver som organisasjonen ikke selv har kompetanse til eller for å hjelpe til med uforutsette topper. Man skal ikke bruke konsulenter fordi man har ansettelsesstopp eller er redd for at man ikke kan kvitte seg med folk når man ikke lenger har bruk for dem.

Join me for some ranting about how best practices from open source development and project management school is making your sustaining team miserable
I dare say most projects start off with a goal of producing code that is easy to maintain for the sustaining crew. But as developers are too often split into either pure development teams or pure sustaining teams, not many in the development teams get to experience what sustaining is actually like. Many seemingly good ideas that are great in the developing phase, make life more difficult in sustaining. Many things that are essential for a good library or framework, are harmful when applied to application development. I want to share some concrete examples and hopefully inspire you all to write applications that is easier for others to work with.

Taking photos of the night sky requires accurate control to track the stars. Controlling a telescope from my pc made me wander into the realms outside the JVM, and into the world of OS and processor specific libraries and connections. Or “write some times, run somewhere”.
When I started using Java, I tried to stay within the 100% java paradigm to make sure that my software would truly be “write once, run anywhere”. Native code was blasphemy. My world consisted of a keyboard, a mouse, a screen and the net. On the net were databases and everything else. A few years back, I started on a hobby project where I needed to break out of the JVM and talk to something that didn’t speak to java. I needed to communicate with the hardware of a webcamera and an embedded platform. All of this to make software that would keep my telescope tracking the night sky with extreme precision. And it was still portable. Sort of. Using good ol’e SOLID principles. I will give a short precentation on the what, why and how of making the system work.

Gutta i elfenbenstårnet. Powerpoint-arkitekter. Papirtigere. Slik oppfatter utviklere ofte arkitekter. Men hva tenker egentlig arkitekter om utviklere? Hvorfor ser arkitekter alltid ting annerledes? Og hvorfor gjør arkitekter som de gjør?
I det venstre hjørnet: utvikleren. Agile metoder, SCRUM, utvikling basert på brukerhistorier, lettvektige rammeverk, mest mulig egenutvikling med de nyeste teknologiene, microservices, osv. I det høyre hjørnet: arkitekten. Virksomhetsarkitektur, målbilde, BPM Suite, SOA plattform, mest mulig bruk av kommersielle løsninger, gjenbruk eller tjenesteorientering. Ut fra arkitektenes ståsted tas et kritisk blikk på bruk av agile metoder ved større infrastruktur- og plattformprosjekter. Utviklerens ønske og argumenter for mest mulig egenutvikling og bruk av de alltid hotteste teknologiene diskuteres opp med forretnings behov. Erfaringer, do’s and don’ts fra ulike kundercaser og prosjekter forestilles og et sett med anti-patterns presenteres.

We have been using Java 8 in production for over a year now and would like to share some of our experiences and best practices. Java 8 helps us to adopt a more functional style in our programs, and this talk will discuss how to write code that is both elegant, readable and efficient.
During the talk I will be going in depth on some of the new language features in Java 8, and also touch on some nice additional utilities. Some of the topics include: - Lambdas vs. Method Handles - Streams + Optional = true? - parallelStream FTW? - To mutate or not to mutate

Hvorfor bruke lang tid på å lage ikoner til din Android-app når man enkelt kan bruke plassbesparende font-ikoner fra web-verdenen. Vektorgrafikk er også på vei inn i Android med noen nyheter i Android 5.
Det kan ofte være tidkrevende å lage grafikk til applikasjoner. Under utvikling av selv en enkel app kan det være greit å spe på med ikoner i forskjellige størrelser enten som tillegg til tekst eller som erstatning til tekst på knapper. På web har man en stund brukt konseptet font-ikoner som erstatter GIF og PNG for enkle monokrome ikoner. Dette kan man enkelt også bruke direkte i en Android-app eller Swing-GUI. Jeg viser eksempler på hvordan font-ikoner kan implementeres i en Android-app på en enkel måte. Med Android 5 (Lollipop) så kommer også mulighet for å lage vektor-bilder og animasjoner av disse ved å bruke VectorDrawable og AnimatedVectorDrawable, hvor man representerer grafikken med XML-filer. Disse har stort potensiale for fremtiden, men har sine begrensninger. Jeg vil vise eksempler på bruk og hvordan man kan bruke vektorgrafikk og hvor dette ikke er anbefalt. Det finnes også alternativer for de som ønsker å bruke vektorgrafikk i tidligere versjoner av Android.

You will learn how profiling tools work and whether you should trust their suggestions or not.
To troubleshoot a devious performance issue or understand the performance characteristics of an application, developers like to use profilers. But what do those numbers they produce actually mean? Are they accurate? How does a profiler actually measure them? What are potential sources of error? Can you compare those numbers with coworkers’? Is it possible to do anything useful with the produced results? This session provides answers to these questions. You will learn how to judge results produced by profilers, find out about the basic measurement techniques of profilers, and learn how to configure them correctly. The presentation shows many problems in live coding examples. Everything mentioned in the session is applicable to any tool.

This talk outlines the key capabilities of the Java EE platform and introduces the audience to additional frameworks and concepts which do help by implementing all kinds of security requirements in Java EE based applications.
Security in applications is a never-ending story. Most of the knowledge about how to build secure applications is derived from knowledge and experience. And we've all done the same mistakes every Java EE developer does over and over again. But how to solve the real business requirements behind access and authorization with Java EE? Can I have a 15k rights matrix? Does that perform? How to secure the transport layer? How does session binding works? Can I implement 2-Factor-Authentication? And what about social integrations? This talk outlines the key capabilities of the Java EE platform and introduces the audience to additional frameworks and concepts which do help by implementing all kinds of security requirements in Java EE based applications.

An Introductory session to Eclipse's successful language development environment. Xtext let's you build fully featured programming languages as well as simple domain specific languages (DSL). The first half of this session will give an overview of what Xtext can do for you. During the second half we will develop a DSL live and from scratch!
A well designed DSL (domain specific language) can be a huge productivity boost in many scenarios. Being it a special language for describing technical things like services or data structures or something more business oriented such as a DSL for describing complex financial products. But to make development of a custom language worthwile it must be easy to define and maintain such a DSL and of course the users must have assistance through tool support. Xtext provides a set of APIs and DSLs to develop such DSLs easily. It not only gives you a generated parser but supports the full stack of infrastruture that is needed. This also includes editor support for Eclipse, IntelliJ and Web as well as integration with the common build tools Maven, Gradle, and Ant. Xtext is an Eclipse.org project and as such available as open-source. The framework is actively developed, very mature and widely used in industry and research. In this session you will first get a brief introduction into the main concepts of Xtext. After that we will build a DSL from scratch.

In this session we'll talk about monad concept and build an instance of monad from scratch. There are hundreds of tutorial that explain monads, but we'll take a practical problem first approach. Building a monad, then explaining the laws of monads and why they exist is a good way to ogranise your mental picture of when monads are useful. Recognising monadic code and its properties is paramount in our era of coming to functional programming.
This code-heavy session demystifies what monads are and outlines reasons why you would even want to introduce them into your code. We’ll take a look at the traditional definition for monads and offer a corresponding type definition in Java. We’ve selected a sample Java 8 implementation of a ‘Promise’ monad, which represents the result of async computation to help us answer practical questions about monads. Also, we'll go over the Laws of Monads and show that you can have a proper monad in Java, if you are brave enough to allow the underlying platform change the rules a bit. PS. You won’t be penalised or ridiculed during this session for your (lack of) Haskell knowledge!

I will walk you through how to build your own retro handheld console that is powered by Java, runs on a Raspberry Pi, and is printed on a 3D printer.
In this session I will walk you through how to build your own retro handheld console that is powered by Java, runs on a Raspberry Pi, and is printed on a 3D printer. Some of the topics that we will cover along the journey include: • Hacking Java on the Raspberry Pi • Rigging input devices with Pi4J • Insane performance tuning on the JVM • Why your boss [or SO] needs to buy you a 3D printer! And of course your retro gaming mettle will be put to the test, so make sure to dust off your old 8 and 16 bit consoles to prepare. This presentation is about the most fun you can have while still legitimately calling this conference “work.” In fact, I will hopefully inspire you to do your own creative “work” leveraging Java and Raspberry Pi to hack the real world.

Brukertesting er et effektivt verktøy for å finne ut om man er på riktig vei med en løsning. Men hva kan vi lære av våre feil? Hva er det i løsningen din som brukeren sjelden forstår? Jeg deler min innsikt fra en drøss gjennomførte brukertester.
For å finne ut hva som kan forbedres i løsningen man utvikler er brukertesting utbredt. Både designere og utviklere har mange ganger vanskeligheter for å sette seg inn i brukerens situasjon og man ser seg gjerne litt blind på sin egen løsning. Etter å ha gjennomført en drøss med brukertester har jeg fått et visst innblikk i hva brukerne sliter med og ønsker å dele dette med dere! Målet med denne lyntalen er å gjøre dere oppmerksom på ulike fallgruver men nødvendigvis ikke tenker over og gi dere litt inspirasjon til å kanskje være med på neste brukertest? :)

Think your code is running? Think Again!
When we think about out application running we tend to think of lines of code following each other as the machine obeys our script, the reality is somewhat different. In this talk we'll have a look at the gap between the lines, where surprising amounts of time can be spent, some of the topics covered: * Placing the Java program on the stack: HW/OS/Process * Open to interpretation: from your code to assembly * When the JVM stops (and the promise of a "pause free JVM") * The pause button: Safepoints in your code * Object Reference accounting: Store and Load access barriers in your code

Kort introduksjon til Scala.js - nå kan du bruke Scala i både frontend og backend, og dele kode mellom de to!
Scala.js kompilerer scala-kode til JavaScript, og lar deg dermed skrive hele web-applikasjonen din i Scala (pluss litt HTML & CSS). Denne lyntalen gir deg en introduksjon til Scala.js og hvordan det funker i praksis. Vi viser et lite eksempel på hvordan et prosjekt kan være satt opp med bl.a. utvikler-roundtrip og deling av kode mellom frontend og backend. Versjon 0.6.0 av Scala.js kom i februar 2015, og var den første som ble annonsert som produksjonsklar. Kode man skriver nå vil fungere igjennom hele 0.6.x og 1.x-seriene. Dette er med andre ord det perfekte tidspunktet å sette seg inn i Scala.js!

Hva gjør du når du mistenker at webappen din har flere sikkerhetshull enn en gammel versjon av Struts? I denne lyntalen gir jeg en praktisk innføring i websikkerhet basert på erfaringer fra et prosjekt hos Skatteetaten. Litt om headere, litt om verktøy, og litt om hvordan man kan jobbe med sikkerhet uten å få hodepine.
Hva gjør du når du mistenker at webappen din har flere sikkerhetshull enn en gammel versjon av Struts? I denne lyntalen gir jeg en praktisk innføring i websikkerhet basert på erfaringer fra et prosjekt hos Skatteetaten. Jeg kommer til å touche innom følgende tema: - Hvordan tenke sikkerhet - Headerbruk - Informasjonsflyt - Kontekster - Noen verktøy Oppsummert håper jeg å levere en praktiskt tilnærming til sikkerhet som ikke skremmer, men som heller motiverer til å ta noen enkle grep. Man kan utrette mye uten å være ekspert!

Utvikler du løsninger uten UX-hjelp og mangler øye for design? Synes du løsningen din mangler noe, uten å helt klare å sette fingeren på hva det er?Jeg gir deg førstehjelp med 5 raske tips til en bedre brukeropplevelse.
Hvordan oppnå bedre brukeropplevelsen i løsningen din? Som interaksjonsdesigner jobber jeg tett med utviklere hver dag og har plukket med meg hva som oftest blir glemt eller mangler i løsningene. I denne lyntalen vil jeg vise de vanligste designfeilene og gi en innføring i hvordan man enkelt kan lage ryddigere, mer oversiktlige og brukervennlige løsninger.

In this talk we show mobile app developers how to deliver apps for iOS and Android faster while not compromising on the native user experience.
At RoboVM, we strongly believe that developers should be able to deliver the native user experience while reusing development skills across all platforms, including the backend, hence reducing development cost and time-to-market. In this talk we will introduce you to RoboVM and show you how to get started with cross-platform mobile app development in Java. We will demonstrate how to maximize code reuse between the iOS and Android versions of your app without compromising on the native user experience.

There are two problems that occur in every project: data conversion and character encoding. This talk will give you an understanding for what a character set is and what an encoding is (yes, these are not the same thing). We will debunk two myths and give you the ability to differentiate between encoding and rendering problems
Although everyone knows something about character encoding, it's a topic which most people don't delve deep into because it's not fancy enough. Most of us have a rough idea about it, pick an encoding which sounds good enough and hack luckily away at our code. Then, the code is opened by a different user using a different editor ... Everyone has had problems with characters all of a sudden looking like gobbledy gook and have found some solution to it. Or perhaps not? How many have seen JavaDoc headers an author tag where the "å" in "Håkon" looking like Donald Duck's swearing? Character sets and encoding are fundamental concepts of every software project you'll ever work on and having a better understanding of it will help you investigate, solve and even avoid encoding related problems in all parts and layers of your code. This talk will give you a fresh reminder of some of the things you already know and teach you a few new things so that next time you see a square, you don't look like a question mark.

For å få samlet inn kvartersmålinger fra 670.000 målepunkter, må vi ha godt samspill mellom et utall systemer både før, under og etter innsamlingen. Det er også ekstreme krav til ytelse og oppetid. Den gamle ESB'en med sin kanoniske datamodell leverte ikke. Løsningen viste seg å involvere Apache Kafka og en triple store.
Først tar vi deg med på hva AMS-prosjektet går ut på, og hvor de store utfordringene ligger. Så viser vi kontrastene mellom "Data Orientert Arkitektur” og “Service Orientert Arkitektur”: Dette er en helt annen måte å tenke på. Vi introduserer konseptene med kodeeksempler og visualiseringer. Vi viser hvordan alt spiller sammen i AMS, og hvilke “tricks” vi måtte bruke for å få ting til å fly fort nok. Vi kommer også inn på hvordan du kan bruke dette arkitekturparadigmet i dine prosjekter.

Hos Statens Pensjonskasse tas for tiden de første skrittene fra tradisjonelle leveranseløp med hoved- og delleveranser til en løskoblet modell med kontinuerlige utrullinger av delsystem og applikasjoner. I denne lyntalen får du et innblikk i den første delen av prosessen, samt at vi deler foreløpige utfordringer, strategier og tabber med andre som vil gå samme vei.
Etter Perform-prosjekt, et av Norges største smidigprosjekt, har SPKs systemforvaltning og nyutvikling videreført og foredlet den smidige arbeidsformen. Men utrulling av endringer til produksjon har fortsatt å følge en tradisjonell modell, med formelle leveranseløp og delt versjonering. Vi gjør nå grep for å øke leveransetakten til produksjon og tilrettelegge bedre for parallell utvikling. I skrivende stund nærmer vi oss halvveis, og lyntalen tar for seg de første etappene i ferden mot løpende leveranser og distribuert versjonering.

Vi går gjennom 5 Maven-plugins og ser på hvordan de kan forenkle din hverdag.
Til tross for en del konkurranse fra andre produkter, er Maven fortsatt godt og mye brukt i store og små prosjekter der ute. Vi ser på 5 plugins som kan gjøre din hverdag enklere.

Den generelle kodegeneratoren er like populær som Ebola og Byllepest. Men hva om du må migrere mengder gammel kode? Hva om du skriver en slags analysator og generator helt selv? En engangs, bruk-og-kast-generator for akkurat ett formål? Ditt eget formål? Kan du kalle det scriptet refactoring (kult) eller kodegenerering (ukult)? Uansett, stilt ansikt til ansikt med et reelt copy-paste-helvete så har jeg gitt det et forsøk!
Med noen fine fluent biblioteker sammen med Java8 lamda og annet snacks finner du ut om jeg endelig fikk oppleve kodegenereringens gode side eller om dette fortsatt er selvskading. Motivasjon Unngå fellene Hvordan Få hjelp av ditt IDE Trenger du egentlig produsere kompilerende kode? Kodeeksempler Resultat

Kom for denne lyntalen for en rask oversikt over Swift, Apples nye programmeringsspråk for iOS og OSX.
Etter å ha "tviholdt" på det noe obskure Objective-C i en årrekke, lanserte Apple et nytt multiparadigme språk for OS X og iOS utvikling på deres WWDC-konferanse i 2014. Språket heter Swift. Swift fikk raskt moment og klatret i løpet av få måneder høyt opp på popularitets-indekser. I april 2015 spurte Stack Overflow hvilke språk utviklere hadde brukt det siste året og hvilke av disse de helst ville jobbe med. 76% av de som hadde jobbet med Swift ønsket å jobbe videre med dette språket. I denne lyntalen går Tobias gjennom syntaks og konsepter i Swift:

Why do even proponents of statical typing pick on Java's type system? We will have a look at the most common criticisms and look at what exists “on the other side of the fence”. Does a more advanced type system really make the grass greener?
Proponents of dynamically typed languages often criticize type systems such as Java's, but – more puzzlingly – programmers advocating static type systems also regularly pick on Java for delivering too few benefits compared to the amount of work you – the programmer – put in by sprinkling noisy type declarations all over your code. What are the actual shortcomings of Java's type system, and how is it compared to languages with more advanced type systems such as Scala, F#, OCaml and Haskell? We will use the characteristics of Java's type system and its history as a guide to explore types in other languages. How can other languages get even more type safety – sometimes without having to use any type declarations at all? Is there a hidden cost somewhere? We will look at some scary-sounding concepts such as “generalized algebraic datatypes”, “higher-kinded types” and “higher-ranked polymorphism” and see if they really can be leveraged by us normal, non-wizard programmers for a tangible benefit.

WebRTC is one of the most substantial things to happen to cross-platform networking in later years. This talk gives you an introduction to WebRTC in native apps on Android, which will make your app capable of sending audio, video and data directly between peers on Android, iOS and browsers.
WebRTC allows you to do low-latency, peer to peer data transfer on all major platforms today. However, very few have yet to take advantage of that fact in their native apps. Transferring files over the local wifi between Android and a browser, creating the next video messaging platform, peer to peer multiplayer for your mobile game, or streaming huge chunks of sensory data from your IoT farm? Everything is easy with WebRTC. WebRTC is not only for browsers, and this talk will walk you through the basic concepts and show you how to get started, allowing you to build WebRTC capable native applications on Android for your next project.

Du hører kanskje favorittmusikken din på en av de store radiokanalene til daglig. Hadde det ikke vært kjekt å lage en egen online audio streamingstjeneste hvor du kan streame musikken din? I denne lyntalen skal jeg vise hvor enkelt di kan gjøre dette med kjent open source teknologi som SHOUTcast, MPD, MPC, JPlayer, AngularJS og OpenShift.
Det har blitt for mange musikktjenester på nettet. Favoritt musikken er vanskligere å finne. Er du av den typen som liker å bygge eget bibliotek av mp3 filer og ha det tilgjengelig fra et sted, så har du sikkert tenkt tanken å bygge egen radio kanal hvor du kan streame egen musikk til privat bruk. Denne lyntalen vil demonstrere hvor enkelt det er å oppnå dette målet. Jeg viser hvordan du kan hoste egen audio streamingstjeneste fra hhv din laptop, på en Raspberry Pi eller i skyene ved hjelp av kjent open source teknologi som SHOUTcast, MPD, MPC og OpenShift. Jeg forteller hvordan teknologiene fungerer og hvordan du kan spille av musikken fra din mobil telefon eller fra en nettleser ved å bruke f.eks. JPlayer.

Plugins! Plugins! Plugins! Gradle can do awesome things by itself but you get more bang when you combine your build with plugins. In this talk we'll show how to keep dependencies nice and tidy; update license headers ; discover all the possibilities of binary packages; find out binary incompatibilities between releases; write great documentation. These and more are up for grabs, come discover how to make the most of your Gradle build with less effort.
Plugins! Plugins! Plugins! Gradle can do awesome things by itself but you get more bang when you combine your build with plugins. In this talk we'll show how to keep dependencies nice and tidy with dependency-management and versions; update license headers with license; discover all the possibilities of binary packages with shadow, izpack and osspackage; find out binary incompatibilities between releases with clirr and japicmp; write great documentation with asciidoctor and jbake. These and more are up for grabs, come discover how to make the most of your Gradle build with less effort.

Attend this session if you want to quickly kickstart your understanding of the entire JavaScript ecosystem in the space of an hour!
While the Java language and Java EE platform are clearly defined and specified, that is not the case for the JavaScript ecosystem. It seems like whenever you wake up in the morning there's a new JavaScript framework that supersedes the one you've been getting comfortable with. Geertjan Wielenga has years of experience in the Java ecosystem and has in recent years gained experience with the new JavaScript frameworks, technologies, and tools. He is writing a book about it with the intention to help Java EE developers in integrating and using relevant parts of the JavaScript platform. Come to this interactive and code-driven session and learn how and when and under which circumstances it may be useful to combine the JavaScript world with Java EE applications, with an overview of the JavaScript landscape and insights on how to best use them within the context of the Java EE platform.

NetCom is deploying its next generation webshop and self-service portals which are modern HTML/JavaScript applications that run entirely in the browser. To support this type of architecture, we designed a set of REST APIs, to be exposed to the Internet, which needed to be secure, front-end developer friendly and fast.
Most of our existing APIs were SOAP/XML based, hard to use and hidden behind firewalls. Now we needed to make backend services available on the Internet such that they can be called directly from the browser. This gave us a chance to replace legacy APIs with new RESTful APIs which we could use both internally and expose publicly as well, potentially to third party developers. In this session we want to share our experience of building solid APIs using plain Java and Spring MVC. Do REST APIs really need to be hypermedia driven (HATEOAS) to be cool? How to solve API versioning in Spring MVC? Can we generate accurate documentation directly from the source ensuring it is always up to date? How can we ensure reliability? How to model asynchronous execution? If those challenging API design problems interest you, then this session is for you.

Based on practical experience of creating an application composed of multiple microservices, this talk is about the challenges developers and testers face when creating an application in this manner.
Traditional applications often deploy as a single unit, or as a client and a server. Splitting such an application into a significantly larger number of independent microservice processes creates new opportunities and some new challenges. This talk presents some of the issues developers and testers will be facing in such an architecture, and revisits some classic problems like build modularization and code design in context of the microservice paradigm. While everything is definitely not same/same, it's definitely not all different.

How we changed full release and deploy from half a day, to half an hour, to 8 minutes using Gradle.
Deployment pipelines is an excellent way of continous delivery. It gives a brilliant visibility to every step needed for an application to reach production. Alas, not always so easy to implement in real life. The presentation will teach you how we used Gradle together with Jenkins Build Pipeline plugin to drastically cut time on a full release and deploy of a large Maven Scala application. The presentation will show you some great benefits Gradle has over Maven and how to use these to make every build in Jenkins a potential release candidate.

Elasticsearch unites text search and statistical analysis into a powerful data analytics pack. This presentation shows how to put the product catalogue from Vinmonopolet into Elasticsearch using Logstash. Using Kibana for visual display and search, we will try to find the the best value for money beer, and the maximum amount of belgianness.
Elasticsearch, Logstash and Kibana come together as a great set of tools for gaining insights into data. The talk will go through the process from gathering data with Logstash, fixing data input, metadata enrichment using Kimonolabs and Untappd, investigating, exploring and creating visualizations in Kibana. Text search is used together with aggregation queries to drill down in data. The talk builds loosely upon this blog post: http://blog.comperiosearch.com/blog/2015/02/09/kibana-4-beer-analytics-engine/ Using Elasticsearch 2.0 beta and Kibana 4.2

If you want to learn about token-based stateless authentication in REST services, this session is for you. You will learn why stateless authentication simplifies your development and we will introduce you to Json Web Tokens (JWT). We are going to pay attention to best practices for handling JWT and what security details and possible tradeoffs you may take into consideration before start coding.
These days almost all projects uses some form of REST architecture to expose resources to their clients (browser, mobile, ...). One of most important points are to secure your endpoints; authenticate users and identify them inside the system. When we think of REST security we might think about protocols such as Oauth, ClientID or SAML. But the question is; do we need these protocols in all cases or could we get away with a simpler method that is still to be considered secure and attack proof? Come to this session to learn; how the Json Web Token(JWT) standard can simplify your authentication model while maintaining high security, and the advantages of using JWT from a developers point of view. This session is an introduction to JWT. No "master of the security universe" prerequisite required to benefit from this session.

Java 8 makes significant changes to the JVM memory model which are important to understand when running a high scale production environment. The first half of this session will cover the basics of Java memory and garbage collection including changes introduced by Java 8. The second half of this session will address the increased the consequence of running a production JVM inside a container environment which is an increasingly common scenario for micro service architectures involving docker.
This session will cover in details the concepts and tooling necessary to understand and manage Java 8 JVM in a productions environment. We will start with memory basics; the stack and the heap. The session will cover Java 8's Metaspace and changes in "perm". The information will be useful to developers as well as ops teams. The session will then dive into garbage collectors comparing differences between java 7 and java 8 for each of; oldParallelGC, CMS and G1. Memory, Thread and JMX tool demonstrations are included to help bring with comprehension. The last portion of the session we will cover details of linux memory and cpu management with cgroups. The session will highlight the difference between cpu sets and cpu shares with a focus on cpu shares (which is the default for most container technologies such as Docker). This session will walk through the consequences of deploying Java in a container and discuss how to manage it.

Your Continuous Integration system is well oiled and kicks in after every commit. Your code is compiled. Your tests are green. Are you ready to take your project to the next level? In this talk we move to Continuous Delivery. And we answer the hard questions. How do I deal with multiple environments? What about configuration? What is the best strategy for dealing with sessions and state? How do I handle database changes? How can I make sure I can release at any time? And how do I do this with Zero Downtime? This talk is for Developers and Architects who wish to take their projects to the next level with Continuous Delivery and Zero Downtime. We tackle the hard problems and the pitfalls you will have to deal with in your software architecture to make it a success. You will leave with a proven recipe for success that you'll be able to start applying immediately. No code, but concepts and battle-tested solutions you'll be able to apply for the rest of your career.
Your Continuous Integration system is well oiled and kicks in after every commit. Your code is compiled. Your tests are green. Are you ready to take your project to the next level? In this talk we move to Continuous Delivery. And we answer the hard questions. How do I deal with multiple environments? What about configuration? What is the best strategy for dealing with sessions and state? How do I handle database changes? How can I make sure I can release at any time? And how do I do this with Zero Downtime? This talk is for Developers and Architects who wish to take their projects to the next level with Continuous Delivery and Zero Downtime. We tackle the hard problems and the pitfalls you will have to deal with in your software architecture to make it a success. You will leave with a proven recipe for success that you'll be able to start applying immediately. No code, but concepts and battle-tested solutions you'll be able to apply for the rest of your career.

This presentation will give a hands on introduction to the many possibilities Elasticsearch offers in terms of lightning fast data analytics and aggregations, beyond traditional search.
This session will go through various case studies for statistical data analytics. The presentation will aim to demonstrate how we can navigate, aggregate and visualise structured and unstructured data for analytical purposes. We will look at case studies that go far beyond traditional full-text-search, and hopefully see that Elasticsearch can help us unlock the true value of our data.

Software has evolved so much that singlethreaded programs are rarely enough now. In this talks we'll cover several approaches to organising your concurrent Java code: from managing threads to actor frameworks, to software transactional memory.
Writing concurrent code that is also correct is unbelievably hard. Naturally, humanity has developed a number of approaches to handle concurrency in the code, starting from basic threads that follow the hardware way to do concurrency to higher level primitives like fibers and work-stealing solutions. But which approach is the best for you? In this session, we'll take a look at a simple concurrent problem and solve it using different ways to manage concurrency: threads, executors, actors, fibers, monadic code with completable futures. All these approaches are different from the simplicity, readability, configuration and management point of view. Some scenarios are better modelled with threads, while sometimes you're better off with actors. We'll discuss the benefits of each approach and figure out when it's worth pursuing in your project.

Have you been hearing buzzwords like "Containers", "Docker", "Kubernetes" but wondering what all the fuss is about? Come along to this introduction to containerization and find out why it just may be the greatest thing since sliced bread.
In this session I will give a brief introduction to containerization, demonstrate the fundamental tools used to isolate an application, and give a quick overview of the 'bigger picture' in the container ecosystem.

Learn how to develop event-driven microservices using domain models based on event sourcing.
Event sourcing persists each entity as a sequence of state changing event. An entity’s current state is derived by replaying the events. Event sourcing is a great way to implement event-driven micro services. When one service updates an entity, the new events are consumed by other services, which then update their own state. In this talk we describe how to implement business logic using a domain model that is based on event sourcing. You will learn how to write functional, immutable domain models in Scala. We will compare and contrast a hybrid OO/FP design with a purely functional approach. You will learn how Domain Driven Design concepts such as bounded contexts and aggregates fit in with event-driven microservices.

This talk will go through some of the challenges we've met as frontend developers at FINN.no while the platform below us is switching to a microservice architecture. It describes some of the architectural choices you have to make for frontend when you're splitting up your services, and suggests some things you can do with your services to make your frontend developers hate you a little less.
Microservices are rapidly developing as the new standard for building scalable and maintainable systems. This brings with it a new set of challenges for building frontends which now have to collate data from more sources than before without growing into the monoliths they mean to replace. There are many things you can do to make frontend development easier, ranging from your choice of protocol to how you plan to do authorization. I'll go through some of the pitfalls we've met at FINN.no, and look at some good and some bad solutions. I'll also try to give some advice on how to design your APIs in a way that will serve the needs of your users with the minimal amount of noise and confusion.

This talk is giving a good overview of the related Web tier enhancements planned for Java EE 8, namely Servlet 4.0 and HTTP/2 support, a brand-new MVC framework, support for SSE, etc.
With the introduction of Web Socket, JSON-P and the various enhancements on JAX-RS (e.g. JAX-RS Client API) HTML 5 support was one of the key themes of Java EE 7. Java EE 8 will continue to build on that and improve the support for writing and deploying HTML 5 based application. This session will look in details at some of the Web related enhancements planned in Java EE 8 such as - Servlet 4.0 and HTTP/2 support - Addition of a new Action-Based MVC framework - Support for SSE (Server-Sent Event) in JAX-RS - Improvements around JSON-P and the addition of a new JSON binding API, i.e. JSON-B. - etc. This session will be illustrated with some demos using the early Reference Implementation builds of some of those brand new APIs.

Most people are familiar with the concept of code coverage. Some people use it as a tool while developing, others use it as a metric to gauge where they are at. There is a better tool and a better metric.
Until a few years ago most people hadn't heard of mutation testing. Now it's in daily use by teams working in domains ranging from tractor sales, insurance and banking through to advanced bio tech and the control systems for the large hadron collider at CERN. In this workshop we'll introduce the concept of mutation testing and, through exercises, demonstrate how the open source http://pitest.org tool can be used to give valuable feedback during development.

Erfaringer og tips om hvordan man går fra en React nettsideapplikasjon til en React Native iOS-app.
React er blitt et mer og mer populært rammeverk i nettsideutvikling. I år har også React kommet i en native utgave for iOS og Android som utfordrer både hybrid-rammeverkene og de opprinnelige native språkene. Dette åpner for en helt ny verden for React-utviklere, men hvordan kan man overføre kompetansen og erfaringen fra React til React Native? Jeg har jobbet med både å utvikle en nettside i React og deretter lage en React Native iOS-app for samme prosjekt. I dette foredraget viser jeg hvordan man går fra React til React Native.

What is the fashion today within the Java world. Do we need it? How should we use it? What are the consequences?
With new projects we want to use the latest products and may wish to try out one of the latest frameworks. What are the consequences of such a decision? How are we going to implement this in existing code? What is the cost?

Event Sourcing er et konsept som vi stadig hører mer om i vår bransje. Men hva er Event Sourcing? Hvorfor skal vi drive med Event Sourcing? Og hva kan Event Sourcing hjelpe oss med?
Er du en av de som skriver "update table set column = X where column = Y"? SLUTT MED DET, det er livsfarlig! Alle våre system blir utsatt for hendelser. Lyntalen vil forklare konseptet Event Sourcing, og hvordan håndtering av hendelser kan ha betydelige forretningsmessige konsekvenser. Vi bør derfor vurdere hvilken strategi vi skal bruke når vi lagrer data i våre system.

Sitter du med en uggen følelse og bekymring for regresjonsfeil etter systemtest? Føler du at sjekklistene ikke dekker alt som skal til for å sikre kvaliteten? Er du i prosjekt der alt MÅ være riktig før det går i produksjon? Liker du i tillegg å la datamaskinen gjøre det den er laget for; Repetitive oppgaver? Da kan det hende vi har noen praktiske tips, triks og erfaringer du kan dra nytte av!
Gjennom flere prosjekter har vi sett behov for å automatisere testingen av systemene vi lager. Særlig når man splitter store systemer opp i mindre deler har ekle feil en tendens til å dukke opp sent og bli dyre. Vi går gjennom noen av våre erfaringer på området, med mål om å vise hvordan du kan automatisere både integrasjonstesting, generering av testdata og applikasjonsflyt. Temaer vi er innom: - Consumer-based testing - Sammenligningstesting av data før/etter endringer - Automatisert avsjekk av flyt gjennom et større system - Automatisert avsjekk av data systemer tilbyr - Automatisering av repterende oppgaver ifm. manuell testing Vi har dessverre ikke svaret på hvordan du slipper all manuell testing, men vi kan forhåpentligvis hjelpe deg med å kutte ned på tiden det tar. Og, muligens gi deg noen idéer til hvordan du kan skrive kode som tester for deg slik at du sover litt tryggere natten før prod.setting. Alt er basert på praktiske erfaringer fra våre prosjekter, men konseptene er forhåpentligvis så generelle at de bør være mulige å ta med seg ut i ditt eget prosjekt når hodepinen fra AweZone har gitt seg.

«There are three kinds of lies: lies, damned lies, and statistics.» Og hva annet er en meningsmåling enn en masse statistikk? La oss se på noen meningsmålinger for å se om vi kan si noe om hvem som kommer til å vinne valget på mandag.
Hvor finner jeg en bra oversikt over de siste meningsmålingene i Norge? Hva slags informasjon kan man trekke ut av dem, og hvordan kan man gjøre det? Og hvordan pleier det å gå galt når en journalist skriver om det, og hvor galt kan det bli? Statistikk rundt meningsmålinger er en av de mest ironiske delfagene innen matematikk: de interessante, opplagte konklusjonene fra råtallene pleier å være feil, men så snart de opplagte konklusjonene begynner å bli sanne er de ikke lenger så interessante. Men det er gøy å leke med dette, og man oppdager fort at Small Data kan fort føre til Really Big Numbers. Bonusmateriale: en kvalifisert gjetning for hvem som kommer til å vinne valget i Oslo.

Ever wanted to try implemeting a programming language from scratch? Doing so can be an educational experience, and it's much easier than you might think. We will guide you through the hoops of creating a small, but neat, programming language.
The workshop will guide you through the process of creating your language using a hands-on TDD approach. By the end of the workshop you will be the proud author of a programming language, and will hopefully have a better understanding of programming languages. The goal is for you to make a relatively simple language, with the following features: a handful of datatypes (integers, booleans, and symbols), variables, and first class functions (with lexical scoping). We plan to provide the test suits in both Python and Java, so you are free to choose which one you prefer. For more practical info, visit http://diy-lisp.com.

Use git pull-requests as review tools to break the knowledge silos that develops in a team of developers
In theory, all team members in SCRUM and Kanban should be almost equal in their knowledge of a given product. In reality, you get silos of knowledge, where certain team members are experts on certain part of the program, and which the team is dependent on to work on that part. I want to show that using tools like git pull-requests, you can make code reviews a part that not only enhances the code quality but also breaks these silos by spreading the knowledge around the team.

If you are ever asked to convert, process and scale millions of real-world images using Java it will be a painful experience - at least it was for me. I came across unexpected problems ranging from CMYK color models, alpha-channel handling, multi-page TIFF, image compression algorithms, setting DPIs, PDF preview generation, decompression bombs to efficient image scaling. In hindsight I wished there was some single resource of information to guide me through my problems - and this is exactly the reason for this presentation. It provides real-life experience in replacing an ImageMagick/JMagick image conversion & scaling with a pure Java implementation covering Apache PDFBox, Java Advanced Imaging (JAI), TwelveMonkeys ImageIO plugins, Sanselan (aka Commons Imaging) and different Java-based image-scaling libraries.
Image processing in Java, using ImageIO & Java Advanced Imaging API (JAI) can seem a simple task when converting only few images. It becomes increasingly difficult when handling millions of user-supplied images and image data found in "the wild", due to terms like alpha-channels, Exif, TIFF support, CMYK, ICC color profiles, JPEG compression flavours, decompression bombs and performance considerations. And, surprisingly, information on how to solve and overcome many of these issues were hard to find. This presentation discusses the problems encountered when replacing a legacy ImageMagick-based solution for creating image previews and thumbnails with a Java-based solution using ImageIO, JAI & Apache PDFBox, introduces the TwelveMonkeys ImageIO library and shows how image processing in Java can be fun again.

Immutable data structures will help you regain your sanity when programming - even in JavaScript! In this talk I will explain what immutability is, what it's good for, and how to effectively put it to use in JavaScript. We will see how immutability can truly help reduce complexity in the UI layer, and even improve performance while we're at it. Immutability goes hand in hand with functional programming, but it doesn't have to - no matter what your pereferred programming paradigm is, immutability will improve your code. If reducing complexity is your cup of tea, this talk is for you.
While the JavaScript standardization committee is coming up with APIs to observe mutations (Object.observe) in order to help improve UI rendering performance, the community around React and ClojureScript has turned to immutability to reduce the problem to managing a single reference. The result is unprecedented performance AND a greatly simplified programming model. In this talk I will walk the audience through what immutable data are, why they reduce complexity, how they can aid in improving performance (in spite of worsening performance at a macro level) and most importantly: how to put immutability to work in JavaScript in the browser.

Are you developing applications that communicate over a network? Of course you are! This talk will take you through all the ways you can build fault-tolerant applications and how, once you get your team in the mindset that everything will eventually fail, dealing with the failures gracefully is no more work than building fragile applications. A big emphasis of this talk is how to re-create issues often only found in production in development and test environments, such as slow networks and lost packets.
So you want to build fault tolerant systems? A big emphasis of this talk is how to re-create issues often only found in production in development and test environments, such as slow networks and lost packets. The topics covered will be: - What to do when one of the dependencies fails to respond in time - When to use network level time outs vs application level timeouts - What to monitor and how to monitor it, e.g connection pools, thread pools, queue sizes, latency - How to test for when the network is slow or saturated - How to test for when traffic is lost in transit - How to train your stakeholders to expect failure and get them to agree to fallbacks meaning they can choose availability over other requirements - When to use automated circuit breakers vs manual kill switches - Tips, hints and tricks for doing all of the above in Java The topics covered are especially relevant if your application has a lot of dependencies that it communicates with over a network i.e. microservices. It is even more applicable if your application is deployed to an environment which is prone to failure e.g. a "cloud". With supporting powerpoint slides, I'll cover the theory and motivation behind moving to a more distributed architecture and then go through the pitfalls and the strategies for improving fault-tolerance, backed up with real examples from the system I built at BSkyB.

Java 8 is finally here giving us access to a variety of long awaited new features and functionalities. Lambda expressions and Stream API has empowered Java in areas that are of great relevance to Big Data, providing an expressive language to operate over complex data structures, making the transformation and analysis of data more convenient, scalable and efficient. In this hands-on session, we will demonstrate how Java 8 Streams programming model in conjunctions with lambdas can be realized in an extensible set of distributed compute engines such as Spark, Tez, Flink etc., giving developer a unified programming model who's core features are part of the JDK itself.
Java 8 is finally here giving us access to a variety of long awaited new features and functionalities. Lambda expressions and Stream API has empowered Java in areas that are of great relevance to Big Data, providing an expressive language to operate over complex data structures, making the transformation and analysis of data more convenient, scalable and efficient. In this hands-on session, we will demonstrate how Java 8 Streams programming model in conjunctions with lambdas can be realized in an extensible set of distributed compute engines such as Spark, Tez, Flink etc., giving developer a unified programming model who's core features are part of the JDK itself.

What do you need to know about if you want (or more likely are forced) to work with front end development these days? In this presentation I will give an introduction and an overview of the modern web developers toolbox.
The world has changed much over the last ten years. Back in 2008 you either used PHP, CSS and JavaScript or you would use Java with JSP or JSF. In the Java world, front-end was considered easy to learn but difficult to get right. It was just something you hacked and got working - like frosting on a cake. Today the world is quite different. Now you use bundlers, test frameworks, linters, transpilers, minification, preprocessors, automation, dependency management. Come and learn why these tools are part of a modern web developer toolbox. Discover that front end has become a rich, professional and complex industry.

The classes of the Java Collections Framework belong to the most used part of the JDK. But can the offered list implementations really be used for all purposes? The most used class ArrayList has not only a minimalistic API but also serious performance weaknesses. The first part of the session therefore introduces alternative implementations which excel in all kind of uses. In the second part, key collections are presented as toolbox to increase not only application but also development performance.
The first part of the session introduces collections which addresses the shortcomings of the JDK list implementation. - GapList is a drop-in replacement for ArrayList which offers efficient access per index and efficient adding/removing at begin/end of the list at the same time. Further performance improvement is realized through exploiting the locality of reference. - BigList is specially designed to handle real large collections (where large means that it still fits into the heap). It stores data in distinct blocks which are maintained in a specialized tree structure and uses copy-on-write functionality to efficiently copy list of all sizes. It is shown how these classes are implemented in detail and benchmarks prove that they outperform other known implementations regarding performance and memory usage. The second part of the session introduces key collections. They add the functionality of keys and constraints to Java collections as known from relational databases. This unique approach allows to define concise data models with just a few lines of code which boosts not only application but also development performance.

En av de største endringene som kommer med Java 9 er Project Jigsaw. Project Jigsaw har som mål å modularisere JDK-en ved å introdusere et skalerbart modulsystem som gjør det mulig å definere eksplisitte avhengigheter mellom moduler, samt kunne definere hvilke deler av en modul som er private og offentlige. Målet er å gjøre det enklere å kjøre Java-programmer på små, integrerte enheter, forenkle vedlikehold, forbedre sikkerheten, øke ytelsen, og gjøre det enklere å utvikle og forvalte biblioteker og applikasjoner. Lyntalen går gjennom motivasjonen og historien til Project Jigsaw, status på prosjektet så langt, og ikke minst hvordan det vil påvirke oss Java-utviklere.
Project Jigsaw var egentlig tiltenkt Java 8, men ble utsatt til Java 9 for å unngå å forsinke Java 8 mer enn nødvendig. Nå er Project Jigsaw planlagt å bli en del av Java 9, men hvordan vil det påvirke oss? JDK-en er i dag på mange måter en stor monolitt. I Java 8 ble det innført en rekke kompakte profiler for å gjøre det enklere å kjøre Java-programmer på integrerte enheter, men det er fortsatt et stykke igjen for å få ned størrelsen på disse kompakte profilene. I tillegg er det mye Java-kode som har direkte avhengigheter til interne Java API-er, noe som skaper utfordringer for å utvikle og vedlikeholde Java-plattformen. I stedet for en monolitt er det ønskelig å ha moduler hvor man klart ser hvilke moduler som er avhengig av hverandre, samt metoder for å kunne gjøre det umulig å bruke kode i en modul som aldri var tenkt eksponert. I denne lyntalen vil vi gå gjennom motivasjonen og historien til Project Jigsaw og status på prosjektet så langt. Hvordan skal modulene bygges opp, og hvordan vil de fungere? I tillegg vil vi gå gjennom nye verktøy som tilbys av JDK-en for bygging av applikasjoner og biblioteker med det nye modulsystemet.

Systemdokumentasjon er en God Ting™ men vekker sjelden stor begeistring hos de som skal skrive den. Denne presentasjonen belyser temaet systemdokumentasjon og hvordan den kan håndteres på en utviklervennlig måte og publiseres på en leservennlig måte med Markdown.
Systemdokumentasjon er egentlig en nødvendighet men vekker sjelden stor begeistring hos de som skal skrive den. Det er ikke bare fordi det er morsommere å skrive kode, men også fordi det kan være utfordrende å vite hva dokumentasjonen skal inneholde, hvor mye som er nok, og hvordan den skal håndteres og publiseres. Det er enklere å fokusere på innholdet når infrastruktur og verktøy er forfattervennlige og resultatet brukervennlig. Denne presentasjonen ser nærmere på systemdokumentasjon og Markdown, som ser ut til å ha etablert seg som det foretrukne formatet. Asciidoctor og dens tool-chain er implementasjonen brukt i foredraget.

Dynamic languages are all the hype these days. In this context, Java - a strictly typed language - can sometimes appear to be overly restrictive. However, using runtime code generation, it is possible to avoid Java's strict type system when it seems necessary and preserve it when types help us to avoid programming errors.
While Java's strict type system is a great help for avoiding programming errors, it also takes away some of the flexibility that developers appreciate when using dynamic languages. By using runtime code generation, it is possible to bring back some of this flexibility back to the Java virtual machine. For this reason, runtime code generation is used by many state-of-the-art Java frameworks for implementing POJO-centric APIs but it also opens the door for assembling more modular applications. This presentation offers an introduction to the complex of runtime code generation and its use on the Java platform. Furthermore, it discusses the up- and downsides of several code generation libraries such as ASM, Javassist, cglib and Byte Buddy.

"The Monoliths days are numbered", so the saying goes. And building Microservices for the Cloud is easy, right? Are Microservices really something new and different, or is it just SOA as it was intended to be? And if so, can we manage to avoid the traps of yet another failed SOA? This talk is about distributed computing, why it matters, and why you need to care when developing your systems this way. Come to hear about what you should harness, what you should fear, and learn about the anti-patterns that are beginning to emerge that deserve their own special place in hell.
Microservices is the new popular kid on the block. Crowd pleaser at many conferences. With popular poster childs like Netflix and Amazon it seems to be the killer approach to 21st century architectures, right? But is this stuff only for Hollywood Coders pioneering on the bleeding edge of our profession? Or is this stuff ready to be used for your projects and your customers? This presentation is a warning. Microservices don't fix broken organizations and distributed computing is still hard. I will go over the benefits, but more so the pitfalls, of using a Microservices based architecture. What impact does it have on your applications, on dealing with scale and failures and how do you prevent your systems landscape from becoming an unmaintainable nightmare.

Learn about the role of product management, what the expectations are for the role, and what a 'typical' day looks like in the role of a product manager
Think that you can make everyone happy, all of the time? Looking for a challenge that covers everything from design to business to code? Just wondering what the heck it is that a product manager is supposed to do for the team? Come learn what this dark art covers and what the different aspects are of being a success in this position. Using the Martin Eriksson definition of a product manager, we'll dive into each of the competency areas - tech, business, and design - that a product manager needs to master. By reviewing a combination of industry and personal stories, we'll evaluate these different areas for the types of hard skills (e.g. juggling chainsaw requirements, negotiating wild goose chases, expectation lion taming...) needed for flourishing in this role. Finally, we'll take a look at how these are used in a day to day environment in trying to please the varying stakeholders that a product manager encounters. Covering the range from expectation management of the business to reading through API docs to understand the limitations of third party services being pitched to developers, this section takes a look at who wants what on a regular basis. Come for the magic of product management, stay for the reality tv show of getting things built!

Denne workshopen gir deg en fyldig og hands-on innføring i Facebooks utrolig populære frontendrammeverk, React. Vi viser deg hvorfor dette har blitt et så populært og hvordan vi bruker det for å lage komplekse brukergrensesnitt med svært god ytelse.
Vi starter med en kort presentasjon om hvorfor dette er en ny, spennende og ikke minst effektiv måte å lage webapplikasjoner på. Deretter går vi raskere mulig over i den praktiske delen, hvor deltagerne selv skal kode React. Kodebiten er todelt - vi skal først lære grunnprinsippene gjennom å gjøre noen konkrete og frittstående oppgaver som demonstrere disse. Når grunnforståelsen så er på plass tar vi det et steg videre og leker med Twitter-APIet for å lage en svært interaktiv og leken overvåkningsapp! Etter denne dagen vil du ha god forståelse for hvordan React virker og sannsynligvis ha kjent på kroppen hvor _gøy_ det er å skrive apps på denne måten.

Imagine a culture where the input of the whole organization turns an individual idea into a user story in just a couple of hours, where everybody's goal is to write great code, make the customer’s job easier, and where you work on projects you love instead of loathe. Key ingredients include quarterly hackathons, bringing autonomous teams together and ‘openness by default.’
A great coding culture concentrates on making developers productive and happy by removing unnecessary overhead, bringing autonomous teams together, helping the individual programmer to innovate, and raising awareness among developers about how to create better code. I will talk about how to establish and foster a strong engineering-focused culture that scales from a small team to a huge organization with hundreds of developers. I'll give lots of examples from our experience at Atlassian to show that once you're working in a great coding culture, you won't want to work anywhere else.

Et lite innblikk i utvikling av apper for smartklokker. Lyntalen baseres på Samsungs rekke av klokker med operativsystemet Tizen der apper skrives i JavaScript.
Dette er en liten presentasjon av hvordan man kan lage apper for smartklokker, og hvilke utfordringer og muligheter vi står ovenfor i en relativt ny sjanger.

A high level overview of the BigData technologies, and their current state. What is Hadoop, what problems it tries to solve, how to approach BigData technologies if you've never done that before, and what else is there other in the Hadoop ecosystem.
Elephants (named "Hadoop" after a toy), bees and hives, pigs, ELKs, rabbits and one ZooKeeper. You can find them in a zoo, or you are just a software developer trying to make sense out of data using technologies with weird names. This session will be a guided tour of the BigData kingdom. We will explore various challenges one has to face when handling large volumes of data, and learn about various tools with funny names which were built to help in the process. Equipped with real-world examples and use-cases, by the end of this session BigData should stop being a buzzword to you.

Digitalisering og API-revolusjonen gjør at stadig flere snakker om API. Men med så mange som snakker om det er det fort gjort at man egentlig snakker om forskjellige ting. Lyntalen vil raskt presentere hvilke API diskusjoner som det er vanligst å ha, og hva som er sentralt ved de ulike.
Digitalisering og API-revolusjonen gjør at stadig flere snakker om API. Men når stadig flere snakker om en ting øker sannsynligheten for misforståelser. Så når du snakker om API, snakker du om det fra en forretnings-dimensjon, arkitektur-dimensjon eller teknologi-dimensjon? Og hva er egentlig forskjellen på disse?

Diving into the wonders of Angular 2 and writing elegant TypeScript code.
When TypeScript was first announced 3 years ago, it was met with skepticism within the JavaScript community. Questions such as; "Do we really need this thing by Microsoft?" were raised, and according to statistics at the time the JavaScript superset was not used by many front-end developers. This would take a dramatic 360 degree turn. Fast forward to the present time. Google's Angular team announces that their AtScript language has been TypeScript all along and the much anticipated Angular 2, will be officially built on TypeScript. The collaboration between the Angular and TypeScript teams has never been this strong! Join me in this session where will dive into the new Angular 2 and write elegant TypeScript code.

TinkerForge is a very simple, easy-to-handle modular electronic system. Depending on the application, a system of sensor, wireless and motor control elements can be built in a modular way and programmed with a few lines of code. No soldering iron is needed. Both the hardware and the software are open source. After a brief overview of the available sensors and actuators, we will quickly start with the actual programming. Together, we will explore different applications, architectures, and the combination of TinkerForge with Java. Using sensors, actuators and some other elements, we will take the first steps and delve into the practical world of IoT with Java 8 and TinkerForge.
TinkerForge is a very simple, easy-to-handle modular electronic system. Depending on the application, a system of sensor, wireless and motor control elements can be built in a modular way and programmed with a few lines of code. No soldering iron is needed. Both the hardware and the software are open source. After a brief overview of the available sensors and actuators, we will quickly start with the actual programming. Together, we will explore different applications, architectures, and the combination of TinkerForge with Java. Using sensors, actuators and some other elements, we will take the first steps and delve into the practical world of IoT with Java 8 and TinkerForge. -What title would you like to use for the events? Industrial Prototyping with Java 8 and TinkerForge -Why should people attend the events (high level over view of what the event will cover, what they will learn and why it is relevant) See answer below. And because it is going to be awesome. ;-)  -What subjects will be covered and how will you present the information (giving ppt. presentation, doing live coding, using previous examples etc) TinkerForge is a very simple, easy-to-handle modular electronic system. Depending on the application, a system of sensor, wireless and motor control elements can be built in a modular way and programmed with a few lines of code. No soldering iron is needed. Both the hardware and the software are open source.  After a brief overview of the available sensors and actuators, we will quickly start with the actual programming. Together, we will explore different applications, architectures, and the combination of TinkerForge with Java. Using sensors, actuators and some other elements, we will take the first steps and delve into the practical world of IoT with Java 8 and TinkerForge.  What do I need to bring? - A laptop on which you can install software - Java 8 (JDK) installed and running - A JDK 8 capable IDE Optionally, you can of course also bring your own Raspberry Pi or the like. Goals: - addressing sensors, storing data and display them using JavaFX. - parallel processing of sensor data streams using Java 8 Streams - connecting a Rasperry Pi - controlling an LCD display - using touch elements

Alright, so maybe "bootiful" won't ever work, but I tried, and it was worth it too because you're reading this. Spring Boot, the new convention-over-configuration centric framework from the Spring team at Pivotal, marries Spring's flexibility with conventional, common sense defaults to make application development not just fly, but pleasant! Join Spring developer advocate Josh Long @starbuxman for a look at what Spring Boot is, why it's turning heads, why you should consider it for your next application (REST, web, batch, big-data, integration, whatever!) and how to get started.
Alright, so maybe "bootiful" won't ever work, but I tried, and it was worth it too because you're reading this. Spring Boot, the new convention-over-configuration centric framework from the Spring team at Pivotal, marries Spring's flexibility with conventional, common sense defaults to make application development not just fly, but pleasant! Join Spring developer advocate Josh Long @starbuxman for a look at what Spring Boot is, why it's turning heads, why you should consider it for your next application (REST, web, batch, big-data, integration, whatever!) and how to get started. We'll do a "Boot"-camp and introduce Boot, and then introduce some of the new features since last year including support for JAX-RS, JTA and the embedded Undertow engine from Wildfly.

The three-act play, the given–when–then BDD triptych, the three steps of the Feynman problem-solving algorithm... a surprising number of things appear to come in threes. This talk walks through — and has some fun with — a number of triples that affect and are found in software development.
The three-act play, the given–when–then BDD triptych, the three steps of the Feynman problem-solving algorithm... a surprising number of things appear to come in threes. This talk walks through — and has some fun with — a number of triples that affect and are found in software development.

Bli med vår reise fra noen få monolitter med sjeldne og lite regelmessige deploys, over til stadig mindre applikasjoner som deployes flere ganger om dagen. Vi har vært gjennom en reise der vi på godt og vondt har fått lære fordelene og ulempene med å slå sammen ansvaret for drift og utvikling. Vi vil fortelle om hvilke (dels smertefulle!) lekser vi har lært på veien, og hvordan vi fikk organisasjonen rundt oss med på dette – til den grad at finansieringen av DevOps ble gjort av salgsavdelingen heller enn IT.
Hør historien om hvordan vi utviklet oss fra et lite team som kastet applikasjoner over veggen til driftsavdelingen uten den minste forståelse for hva slags miljø den landet i, over til de fagre engene med DevOps og micro services. Dette har på ingen måte vært en smertefri reise, og vi har lyst til å dele både det gode og det onde – og ikke minst de lærdommene vi har gjort oss på veien. Så gøy som vi enn synes det er, har vi ikke tenkt å grave oss ned i teknologien og vise fram alt det kule vi har lagd. Vi vil heller snakke om hvilke feil vi har gjort, hvilke smerter vi har kjent på og hvilke løsninger vi har endt opp med. Målet vårt er at du går ut av presentasjonen inspirert og full av gode ideer om hvordan du kan ta din egen arkitektur enda et steg videre. Og at du kanskje kan unngå å gjøre noen av de feilene vi har gjort.

Clojure og Scala er ikke lenger nye språk. Denne presentasjonen tar for seg hvordan det faktisk er å jobbe med dem, sammenlignet med Java (8).
Clojure og Scala er ikke lenger nye språk, og vi er også forbi tiden der man var usikre på om disse språkene ville overleve. Flere teams i Norge velger nå alternative språk til Java, selv når Java 8 har kommet ut. Jeg har vært så heldig å være på flere sånne teams. Jeg har erfaring med både Clojure og Scala i produksjon. I denne presentasjonen vil jeg gi innsikt i mine erfaringer med språkene. Jeg vil jeg fokusere på hvordan disse språkene forskjellige, men kanskje like interessant, er hvordan de er like. I tillegg vil jeg gløtte litt på hvordan Java nærmer seg disse språkene, med de funksjonelle tilleggene som kom med Java 8. Om du tror jeg kommer til å kåre en “vinner” så blir du nok skuffet. Målet mitt er å gi deg nok informasjon til kunne velge de riktige språket for ditt team, Scala, Clojure, eller kanskje til og med Java 8.

Vi hører ofte om nettsider som har blitt kompromittert og har fått stjålet brukerinformasjon. Dette fører til et ønske om at nettsider ikke skal behøve og ta vare på disse hemmelighetene for oss. Det er også økt fokus på at man ikke bør ha samme brukernavn og passord på flere sider. Her kommer SQRL inn som et alternativ.
SQRL som uttales squirrel er et foreslått alternativ til brukernavn og passord og har potensiale til å revolusjonere logg inn og autentisering. Det eliminerer mange problemer som finnes ved tradisjonell innlogging. Vi vil f.eks. ha en unik identitet per nettside vi logger inn på og vi trenger bare huske et passord som en passord manager.

«All logikken må ligge i Java-laget fordi frontend ikke skalerer» «Applikasjoner større enn en «to do»-app trenger et ordentlig web-rammeverk, som JSF». Om du er enig med disse utsagnene, er det på tide å ta et oppgjør med hvordan du bygger klienten din.
Frontend har gått fra å være et nødvendig onde til å bli en egen fagdisiplin. Klientene har blitt tykkere, og logikk som tidligere ble pakket inn i en Action Delegate lever nå fullstendig i frontend-laget. Med begrenset tooling og ingen etablert standard kan frontend-koden vokse seg til et uhåndterlig vesen som til slutt kollapser av sin egen tyngde. I gamledager kunne vi kaste alt og starte på nytt, men det går ikke lenger. I dette foredraget skal vi se på hvordan bygge applikasjoner som kan skaleres og videreutvikles i årene fremover – hvordan unngå en monolittisk struktur, og hvordan laste koden i klienten på best mulig måte.

This talk presents a number of conceptual and technical challenges that we discovered while building JRebel. JRebel performs class reloading and framework integrations which the JVM doesn't provide out the box. This session demystifies the magic.
This talk presents a number of conceptual and technical challenges that we discovered while building JRebel. At first, the JVM wasn't designed for live updates, so we will talk about the engine that mitigates the problem. Secondly, the diversity of Java ecosystem, created by the variety of application servers, the frameworks and tools, makes it challenging in creating a generic solution that would fit the majority of developers. We will see, how Java platform itself allows us to develop a solution by applying bytecode instrumentation mechanism. JRebel does live code reloading to ensure that the developer can keep instantly alternating between the developing environment and the web browser, to save wasted time and increase the productivity flow.

As mobile oriented standards for the web emerge, you can in an increasing number of situations can replace a native mobile app with a web application. With Chrome 42, Google has closed the two most significant remaining gaps. In this hands-on talk, we will examine some of the web standards which aim to make more mobile oriented web applications and how you can create a web mobile application today.
Many people are surprised by the number of features that are normally associated with mobile development which can be accessed in a mobile web application or indeed in a desktop web application. For a long time, camera and location services have been available. With new standards that have been released to production in 2015, two of the most significant improvements have also been made available to a huge number of browsers: The ability to push notifications to your application even when it's not running and the ability to create a wallpaper shortcut to the web application. In this practically oriented talk, we will show the technical details of making web applications which feels like a native application.

Enhetstesting og fokuset på at små deler skal gjøre sin oppgave riktig har lenge vært viktig for oss som skriver programvare. Men om man glemmer at alle disse mindre enhetene må spille sammen for å gi verdi, kan man fort lage små feil i skjøtene. Denne lyntalen argumenterer for å lage flere tester som går gjennom de ulike lagene i systemet.
Ønsket om små, isolerte tester kan av og til ta litt overhånd. Ved å bytte ut alle avhengigheter med mock-er kan man både skjule feil i koblingene og sideeffekter i andre klasser. Denne talen tar for seg det den kaller for helhetstesting. Ved å teste fra et kall mot en servlet helt ned til en inmemdb og opp igjen, så kan man luke ut flere feil, og føle seg tryggere når man bytter ut deler av systemet. Helhetstesting handler om å lage slike tester hvor de fleste koblinger er reelle, mens man har de konvensjonelle enhetstestene på mindre deler hvor det ikke er sideeffekter.

This session will provide the opportunity to use the new features of JDK8, Lambdas and Streams in a practical class. There will be a series of exercises, gradually increasing in difficulty, which will show you how to use a functional style of programming with JDK8.
Lambda expressions and the Streams API provide, for the first time in Java, a way to write functional style code. Learning to use these features effectively requires developers to think differently, moving away from external loops and explicit state to using a pipeline of stateless operations. This hands-on lab will provide a series of exercises that will lead you through many of the new features and APIs in JDK8 that use these exciting new features. The exercises gradually increase in complexity. See how far you get before the time runs out!

With modularity coming to the core Java platform in Java 9, are all our modularity needs fulfilled, or does it still make sense to use something like OSGi? In this talk you will learn how Jigsaw helps modularity, and in what cases it might fall short.
Java 9 will provide a module-system, called Jigsaw. Besides modularising the JDK itself, Java developers can build more modular applications with Jigsaw. Modularity and Java go back way longer, though. OSGi, the de facto standard for modularity in Java has been around since 2000. Adoption is increasing in recent years. A modular architecture has many advantages, such as increased decoupling resulting in more flexibility. In that sense, native support for Java modularity is very welcome. The big question now is: does Java 9 provide everything you need to build truly modular applications? Since Java 9 needs to maintain backwards compatibility, some compromises need to be made while enforcing module boundaries. This talk discusses what you really need to build modular applications. We'll investigate which requirements are met (or not) by both module systems. You'll see that both Jigsaw and OSGi provided pieces of the modularity puzzle. Also, you'll learn whether having an additional modular runtime such as OSGi on top of Java 9 still makes sense.

Braintree is the payment provider behind companies like Uber, AirBnB and Github. This talk dives into why Clojure was chosen to handle real-time data processing within a mostly Ruby stack.
Braintree, part of PayPal, is a full-stack payments platform offering a variety of services making it easy to accept payments from many methods across many platforms. Mostly a Ruby shop, this talk details how and why Clojure was chosen to implement the real-time data pipeline that keeps transaction data at the tip of merchants fingertips. The talk will cover the engineering challenge posed, the design choices that lead to the selection of Clojure (on top of Kafka) as implementation language, challenges faced in creating the system, and finally, how the choice of Clojure for this application has influenced future projects within Braintree.

This talk introduces Easy Batch: a lightweight framework to do batch processing with Java easily
Batch processing with Java has been dominated for many years by the popular Spring Batch framework. In Java EE 7, a new Batch API (JSR352), heavily inspired by Spring Batch's concepts, has been introduced. Today, Spring Batch and the Java EE Batch API are the main solutions to develop batch applications in Java. Both solutions are robust and powerful. But with power comes complexity and many people are complaining about the complexity, overhead and learning curve that these frameworks introduce. The main motivation of Easy Batch is to provide an alternative solution that would be lightweight, easy to learn and use. The idea behind the framework is to take care of all the boilerplate code that is needed to process data in batch mode (data filtering, parsing, mapping to domain objects, validation, etc..) while letting the developer focus on the business logic of his application. Using Easy Batch tremendously reduces the application's code (and hence time to market) and makes it more readable, reusable and maintainable.

In this age when parallelism matters, being able to write proper concurrent code is paramount. While Java hides lots of implementation details by its 'Write Once, Run Anywhere' motto, all abstractions will eventually leak. When they do, you will have to go deeper and see how that thing actually works.
In this talk, we will go deeper into the HotSpot sources and beyond to realize why JMM is the way it is and how to wield it for greater results. We shall take a simple pience of multi-threaded code, and go all the way down to the level of CPU instructions to see what really happens.

De siste to årene har vi jobbet med å bryte opp en massiv monolittisk portal bestående av SpareBank 1 sin privatnettbank, bedriftsnettbank og cms-løsning https://www.sparebank1.no. Monolitten er blitt til en rekke samarbeidende webapplikasjoner som er en enhetlig løsning, men som har mange av egenskapene til en mikroservicearkitektur når det gjelder kohesjon og kobling. Veien fram hit er belagt med både suksesser, fiaskoer og ikke minst mye læring. Kom og bli med når vi deler dette med dere.
SpareBank 1 sin portal begynte å nå smertegrensen når det gjaldt koblinger og gamle rammeverk. Samtidig var portalen en braksuksess. Vi hadde levert en release i måneden i tre år. Både organsiasjon og prosessene våre var fintunet gjennom denne tiden til å kunne levere med fast takt på en måned. Vi fikk smertelig erfare at å rokke på prosesser som i utgangspunktet føles å fungere godt, må gjøres med adskillig mer kløkt og omhu enn det vi klarte ved første forsøk. Foredraget går gjennom de viktigste læringspunktene vi har hatt på veien fra en monolittisk til en distribuert applikasjonsarkitektur, med fokus både på teknologi-, prosess- og organiasjonsendringene vi har gjort.

Elsker du å programmere, men blir frustert av å lese andres kode? Hvordan er det å lese din egen kode tre måneder etter du skrev den? Noe mystisk skjer i tidsperioden fra kode blir skrevet og til den blir lest, her skal vi prøve vi å finne ut hva.
Syntaks er for maskiner, ord for mennesker, og kode må tilfredsstille begge. Det er lett å glemme at når ditt eget nøye utformede kodeverk havner i andres hender, har det sluttet å være et problem og blitt til en løsning. En del av din jobb som utvikler er å gjøre det klinkende klart overfor leseren din hvorfor du har valgt én løsning over en annen. Og dette er ikke helt lett når hjernen din motarbeider deg. Denne lyntalen vil ved et kjapt dykk i kognitiv psykologi ta for seg hvorfor det å lese andres kode er så fantastisk vanskelig, og hvorfor du gjør lurt i å finne frem forfatteren du har i magen.

Denne presentasjonen oppsummerer teknikker for arkitektur-gjennomgang som er tilgjengelig i industrien, forskjellene mellom dem, og hvordan man kan tilpasse dem til sin prosjektkontekst
De fleste organisasjoner som driver softwareprosjekter har en eller annen type arkitekturgjennomgang / review-aktivitet, men flertallet av dem bruker ad hoc teknikker og har ingen systematisk tilnærming. Som en konsekvens av dette leverer de ikke en nyttig analyse av hva som har blitt, eller skal bli, produsert. En vesentlig årsak til dette er at det er få arkitekter i bransjen som er klar over de teknikker for arkitektur-gjennomgang som finnes, eller som vet hvordan de skal bruke dem i praksis.

To achieve new insights within your company you don't necessarily have to accumulate and crunch a lot of new tracking and tracing data - much key information already exists in disconnected data silos, stored in different databases and systems. By bringing the relevant pieces together in a single place and connecting the pieces of the puzzle at the right points you can gain new insights into your existing data and business.
Graph databases offer the unique opportunity to easily cross-reference and connect disparate, variably structured datasets from many sources in a single place. It is then available for ad-hoc querying and exploration as well as strategic decision making. As a graph is a flexible and malleable data structure, it can evolve as you add new datasets or draw new connections from the insights or assumptions gained. This source of decision making will not be your old-school MDM data cemetery, but a flexible instrument that you can use, reuse, discard and recreate for different goals and purposes. Getting the data into the graph is only one interesting side of the coin, the other similarly challenging one is how to make the freshly spun web of knowledge available for different types of users. Technical users have it easy - they can yield Cypher, a powerful graph query language for arbitrary graph pattern matching, filtering, projection and aggregation of relevant data. For non-technical users a variety of tools and toolkits are available that use the inherent structures and meta information of the graph (labels, types, relationships and properties) to provide visual or natural language interaction to drill down, look at interesting facets, connect and correlate interesting information. Under the hood those tools use the same graph query language to do their job. This talk will cover both aspects of this exciting opportunity. We'll look at how to aggregate, import and connect information from disparate data-sources into a dynamic, flexible graph model and the means, tools and techniques for graph search and discovery on top of that fabric. The tools we use are the graph database Neo4j, its query language Cypher which also provides comprehensive import and data transformation abilities, as well as several tools and libraries from the Neo4j ecosystem to provide visual and textual graph search and exploration.

The container abstraction hit the collective developer mind with great force the past two years and created a space of innovation for the distribution, configuration and deployment of cloud based applications. Now that this new model has established itself, work is moving towards orchestration and coordination of loosely coupled network services. There is an explosion of tools in this arena at different degrees of stability but the momentum is huge. In this session we'll cover an overview of the orchestration landscape - Kubernetes, Mesos, Helios, etc. -, give an introduction to Docker's own orchestration tools - machine, swarm and compose - and show a (semi)live demo of how they work in practice.
The container abstraction hit the collective developer mind with great force and created a space of innovation for the distribution, configuration and deployment of cloud based applications. Now that this new model has established itself work is moving towards orchestration and coordination of loosely coupled network services. There is an explosion of tools in this arena at different degrees of stability but the momentum is huge. On the above premise this session we'll delve into a selection of the following topics: - Two minute Docker intro refresher - Overview of the orchestration landscape (Kubernetes, Mesos, Helios and Docker tools) - Introduction to Docker own ecosystem orchestration tools (machine, swarm and compose) - Live demo of cluster management using a sample application. A basic understanding of Docker is suggested to fully enjoy the talk.

42 IntelliJ tips & tricks in 10 minutes
A whirlwind tour of some of the most powerful features in IntelliJ IDEA, this lightning talk should have something to offer both rookies and seasoned Java veterans. Covers the basic stuff that every developer needs to know, as well as more advanced features like multi-cursor editing and postfix code completion. We’ll also look at how customizing IntelliJ can further improve your coding speed (and avoid repetitive strain injury) by using techniques such as two-stroke keyboard shortcuts and custom live templates. The talk focuses on pure Java editing features, and not so much on tools, framework integration and other languages.

Du er ikke garantert at alle klassene og metodene du kompilerte med er tilgjengelig når du kjører programmet ditt. Jeg viser deg hvorfor du får NoSuchMethodError og NoClassDefFoundError, og hvordan du kan unngå det!
Selv om Java er kompilert, statisk og sterk typet er du ikke garantert at alle klassene og metodene du kompilerte med er tilgjengelig når du kjører programmet ditt. De klassene og metodene du har tilgjengelig i programmet ditt avgjøres av hvilke jar-filer som ligger på class path. Har du oversikt over hvilke avhengigheter du har, både direkte og transitivt? Er du sikker på at alle avhengighetene du har er kompatible? Jeg vil fortelle deg hvorfor NoSuchMethodError og NoClassDefFoundError oppstår, og hvordan du ved hjelp av bytekode-analyse under bygging kan bli sikrere på at de ikke oppstår på produksjonsserveren din!

Learn how to use the Java Mission Control/Java Flight Recorder profiling tool available in the Oracle JDK
In this lab the attendees will learn how to use the Java Mission Control tool and especially Java Flight Recorder. We will show how to create flight recordings both from command line and from within the JMC UI. We will look at how to analyze the recording data to find potential performance problems. Problem areas include Excessive GC, Synchronization problems and finding execution hotspots.

Mange mobilapplikasjoner har som hovedmål å tilby søkbart innhold fra server. Samtidig skal de fungere offline også. Og det skal gå raskt! Her smelter Couchbase og ElasticSearch sammen til en himmelsk kombinasjon: Jeg vil gå gjennom hvordan du enkelt og raskt kan oppnå offline lagring, rask og enkel synkronisering av innhold og et kraftig søk ved å kombinere Couchbase Lite, Couchbase Server og ElasticSearch.
Selv i dagens tilkoblede samfunn vil du ikke kunne unngå å fra tid til annen være offline, enten det er på hytten, i utlandet, i kjelleren eller på butikken. Dette må vi som utviklere ta inn over oss. Vi må ikke bare ta hensyn til det, men vi bør utvikle for en offline tilstand! Trenger du virkelig å synkronisere med server for hver sidelasting? Må dataene brukeren legger inn ligge på server umiddelbart? Nei, men det bør være så sømløst som mulig for brukeren å hoppe mellom online og offline tilstand. Ved å bruke Couchbase Lite, kombinert med Couchbase SyncGateway, kan applikasjonen lagre data i den lokale databasen på mobilen, og så synkroniseres dataene til server som en bakgrunnsjobb når mobilen får nettverkstilgang. Tilsvarende kan innhold synkroniseres fra server til mobilen, slik at det er tilgjengelig offline til en hver tid. Dermed har man også eliminert mye ventetid som går med til kommunikasjon med serveren, og appen kjører like raskt enten den er på Wifi, mobilnettet eller er offline. Samtidig ønsker vi å tilby en rikere opplevelse når brukeren er online. Kraftig fritekstsøk er en slik funksjonalitet, og Elasticsearch er en av teknologiene som leder an her. Jeg skal vise hvordan ElasticSearch kan brukes til å indeksere og søke i dokumenter fra Couchbase, og kombineres med Couchbase Lite for å servere innhold med veldig høy hastighet.

Building Microservice Architectures describes this architectural style, as exemplified by Netflix and Amazon, as the first post-DevOps revolution architecture. This session describes context, what problem are we solving, characteristics of microservice architectures, and engineering practices.
Inspired by success stories from companies such as Amazon and Netflix, many organizations are moving towards microservice architectures at a brisk pace. This style of architecture is important because it’s the first architecture to fully embrace the Continuous Delivery and DevOps revolutions. In this session, I cover the motivations for building a microservice architecture (including making the distinction between “regular SOA” and microservices), some considerations you must make before starting (such as transactions versus eventual consistency), how to determine service partition boundaries, and ten tips to dowse you towards success. I also discuss the role of polyglot development, enterprise governance, how data and databases fit into this new world, and tooling to help ensure consistency between core services like logging and monitoring. This session provides a thorough overview of the pros and cons for microservice architectures, when it is applicable, and some nascent best practices.

The EcmaScript 2015 spec - that's the biggest upgrade to the JavaScript language ever - was finalized this summer. Many of the new features are already available in many browsers, and made available by an even wider range of transpilers, frameworks and other tools. ES2015 (aka ES6) does not disappoint - it adds new useful features, and in true JavaScript style, some new WTFs are thrown in for good measure as well. In this talk I'll take you on a tour of the JavaScript of tomorrow (or today, if you don't mind a compiler) and show you what a wonderful (and terrifying) world it is.
I will walk through the most interesting features of EcmaScript 2015/6, show which old JavaScript features you can now safely forget, and spice it all up with some weird gotchas introduced by the language upgrade.

As a former member of the Formula Student team from NTNU, Revolve NTNU, I will talk about our experiences using WebSockets to provide real-time telemetry to connected clients running on mobile platforms or in a web browser.
“The internet of things”, we are told, is coming. Everything, everywhere, is going to be online. I presume that also means our cars. We are also told that racing is where the innovation is happening, that what’s being developed for the race track now will trickle down to our cars in a few years’ time. I can’t wait for my car to have 3D printed titanium wheel hubs, and WebSockets. Last year I participated in what is probably Norway’s toughest student project, Revolve NTNU. As a team of 46 devoted students, we were building Norway’s first electric race car. Competing with top students from 114 other schools and universities from all over the world, the competitions took place in both Germany and the UK. If we wanted to compete against the best, we needed not only to build a really, really good car, but we needed to train our drivers and set up the car properly. This is the story of how we used WebSockets to democratize our live telemetry data.

I denne lyntalen vil du se hvordan et spill går fra å være "dum" til å gradvis bli sterkere etter hvert som vi utforsker bedre maskinlæringsteknikker. Kom på lyntalen og lær hvordan!
Denne lyntalen gir deg innsikt i noen enkle teknikker innen Maskinlæring og hvordan du med disse kan få en datamaskin til å spille et hvilket som helst brettspill, slik som 4-på-rad, kinasjakk, Ludo, Monopol. Du vil få en praktisk tilnærming med kodeeksempler fra et Java-basert Open Source spill som er lette å forstå og som du selv kan bygge videre på. I lyntalen skal vi først se på enkle linære algoritmer som bruker vekter for å evaluere tilstander. Deretter ser vi på mer avanserte teknikker som mønstergjenkjenning i observerte data med Nevrale Nettverk. For å gjøre det enklest mulig for deg å ta i bruk maskinlæring, vil foredraget begrense seg til hvordan en datamaskin lærer ved hjelp treningsdata. Etter lyntalen vil du ha et utgangspunkt med kodeeksempler og verktøy for å teste ut maskinlæring i egne prosjekter.

The case for running an own datacenter is vanishing rapidly. The cloud seduces with a low barrier of entry and full flexibility. Infrastructure can be spun up almost instantly in a fully automated way through an API. All this with no upfront costs and the ability to decommission it just as fast. But what does this mean for our applications and their architecture? Can we just lift and shift them to the cloud? Everything comes at a price. To be able to fully leverage the potential of the cloud, new challenges must be mastered: from data privacy and security to cost-based architectures, dynamic provisioning, service discovery and efficient deployment models. This talk provides architects and developers clear answers and battle-tested solutions for a successful journey to infrastructure heaven.
The case for running an own datacenter is vanishing rapidly. The cloud seduces with a low barrier of entry and full flexibility. Infrastructure can be spun up almost instantly in a fully automated way through an API. All this with no upfront costs and the ability to decommission it just as fast. But what does this mean for our applications and their architecture? Can we just lift and shift them to the cloud? Everything comes at a price. To be able to fully leverage the potential of the cloud, new challenges must be mastered: from data privacy and security to cost-based architectures, dynamic provisioning, service discovery and efficient deployment models. This talk provides architects and developers clear answers and battle-tested solutions for a successful journey to infrastructure heaven.

Istedenfor å bruke år på å utbrodere arkitekturtegninger for å sikre at en ikke gjør et galt valg på noe som blir vanskelig å endre, bør man rett og slett bruke tiden på å bygge.
Når man bygger må man sørge for å og holde seg innenfor prinsippene om å unngå synkrone kall, sørg for robusthet ift feil, automatiser så langt som mulig testing, utrulling, overvåking og sørg for at «deploy» er en «ikke-hendelse».

